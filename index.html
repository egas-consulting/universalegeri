<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Universul Rom√¢nesc</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        *, *:before, *:after { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            overflow-x: hidden;
            background-color: #000;
            color: #fff;
        }

        .headline-wrapper {
            position: relative;
            z-index: 3;
            text-align: center;
            padding-top: 8vh;
            padding-bottom: 4vh;
            color: white;
        }

        .cosmic-supratitle {
            font-family: 'Roboto', sans-serif;
            font-size: 1.6em;
            font-weight: 300;
            color: white;
            text-shadow: 0 0 6px #88b5ff, 0 0 10px #5573d6;
            margin-bottom: 10px;
        }

        .cosmic-title {
            font-family: 'Roboto', sans-serif;
            font-size: 1.8em;
            font-weight: 400;
            padding: 0 6vw;
            line-height: 1.4;
            color: white;
            text-shadow: 0 0 6px #88b5ff, 0 0 12px #335bc4;
        }

        .text-container {
            max-width: 600px;
            margin: 0 auto;
            padding: 0 5vw;
            padding-top: 5vh;
            color: #fff;
        }

        p {
            text-align: center;
            font-size: 1em;
            margin: 1em 0;
        }


        .chart-wrapper {
            position: relative;
            height: 250vh;
            margin-bottom: 5vh;
        }

        .chart-container {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100vh;
            background: radial-gradient(ellipse at center, #0b1f4c 0%, #000000 100%);
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.6s ease;
        }


        .svg-inner {
            width: 100%;
            max-width: 1000px;
            position: relative;
        }
        svg {
            width: 100%;
            height: auto;
            display: block;
            background-color: transparent;
            overflow: visible; 
        }


        .tooltip {
            position: absolute;
            background: rgba(255,255,255,0.95);
            border: 1px solid #aaa;
            padding: 0.85em 1em;
            font-size: 0.9em;
            pointer-events: none;
            opacity: 0;
            z-index: 10; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            border-radius: 4px;
            max-width: 90vw;
            min-width: 80px;
            color: #333;
            transition: opacity 0.2s ease;
        }

        .top-spacer { height: 15vh; }


        #search-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 11;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            display: none;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            max-width: 90vw;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
        }
         #search-container.visible {
            display: block;
            opacity: 1;
            pointer-events: auto;
         }
        #search-input, #clear-search, #winner-filter {
            padding: 8px 12px;
            font-size: 0.9em;
            margin: 4px;
            border: 1px solid #555;
            border-radius: 5px;
            background-color: #333;
            color: #eee;
        }
        #search-input::placeholder { color: #aaa; }
        #clear-search {
            padding: 8px 10px;
            margin-left: 6px;
            cursor: pointer;
            background-color: #555;
            border-color: #777;
        }
         #clear-search:hover { background-color: #666; }
        #winner-filter {
            cursor: pointer;
            background-color: #333;
             border-color: #555;
             color: #eee;
             flex-grow: 1;
             min-width: 150px;
        }
        #search-container > div {
             display: flex;
             align-items: center;
             gap: 5px;
             flex-wrap: wrap;
         }
         #search-container > div:last-child { margin-top: 8px; }
         #search-container label {
             color: white;
             margin-right: 6px;
             font-size: 0.9em;
             white-space: nowrap;
         }


        #scatter-steps {
            position: relative;
            z-index: 5;

             margin-top: 100vh;
             padding-top: 1vh;
             padding-bottom: 5vh;
        }
        .step {
            position: relative;
            max-width: min(90vw, 340px);

            margin: 70vh auto;
            padding: 1.25em 1.5em;
            background: rgba(255,255,255,0.92);
            border-radius: 8px;
            font-size: .95em;
            line-height: 1.35;
            box-shadow: 0 2px 10px rgba(0,0,0,.25);
            color: #333;
        }

         .step:first-child { margin-top: 40vh; }
         .step:last-child { margin-bottom: 50vh; }


        #sphere-intro{
            position:fixed; inset:0; z-index:6; display:flex;
            flex-direction:column; justify-content:center; align-items:center;
            text-align:center; gap:1.5rem; font-family:'Roboto',sans-serif;
            background:rgba(0,0,0,0.88); color:#fff; opacity:1;
            pointer-events:auto; transition:opacity .6s ease;
        }
        #sphere-intro h2{font-size:2rem; margin:0;}
        #sphere-intro p {font-size:1rem; line-height:1.4; margin:0;}
        #sphere-intro button{
            padding:.6rem 1.4rem; font-size:1rem; border:none; border-radius:6px;
            background:#88b5ff; color:#000; cursor:pointer;
        }
        #sphere-intro.hidden{ opacity:0; pointer-events:none; }


        #flourish-block{
            padding: 10vh 0 6vh;
            background: #000;
            text-align:center;
            position:relative;
            z-index:3;
        }
        .scatter-plot-container {
            max-width: 950px;
            width: 92%;
            margin: 10vh auto;
            background-color: rgba(11, 31, 76, 0.2);
            border-radius: 8px;
            padding: 25px 15px 15px 15px; 
            box-shadow: 0 0 15px rgba(136, 181, 255, 0.15);
        }
        .scatter-explainer {
            font-size: 0.9em; color: #ccc; margin-top: 10px;
            max-width: 850px; margin-left: auto; margin-right: auto;
            padding: 0 15px; line-height: 1.4; text-align: center;
        }


        .axis path, .axis line { stroke: #aaa; stroke-width: 0.5; shape-rendering: crispEdges; }
        .axis text { fill: #ccc; font-weight: 300; font-size: 10px; }
        .axis-label { fill: #ddd; font-size: 0.85em; text-anchor: middle; }
        .plot-title { fill: #fff; font-size: 1.25em; font-weight: 600; text-anchor: middle; }
        .map-title { fill: #fff; font-size: 1.3em; font-weight: 600; text-anchor: middle; }
        .map-subtitle { fill: #ccc; font-size: 0.9em; text-anchor: middle; }
        .quadrant-line { stroke: #ffffff; stroke-dasharray: 3 3; stroke-width: 1.5px; opacity: 0.8; }
        .quadrant-label { /* Base style for all quadrant labels */
            fill: #ffffff;
            font-size: 1em;
            font-weight: 400;
            opacity: 0.9;
         }
         .quadrant-label-outer { 
             font-size: 0.75em;
             fill: #ccc;
             opacity: 0.85;
         }
         .quadrant-overlay {
             fill: #ffffff;
             opacity: 0;
             pointer-events: none;
             transition: opacity 0.3s ease;
         }


        @media (max-width: 600px) {
             #search-container {
                 top: 10px; left: 50%; right: auto; transform: translateX(-50%);
                 width: 90vw; max-width: 350px; padding: 8px 10px;
             }
             #search-container > div {
                 flex-direction: column; align-items: stretch; width: 100%; gap: 6px;
             }
             #search-input, #clear-search, #winner-filter, #search-container label {
                 font-size: 0.85em; width: 100%; margin: 0; box-sizing: border-box;
             }
             #search-input { padding: 7px 10px; }
              #clear-search { padding: 7px 10px; margin-top: 4px; }
             #search-container label { margin-bottom: 4px; text-align: center; margin-right: 0; }
             #winner-filter { padding: 7px 10px; min-width: 0; }
             #search-container > div:last-child { margin-top: 10px; }

            .scatter-plot-container {
                width: 98%; padding: 10px 5px 5px 5px; margin: 5vh auto; box-shadow: none;
            }
            .scatter-explainer { padding: 0 5px; font-size: 0.8em; margin-top: 8px; line-height: 1.3; }
             .plot-title { font-size: 1.1em; }
             .axis-label { font-size: 0.75em; }

             .quadrant-label {
                 font-size: 0.65em; 
             }
             .quadrant-label-outer {
                  font-size: 0.6em; 
             }

             .axis text { font-size: 9.5px; }


            .step { margin: 60vh auto; }
            .step:first-child { margin-top: 30vh; }
            .step:last-child { margin-bottom: 40vh; }

            .map-title { font-size: 1.15em; }
            .map-subtitle { font-size: 0.85em; }
            .cosmic-title { font-size: 1.5em; }
            .cosmic-supratitle { font-size: 1.3em; }
        }


        body { min-height: 500vh; }
        html,body{ overscroll-behavior: none; }

    </style>
</head>
<body>
    <div class="headline-wrapper">
        <div class="cosmic-supratitle">Universul Rom√¢nesc</div>
        <h1 class="cosmic-title">
            C√¢t de mult impacteazƒÉ statutul socio-economic al localitƒÉ»õilor rezultatele la preziden»õiale
        </h1>
    </div>
    <div class="text-container">
        <p>
            Am corelat <strong>rezultatele ob»õinute</strong> »ôi <strong>prezen»õa</strong> √Æn alegerile preziden»õiale din 2024.<br>
            <strong>Scroll</strong> pentru a explora vizualizarea interactivƒÉ principalƒÉ. Mai jos gƒÉsi»õi analize detaliate pe indicatori specifici.<br>
            <i>Filtrele »ôi cƒÉutarea (sus dreapta) se aplicƒÉ tuturor graficelor.</i>
        </p>
    </div>

    <div id="search-container">
        <div>
            <input id="search-input" type="text" placeholder="CautƒÉ localitate..." list="localitati-list">
            <button id="clear-search" title="ReseteazƒÉ cƒÉutarea">Reset</button>
            <datalist id="localitati-list"></datalist>
        </div>
        <div >
            <label for="winner-filter">FiltreazƒÉ dupƒÉ c√¢»ôtigƒÉtor:</label>
            <select id="winner-filter">
                <option value="all">To»õi</option>
                <option value="ION-MARCEL CIOLACU">ION-MARCEL CIOLACU</option>
                <option value="NICOLAE-IONEL CIUCƒÇ">NICOLAE-IONEL CIUCƒÇ</option>
                <option value="ELENA-VALERICA LASCONI">ELENA-VALERICA LASCONI</option>
                <option value="GEORGE-NICOLAE SIMION">GEORGE-NICOLAE SIMION</option>
                <option value="HUNOR KELEMEN">HUNOR KELEMEN</option>
                <option value="CƒÇLIN GEORGESCU">CƒÇLIN GEORGESCU</option>
            </select>
        </div>
    </div>

    <div class="top-spacer"></div>

    <div class="chart-wrapper">
        <div class="chart-container" id="chart-container">
            <div class="svg-inner">
                <svg id="viz" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet"></svg>
            </div>
        </div>
    </div>

    <div id="sphere-intro">
        <h2>Universul Rom√¢nesc</h2>
        <p>Am analizat rezultatele din primul tur al alegerilor preziden»õiale din 2024<br>
            »ôi le-am corelat cu 8 indicatori economici »ôi sociali relevan»õi, <br>
            pentru a √Æn»õelege cum influen»õeazƒÉ ace»ôtia op»õiunile electorale.<br>
            Fiecare cerc din grafic este interactiv. Scroll pentru a explora toate sec»õiunile.
        </p>
        <button id="intro-ok">√éncepe</button>
    </div>

    <section id="scatter-steps">
        <div class="step" data-quad="I">
            <p><strong>Cum este √ÆmpƒÉr»õit graficul</strong><br>
                Fiecare grafic este √ÆmpƒÉr»õit √Æn patru pƒÉr»õi, folosind valorile mediane de pe fiecare axƒÉ pentru a identifica tipare clare √Æntre localitƒÉ»õi</p>
        </div>
        <div class="step" data-quad="II">
            <p><strong>Cum interpretezi cadranele</strong><br>
                Astfel, fiecare axƒÉ creeazƒÉ o linie de referin»õƒÉ echitabilƒÉ, iar cele patru cadrane aratƒÉ combina»õii diferite de situa»õii (de exemplu: localitƒÉ»õi cu valori mari pe ambele axe, sau localitƒÉ»õi cu o valoare mare pe una »ôi micƒÉ pe cealaltƒÉ).</p>
        </div>
        <div class="step" data-quad="III">
            <p><strong>De ce sunt utile cadranele</strong><br>
                √én loc sƒÉ analizƒÉm fiecare indicator separat, vedem rapid cum se leagƒÉ √Æntre ele douƒÉ variabile importante. Astfel, putem √Æn»õelege mai bine rela»õia dintre factori economici, sociali sau politici »ôi op»õiunile electorale sau dezvoltarea localƒÉ.</p>
        </div>
        <div class="step" data-quad="IV">
            <p><strong>CautƒÉ localitatea sau filtreazƒÉ informa»õia</strong><br>
                Graficul este interactiv: po»õi plasa cursorul pe un cerc pentru a vedea detalii, cƒÉuta direct o localitate sau filtra localitƒÉ»õile dupƒÉ candidatul c√¢»ôtigƒÉtor.</p>
        </div>
         <div class="step" data-quad="all"> <!-- This step helps reset when scrolling past the last specific quadrant step -->
             <p><strong>Scroll √Æn continuare pentru a explora graficele</strong></p>
         </div>
    </section>

    <section id="flourish-block">
        <h2 class="cosmic-title" style="margin-bottom: 5vh; padding-top: 5vh;">Analiza detaliatƒÉ pe indicatori statici</h2>
        <div id="scatter-container-1" class="scatter-plot-container">
            <svg id="scatter-viz-1" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce poate spune despre o comunitate combina»õia dintre v√¢rsta medie a popula»õiei »ôi suprafa»õa locuibilƒÉ disponibilƒÉ pe persoanƒÉ?</strong> <br> Prin aceastƒÉ distribu»õie √Æn scatter plot, observƒÉm contraste clare √Æntre regiuni: localitƒÉ»õile din dreapta sus, cu v√¢rstƒÉ medie ridicatƒÉ »ôi spa»õiu generos, sunt adesea foste ora»ôe istorice sau zone de vacan»õƒÉ unde popula»õia t√¢nƒÉrƒÉ a migrat. La polul opus, ora»ôele mici sau cartierele vechi, unde popula»õia √ÆmbƒÉtr√¢nitƒÉ locuie»ôte √Æn spa»õii modeste, se regƒÉsesc √Æn partea de jos a graficului. Acela»ôi tipar apare »ôi √Æn zonele rurale sƒÉrace.

                √én st√¢nga sus, gƒÉsim suburbii »ôi localitƒÉ»õi periurbane prospere, unde familiile tinere locuiesc √Æn case mari, √Æn timp ce st√¢nga jos reflectƒÉ ora»ôele mari aglomerate, dominate de tineri care trƒÉiesc √Æn locuin»õe mai mici.

                AceastƒÉ combina»õie de indicatori deschide o fereastrƒÉ spre √Æn»õelegerea dinamicii sociale, economice »ôi istorice a comunitƒÉ»õilor.</p>
        </div>
        <div id="scatter-container-2" class="scatter-plot-container">
            <svg id="scatter-viz-2" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce ne aratƒÉ rela»õia dintre plecƒÉrile cu domiciliul »ôi »ôomajul local?</strong><br>PlecƒÉrile cu domiciliul raportate la popula»õie sunt un indicator direct al mobilitƒÉ»õii »ôi al nivelului de atractivitate al unei comunitƒÉ»õi. Ponderea »ôomerilor reflectƒÉ presiunea economicƒÉ localƒÉ »ôi oportunitƒÉ»õile de muncƒÉ disponibile.

                Zonele cu rate mari de plecare »ôi »ôomaj ridicat indicƒÉ adesea o spiralƒÉ a declinului: lipsƒÉ de oportunitƒÉ»õi, migra»õie economicƒÉ, depopulare acceleratƒÉ. √én schimb, comunitƒÉ»õile unde plecƒÉrile sunt reduse »ôi »ôomajul scƒÉzut demonstreazƒÉ stabilitate »ôi capacitatea de a-»ôi pƒÉstra popula»õia activƒÉ.

                AceastƒÉ combina»õie de indicatori ajutƒÉ la identificarea zonelor vulnerabile, dar »ôi a celor care reu»ôesc sƒÉ reziste presiunilor demografice »ôi economice.</p>
        </div>
        <div id="scatter-container-3" class="scatter-plot-container">
            <svg id="scatter-viz-3" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce poate spune rela»õia dintre numƒÉrul de salaria»õi »ôi veniturile fiscale locale?</strong><br>NumƒÉrul de salaria»õi raportat la popula»õie indicƒÉ dinamismul economic al unei comunitƒÉ»õi: c√¢»õi dintre locuitori contribuie activ la economie. Cota de impozit pe cap de locuitor aratƒÉ c√¢t de mult reu»ôe»ôte administra»õia localƒÉ sƒÉ colecteze din impozitele locale pe venituri »ôi proprietƒÉ»õi.

                Zonele cu mul»õi salaria»õi »ôi cote fiscale mari per locuitor pot semnala comunitƒÉ»õi prospere, cu economie diversificatƒÉ »ôi administra»õie performantƒÉ. √én schimb, zonele cu pu»õini salaria»õi »ôi venituri fiscale scƒÉzute indicƒÉ adesea probleme structurale ‚Äì lipsa locurilor de muncƒÉ, migra»õie, economie informalƒÉ sau o administra»õie slabƒÉ.

                AceastƒÉ combina»õie de indicatori surprinde echilibrul dintre for»õa de muncƒÉ activƒÉ »ôi capacitatea realƒÉ a comunitƒÉ»õilor de a se sus»õine financiar.</p>
        </div>
        <div id="scatter-container-4" class="scatter-plot-container">
            <svg id="scatter-viz-4" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce poate spune rela»õia dintre fondurile europene atrase pe cap de locuitor »ôi numƒÉrul de pacien»õi care revin unui medic?</strong><br>AceastƒÉ combina»õie de indicatori oferƒÉ o perspectivƒÉ asupra modului √Æn care investi»õiile publice influen»õeazƒÉ accesul la servicii medicale. Fondurile europene atrase nu sunt direc»õionate exclusiv cƒÉtre sƒÉnƒÉtate, √ÆnsƒÉ dezvoltarea infrastructurii √Æn ansamblu ‚Äî drumuri mai bune, servicii publice modernizate, condi»õii de trai mai atractive ‚Äî poate contribui la stabilizarea sau atragerea de profesioni»ôti, inclusiv √Æn domeniul medical. AceastƒÉ combina»õie de indicatori oferƒÉ o perspectivƒÉ asupra modului √Æn care investi»õiile publice influen»õeazƒÉ accesul la servicii medicale. Fondurile europene atrase nu sunt direc»õionate exclusiv cƒÉtre sƒÉnƒÉtate, √ÆnsƒÉ dezvoltarea infrastructurii √Æn ansamblu ‚Äî drumuri mai bune, servicii publice modernizate, condi»õii de trai mai atractive ‚Äî poate contribui la stabilizarea sau atragerea de profesioni»ôti, inclusiv √Æn domeniul medical.</p>
        </div>
    </section>

    <div class="tooltip" id="tooltip"></div>

    <script>

        let allDataGlobal;
        const mainWidth = 1000, mainHeight = 700;
        const plotWidth = 900, plotHeight = 550;
        // Increased static plot margins slightly to make room for outer labels
        const margin = { top: 60, right: 50, bottom: 50, left: 70 };
        // Increased main plot margins slightly to make room for outer labels
        const marginMain = { top: 60, right: 70, bottom: 60, left: 80 };

        const baseCircleDiameter = window.innerWidth <= 600 ? 9 : window.innerWidth > 800 ? 4 : 3.5;

        const svgMain = d3.select("#viz");
        const tooltip = d3.select("#tooltip");
        const chartMain = svgMain.append("g").attr("id", "chartGroup");
        const searchEl = d3.select("#search-container");

        const winnerColors = {
            "ION-MARCEL CIOLACU": "#FF2A1F", "NICOLAE-IONEL CIUCƒÇ": "#00B7FF",
            "ELENA-VALERICA LASCONI": "#D066F2", "GEORGE-NICOLAE SIMION": "#FFB623",
            "HUNOR KELEMEN": "#36FC00", "CƒÇLIN GEORGESCU": "#865750"
        };
        const colorScale = d3.scaleOrdinal(Object.keys(winnerColors), Object.values(winnerColors));

        let currentView = "sphere";
        let currentFilter = "all";
        let mainCircles;
        let staticCircles = [];
        let staticConfigs = {};
        let activeQuad = "all";
        let mainScatterConfig = {};
        let staticPlotsVisible = false;
        let observerInitialized = false;


        const normalize = str => (str || "").toString().normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().trim();


        function showSearchControls() { searchEl.classed("visible", true); }
        function hideSearchControls() { searchEl.classed("visible", false); }
        function updateSearchControlsVisibility() {
            if ((currentView === 'map' || currentView === 'scatter') || staticPlotsVisible) {
                showSearchControls();
            } else {
                hideSearchControls();
            }
        }


        function basicTooltip(d) {
            return `<strong>${d.jud}</strong><br/>${d.uat}<br/>C√¢»ôtigƒÉtor: ${d.Castigator}<br/>Procent: ${d["Procent castigator"]}%<br/>Prezen»õa: ${d.Prezenta}%`;
         }
        function scatterTooltip(d, config) {
            const xValue = d[config.xField] !== undefined && d[config.xField] !== null ? d[config.xField].toFixed(config.xDecimals ?? 2) : 'N/A';
            const yValue = d[config.yField] !== undefined && d[config.yField] !== null ? d[config.yField].toFixed(config.yDecimals ?? 2) : 'N/A';
            return `<strong>${d.jud}</strong><br/>${d.uat}<br/>${config.xLabel}: ${xValue}${config.xUnit ?? ''}<br/>${config.yLabel}: ${yValue}${config.yUnit ?? ''}<br/>C√¢»ôtigƒÉtor: ${d.Castigator}<br/>Procent: ${d["Procent castigator"]}%<br/>Prezen»õa: ${d.Prezenta}%`;
         }
         function updateTooltipPosition(event) {
            const tRect = tooltip.node().getBoundingClientRect();
            let left = event.pageX + 10, top = event.pageY - 15;
            const marginTT = 10; // Tooltip margin
            if (left + tRect.width > window.innerWidth - marginTT) left = event.pageX - tRect.width - 10;
            if (top + tRect.height > window.innerHeight - marginTT) top = event.pageY - tRect.height - 5;
            if (top < marginTT) top = marginTT;
            if (left < marginTT) left = marginTT;
            tooltip.style("left", left + "px").style("top", top + "px");
         }


        function createSpherePositions(data, radius = 250){
            data.forEach((d,i) => {
                const phi = Math.acos(-1 + (2 * i) / data.length);
                const theta = Math.sqrt(data.length * Math.PI) * phi;
                d.sphere_x = radius * Math.sin(phi) * Math.cos(theta);
                d.sphere_y = radius * Math.sin(phi) * Math.sin(theta);
                d.sphere_z = radius * Math.cos(phi);
            });
        }
        let rotationAngle = 0;
        const sphereAnimation = anime({
            targets: { angle: 0 }, angle: 2 * Math.PI, duration: 35000, easing: 'linear',
            loop: true, autoplay: false,
            update: anim => {
                rotationAngle = anim.animations[0].currentValue;
                if (currentView === "sphere") updateSphereVisuals();
            }
        });
        function updateSphereVisuals() {
            const f = 400, cx = mainWidth / 2, cy = mainHeight / 2;
            if (!mainCircles) return;
            mainCircles.each(function(d) {
                const xRot = d.sphere_x * Math.cos(rotationAngle) - d.sphere_z * Math.sin(rotationAngle);
                const zRot = d.sphere_x * Math.sin(rotationAngle) + d.sphere_z * Math.cos(rotationAngle);
                const scale = f / (f + zRot + 1e-6);
                d.display_x = cx + xRot * scale;
                d.display_y = cy + d.sphere_y * scale;
                d.base_sphere_r = Math.max(1, baseCircleDiameter * scale);
                d.display_opacity_z = Math.max(0.1, Math.min(1, (f - zRot) / (f * 1.5)));
            });
            applyGlobalFilterAndSearch();
        }


        function isPointInQuad(d, config, quad) {
            if (!config || !config.xField || !config.yField || !allDataGlobal) return false;
            // Use cached medians if available
            const xMedian = config._xMedian ?? (config._xMedian = d3.median(allDataGlobal, dataPoint => dataPoint[config.xField]));
            const yMedian = config._yMedian ?? (config._yMedian = d3.median(allDataGlobal, dataPoint => dataPoint[config.yField]));
            if (xMedian === undefined || yMedian === undefined || xMedian === null || yMedian === null) return false; // Medians invalid
            const xVal = d[config.xField], yVal = d[config.yField];
            if (xVal === undefined || yVal === undefined || xVal === null || yVal === null) return false; // Data point invalid

            let pointQuad = "";
            // Quadrant Definition: I=TopLeft, II=TopRight, III=BottomLeft, IV=BottomRight
            if (xVal <= xMedian && yVal >= yMedian) pointQuad = "I";
            else if (xVal > xMedian && yVal >= yMedian) pointQuad = "II";
            else if (xVal <= xMedian && yVal < yMedian) pointQuad = "III";
            else if (xVal > xMedian && yVal < yMedian) pointQuad = "IV";

            return pointQuad === quad;
         }


        function applyGlobalFilterAndSearch() {
            const searchTerm = normalize(d3.select("#search-input").property("value"));
            const isSearching = searchTerm.length > 0;
            const selectedWinner = d3.select("#winner-filter").property("value");
            currentFilter = selectedWinner;

            let areaScale;
            if (allDataGlobal) {
                const extent = d3.extent(allDataGlobal, d => d["Procent castigator"]);
                if (extent[0] !== undefined && extent[1] !== undefined) {
                    areaScale = d3.scaleSqrt().domain(extent).range([baseCircleDiameter * 0.8, baseCircleDiameter * 2.2]);
                }
            }

            // Raise exact search matches
            d3.selectAll(".data-circle").each(function(d) {
                if (isSearching && normalize(d.uat) === searchTerm) d3.select(this).raise();
            });

            // Apply filters and styles via transition
            d3.selectAll(".data-circle")
                .transition("filterSearch").duration(350)
                .attr("opacity", function(d) {
                    const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                    const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;

                    // Basic visibility check
                    if (!isWinnerMatch || !isSearchMatch) return 0.08;

                    let baseOpacity = 1.0;
                    const isMain = d3.select(this).classed('main-circle');
                    const isStatic = d3.select(this).classed('static-circle');

                    if (isStatic) {
                         const parentSvgId = d3.select(this.ownerSVGElement).attr('id');
                         const config = staticConfigs[parentSvgId];
                         // Dim static circles if their data is invalid for the plot axes
                         if(config && (d[config.xField] === null || d[config.yField] === null)) {
                             baseOpacity = 0.05;
                         } else {
                             baseOpacity = 0.75;
                         }
                    } else if (isMain) {
                        
                        if (currentView === 'sphere') {
                            baseOpacity = d.display_opacity_z ?? 1.0;
                        } else if (currentView === 'map') {
                            baseOpacity = (d.Lat && d.Long) ? 0.8 : 0; 
                        } else if (currentView === 'scatter') {
                            const config = mainScatterConfig;
                            const xVal = d[config.xField], yVal = d[config.yField];
                            const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;

                            if (!hasValidScatterData) return 0; 

                            const isQuadActive = activeQuad !== 'all';
                            const inActiveQuad = isQuadActive && isPointInQuad(d, config, activeQuad);

                            // Dim if a quad is active, BUT the point is not in the active quad
                            if (isQuadActive && !inActiveQuad) baseOpacity = 0.05;
                            else baseOpacity = 0.8; // Default scatter opacity
                        }
                    }

                    
                    if (isSearching && !exactSearchMatch && isWinnerMatch && isSearchMatch) {
                         baseOpacity *= 0.6;
                    }
                    // Highlight exact match
                    if (exactSearchMatch) {
                        baseOpacity = isStatic ? 0.9 : 1.0;
                    }

                    return Math.max(0.05, baseOpacity); 
                })
                .attr("stroke", function(d) {
                    const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                    const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;

                    if (!isWinnerMatch || !isSearchMatch) return "none"; 

                    if (exactSearchMatch) return "#FFFFFF"; 
                    if (currentFilter !== "all" && isWinnerMatch) return "#FFFFFF"; 

                    
                    const isMain = d3.select(this).classed('main-circle');
                    if (isMain && currentView === 'scatter' && activeQuad !== 'all') {
                         const config = mainScatterConfig;
                         const xVal = d[config.xField], yVal = d[config.yField];
                         const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                         if (hasValidScatterData && isPointInQuad(d, config, activeQuad)) {
                             return "#FFF"; 
                         }
                    }


                    return "none"; 
                })
                .attr("stroke-width", function(d) {
                     const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                     const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;

                     if (!isWinnerMatch || !isSearchMatch) return 0; 

                     const isMain = d3.select(this).classed('main-circle');

                     if (exactSearchMatch) return isMain ? 3 : 2.5; 
                     if (currentFilter !== "all" && isWinnerMatch) return 1; 

                     
                     if (isMain && currentView === 'scatter' && activeQuad !== 'all') {
                          const config = mainScatterConfig;
                          const xVal = d[config.xField], yVal = d[config.yField];
                          const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                          if (hasValidScatterData && isPointInQuad(d, config, activeQuad)) {
                              return 1; 
                          }
                     }


                     return 0; 
                 })
                 .attr("cx", function(d) {
                    if (currentView === 'sphere' && d3.select(this).classed('main-circle')) return d.display_x;
                    // Keep existing calculated cx for map/scatter if transitioning
                    return d3.select(this).attr("cx");
                 })
                 .attr("cy", function(d) {
                    if (currentView === 'sphere' && d3.select(this).classed('main-circle')) return d.display_y;
                    // Keep existing calculated cy for map/scatter if transitioning
                    return d3.select(this).attr("cy");
                 })
                 .attr("r", function(d) {
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                     const boostFactor = 1.8;
                     const isMain = d3.select(this).classed('main-circle');
                     let baseRadius = 0;

                     if (isMain) {
                         
                         if (currentView === 'sphere') {
                             baseRadius = d.base_sphere_r ?? 0;
                         } else if (currentView === 'map' && areaScale) {
                             baseRadius = (d.Lat && d.Long) ? areaScale(d["Procent castigator"]) : 0;
                         } else if (currentView === 'scatter') {
                             const config = mainScatterConfig;
                             const xVal = d[config.xField], yVal = d[config.yField];
                             baseRadius = (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 1.1 : 0;
                         }
                     } else { 
                          const parentSvgId = d3.select(this.ownerSVGElement).attr('id');
                          const config = staticConfigs[parentSvgId];
                          if (config) {
                              const xVal = d[config.xField], yVal = d[config.yField];
                             
                              baseRadius = (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 0.75 : 0;
                          } else {
                              baseRadius = 0; 
                          }
                     }

                     
                     baseRadius = (typeof baseRadius === 'number' && !isNaN(baseRadius)) ? baseRadius : 0;

                     
                     return (exactSearchMatch && baseRadius > 0) ? baseRadius * boostFactor : baseRadius;
                 })
                 
                 .style("pointer-events", function(d) {
                     const opacity = parseFloat(d3.select(this).attr("opacity"));
                     const radius = parseFloat(d3.select(this).attr("r"));
                     // Allow events only if reasonably visible and has size
                     return (opacity > 0.05 && radius > 0.1) ? 'auto' : 'none';
                 });
         }


        function createScatterPlot(containerSelector, data, config) {
             const svg = d3.select(containerSelector);
             const svgId = svg.attr('id');
             staticConfigs[svgId] = config; 
             config._xMedian = d3.median(data, d => d[config.xField]); 
             config._yMedian = d3.median(data, d => d[config.yField]); 

             svg.selectAll("*").remove(); 

            
             const plotGroup = svg.append("g")
                 .attr("transform", `translate(${margin.left},${margin.top})`);

             const innerWidth = plotWidth - margin.left - margin.right;
             const innerHeight = plotHeight - margin.top - margin.bottom;

             // Determine data extents and setup scales
             const xExtent = d3.extent(data, d => d[config.xField]);
             const yExtent = d3.extent(data, d => d[config.yField]);
             // Handle cases where extent might be undefined (e.g., no valid data)
             const xDomain = (xExtent[0] === undefined || xExtent[1] === undefined) ? [0, 1] : xExtent;
             const yDomain = (yExtent[0] === undefined || yExtent[1] === undefined) ? [0, 1] : yExtent;

             const x = d3.scaleLinear().domain(xDomain).nice().range([0, innerWidth]);
             const y = d3.scaleLinear().domain(yDomain).nice().range([innerHeight, 0]);

             const xMedian = config._xMedian; 
             const yMedian = config._yMedian; 

            // --- Draw Axes and Titles ---
            plotGroup.append("g").attr("class", "x-axis axis")
                .attr("transform", `translate(0,${innerHeight})`)
                .call(d3.axisBottom(x).ticks(7).tickSizeOuter(0));
            plotGroup.append("text").attr("class", "axis-label x-label")
                .attr("x", innerWidth / 2)
                .attr("y", innerHeight + margin.bottom - 10)
                .text(config.xLabelFull || config.xLabel);
            plotGroup.append("g").attr("class", "y-axis axis")
                .call(d3.axisLeft(y).ticks(7).tickSizeOuter(0));
            plotGroup.append("text").attr("class", "axis-label y-label")
                .attr("transform", "rotate(-90)")
                .attr("x", -innerHeight / 2)
                .attr("y", -margin.left + 15) 
                .text(config.yLabelFull || config.yLabel);
            plotGroup.append("text").attr("class", "plot-title")
                .attr("x", innerWidth / 2)
                .attr("y", -margin.top / 2) 
                .text(config.title);

           
            if (xMedian !== undefined && xMedian !== null) {
                plotGroup.append("line").attr("class", "quadrant-line")
                    .attr("x1", x(xMedian)).attr("x2", x(xMedian))
                    .attr("y1", 0).attr("y2", innerHeight);
            }
            if (yMedian !== undefined && yMedian !== null) {
                plotGroup.append("line").attr("class", "quadrant-line")
                    .attr("x1", 0).attr("x2", innerWidth)
                    .attr("y1", y(yMedian)).attr("y2", y(yMedian));
            }

            
            const isMobile = window.innerWidth <= 600;
            const outerLabelPadding = isMobile ? 15 : 20; 
            const outerLabelYOffset = isMobile ? -15 : -20; 
            const outerLabelYOffsetBottom = isMobile ? 20 : 35; 

            if (config.quadLabels && xMedian !== undefined && yMedian !== undefined && xMedian !== null && yMedian !== null) {
                 

                 
                 plotGroup.append("text").attr("class", "quadrant-label quadrant-label-outer")
                     .attr("x", innerWidth + outerLabelPadding) 
                     .attr("y", outerLabelYOffset) 
                     .attr("text-anchor", "end")
                     .text(config.quadLabels.II);

                 
                 plotGroup.append("text").attr("class", "quadrant-label quadrant-label-outer")
                     .attr("x", -outerLabelPadding) 
                     .attr("y", outerLabelYOffset) 
                     .attr("text-anchor", "start")
                     .text(config.quadLabels.I);

                 // Quadrant III (Bottom Left Corner Area) - Text anchored start, placed left of plot
                 plotGroup.append("text").attr("class", "quadrant-label quadrant-label-outer")
                     .attr("x", -outerLabelPadding) // Left of plot area
                     .attr("y", innerHeight + outerLabelYOffsetBottom) // Below plot area bottom
                     .attr("text-anchor", "start")
                     .text(config.quadLabels.III);

                 // Quadrant IV (Bottom Right Corner Area) - Text anchored end, placed right of plot
                 plotGroup.append("text").attr("class", "quadrant-label quadrant-label-outer")
                     .attr("x", innerWidth + outerLabelPadding) 
                     .attr("y", innerHeight + outerLabelYOffsetBottom) 
                     .attr("text-anchor", "end")
                     .text(config.quadLabels.IV);
             }
             
             const circles = plotGroup.selectAll(".data-circle")
                .data(data, d => d.uat + d.jud) 
                .enter().append("circle")
                .attr("class", "data-circle static-circle") 
                
                .attr("cx", d => { const val = d[config.xField]; return (val !== undefined && val !== null && !isNaN(x(val))) ? x(val) : -100; })
                .attr("cy", d => { const val = d[config.yField]; return (val !== undefined && val !== null && !isNaN(y(val))) ? y(val) : -100; })
                
                .attr("r", d => {
                    const xVal = d[config.xField];
                    const yVal = d[config.yField];
                    return (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 0.75 : 0;
                })
                .attr("fill", d => colorScale(d.Castigator) || "#999") 
                .attr("opacity", 0.75) 
                .attr("stroke", "none")
                .attr("stroke-width", 0)
               
                .style("pointer-events", d => {
                    const xVal = d[config.xField];
                    const yVal = d[config.yField];
                    return (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? 'auto' : 'none';
                })
               
                .on("mouseover", (event, d) => {
                   
                    const xVal = d[config.xField], yVal = d[config.yField];
                    if (xVal === undefined || xVal === null || yVal === undefined || yVal === null) return;

                    tooltip.style("opacity", 1).html(scatterTooltip(d, config)); // Show tooltip
                    d3.select(event.currentTarget).raise().attr("stroke", "#000").attr("stroke-width", 1.5); // Highlight
                })
                .on("mousemove", updateTooltipPosition) 
                .on("mouseout", (event, d) => {
                     
                     const xVal = d[config.xField], yVal = d[config.yField];
                     if (xVal === undefined || xVal === null || yVal === undefined || yVal === null) return;

                     tooltip.style("opacity", 0); // Hide tooltip

                   
                     const searchTerm = normalize(d3.select("#search-input").property("value"));
                     const isSearching = searchTerm.length > 0;
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                     const isHighlightedByFilter = currentFilter !== "all" && d.Castigator === currentFilter;

                     let finalStroke = "none", finalStrokeWidth = 0;
                     if (exactSearchMatch) { // Exact search match has priority
                         finalStroke = "#FFFFFF";
                         finalStrokeWidth = 2.5; // Slightly thinner for static plots
                     } else if (isHighlightedByFilter) { // Winner filter highlight
                         finalStroke = "#FFFFFF";
                         finalStrokeWidth = 1;
                     }
                     // Reset stroke based on persistent state (search/filter)
                     d3.select(event.currentTarget).attr("stroke", finalStroke).attr("stroke-width", finalStrokeWidth);
                });

             staticCircles.push(circles); // Keep track of static circle selections
             return circles; // Return the selection
         }


        
        d3.csv("scatter.csv", d3.autoType).then(data => {
            // Filter data: ensure essential fields exist
            allDataGlobal = data.filter(d => d.Lat && d.Long && d.Castigator && d.uat && d["Procent castigator"] != null);

           
            allDataGlobal.forEach(d => {
                // Convert "#DIV/0!" string in the specific column to null
                if (d["Pacienti la un medic 2023"] === "#DIV/0!") {
                    d["Pacienti la un medic 2023"] = null;
                }
                
            });
           
            const scatterConfig1 = { xField: "Varsta medie a populatiei in 2023", yField: "Suprafata locuibila/cap de locuitor (m patrati) 2023", xLabel: "V√¢rsta medie", yLabel: "Suprafa»õƒÉ/loc.", xUnit: " ani", yUnit: " m¬≤", xDecimals: 1, yDecimals: 1, title: "V√¢rsta medie a popula»õiei »ôi suprafa»õa locuibilƒÉ/cap de locuitor", xLabelFull: "V√¢rsta medie a popula»õiei (ani)", yLabelFull: "Suprafa»õƒÉ locuibilƒÉ/locuitor (m¬≤)", quadLabels: { I: "I. Tineri, Spa»õiu Mare", II: "II. V√¢rstnici, Spa»õiu Mare", III: "III. Tineri, Spa»õiu Mic", IV: "IV. V√¢rstnici, Spa»õiu Mic" } };
            const scatterConfig2 = { xField: "Procent plecari din populatie (2023)", yField: "Ponderea somerilor in 2023", xLabel: "PlecƒÉri", yLabel: "»òomeri", xUnit: "%", yUnit: "%", xDecimals: 1, yDecimals: 1, title: "PlecƒÉrile din localitate »ôi ponderea »ôomerilor", xLabelFull: "Procent plecƒÉri din popula»õie (%)", yLabelFull: "Pondere »ôomeri √Æn popula»õie (%)", quadLabels: { I: "I. Pu»õine plecƒÉri, »òomaj mare", II: "II. Multe plecƒÉri, »òomaj mare", III: "III. Pu»õine plecƒÉri, »òomaj mic", IV: "IV. Multe plecƒÉri, »òomaj mic" } };
            const scatterConfig3 = { xField: "Numarul de salariati raportat la populatie (% din populatie) 2023", yField: "Cote de impozit raportat la populatie (2022)", xLabel: "Salaria»õi", yLabel: "Impozit/loc.", xUnit: "%", yUnit: " lei", xDecimals: 1, yDecimals: 0, title: "Salaria»õi vs. Venituri din Impozite", xLabelFull: "Salaria»õi / Popula»õie (%)", yLabelFull: "Cote impozit / Popula»õie (lei/loc.)", quadLabels: { I: "I. Pu»õini Salaria»õi, Impozit Mare", II: "II. Mul»õi Salaria»õi, Impozit Mare", III: "III. Pu»õini Salaria»õi, Impozit Mic", IV: "IV. Mul»õi Salaria»õi, Impozit Mic" } };
            const scatterConfig4 = { xField: "Fonduri pe cap de locuitor (2022)", yField: "Pacienti la un medic 2023", xLabel: "Fonduri UE/loc.", yLabel: "Pacien»õi/medic", xUnit: " lei", yUnit: "", xDecimals: 0, yDecimals: 0, title: "Fonduri Europene vs. Acces la Medici", xLabelFull: "Fonduri europene / Locuitor (lei)", yLabelFull: "NumƒÉr pacien»õi / medic", quadLabels: { I: "I. Fonduri pu»õine, Medici pu»õini", II: "II. Fonduri multe, Medici pu»õini", III: "III. Fonduri pu»õine, Medici mul»õi", IV: "IV. Fonduri multe, Medici mul»õi" } };


            // Set the first config as the one for the main interactive scatter
            mainScatterConfig = scatterConfig1;
            // Pre-calculate medians for the main scatter config
            mainScatterConfig._xMedian = d3.median(allDataGlobal, d => d[mainScatterConfig.xField]);
            mainScatterConfig._yMedian = d3.median(allDataGlobal, d => d[mainScatterConfig.yField]);

            // Setup scales for map view and circle size
            const areaScale = d3.scaleSqrt().domain(d3.extent(allDataGlobal, d => d["Procent castigator"])).range([baseCircleDiameter * 0.8, baseCircleDiameter * 2.2]);
            const xGeo = d3.scaleLinear().domain(d3.extent(allDataGlobal, d => d.Long)).range([marginMain.left, mainWidth - marginMain.right]);
            const yGeo = d3.scaleLinear().domain(d3.extent(allDataGlobal, d => d.Lat)).range([mainHeight - marginMain.bottom, marginMain.top]);


            
            createSpherePositions(allDataGlobal, 250); // Calculate sphere positions

            // Create main circles (initially positioned for sphere)
            mainCircles = chartMain.selectAll("circle.main-circle")
                .data(allDataGlobal, d => d.uat + d.jud) // Key for object constancy
                .enter().append("circle")
                .attr("class", "data-circle main-circle") // Add main class
                .attr("fill", d => colorScale(d.Castigator) || "#999")
                .attr("opacity", 0) // Start invisible
                .style("pointer-events", "auto") // Allow interactions
                .on("mouseover", (event, d) => {
                     tooltip.style("opacity", 1);
                     // Show tooltip based on current view
                     if (currentView === 'sphere' || currentView === 'map') {
                         tooltip.html(basicTooltip(d));
                     } else if (currentView === 'scatter') {
                         const config = mainScatterConfig;
                         const xVal = d[config.xField], yVal = d[config.yField];
                         // Show scatter tooltip only if data is valid, else basic
                         if (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) {
                             tooltip.html(scatterTooltip(d, config));
                         } else {
                             tooltip.html(basicTooltip(d)); // Fallback
                         }
                     }
                     // Highlight on hover
                     d3.select(event.currentTarget).raise().attr("stroke", "#000").attr("stroke-width", currentView === 'sphere' ? 2.5 : 2);
                 })
                .on("mousemove", updateTooltipPosition)
                .on("mouseout", (event, d) => {
                    tooltip.style("opacity", 0); // Hide tooltip
                    // Determine persistent stroke based on filters/search/quadrant
                    const searchTerm = normalize(d3.select("#search-input").property("value"));
                    const isSearching = searchTerm.length > 0;
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                    const isHighlightedByFilter = currentFilter !== "all" && d.Castigator === currentFilter;
                    let inActiveQuadHighlight = false;
                     if (currentView === 'scatter' && activeQuad !== 'all') {
                         const config = mainScatterConfig;
                         const xVal = d[config.xField], yVal = d[config.yField];
                         const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                         if (hasValidScatterData && isPointInQuad(d, config, activeQuad)) {
                             inActiveQuadHighlight = true;
                         }
                     }

                    let finalStroke = "none", finalStrokeWidth = 0;
                    if (exactSearchMatch) {
                        finalStroke = "#FFFFFF"; finalStrokeWidth = 3;
                    } else if (isHighlightedByFilter) {
                        finalStroke = "#FFFFFF"; finalStrokeWidth = 1;
                    } else if (inActiveQuadHighlight) {
                        finalStroke = "#FFFFFF"; finalStrokeWidth = 1;
                    }
                    // Apply persistent stroke state
                    d3.select(event.currentTarget).attr("stroke", finalStroke).attr("stroke-width", finalStrokeWidth);
                });

            updateSphereVisuals(); // Initial sphere rendering
            sphereAnimation.play(); // Start animation

            // --- Setup Search and Filters ---
            const datalist = document.getElementById("localitati-list");
            // Populate datalist for search suggestions
            [...new Set(allDataGlobal.map(d => d.uat).filter(Boolean))] // Get unique UAT names
                .sort((a, b) => a.localeCompare(b, "ro-RO")) // Sort alphabetically
                .forEach(name => {
                    const opt = document.createElement("option");
                    opt.value = name;
                    datalist.appendChild(opt);
                });

            // Attach event listeners for search/filter controls
            d3.select("#search-input").on("input", applyGlobalFilterAndSearch);
            d3.select("#clear-search").on("click", () => {
                d3.select("#search-input").property("value", ""); // Clear input
                applyGlobalFilterAndSearch(); // Re-apply filters
            });
            d3.select("#winner-filter").on("change", applyGlobalFilterAndSearch);

            // --- Create Static Scatter Plots ---
            staticCircles = []; // Reset array holding static circle selections
            staticConfigs = {}; // Reset object holding static configs
            createScatterPlot("#scatter-viz-1", allDataGlobal, scatterConfig1);
            createScatterPlot("#scatter-viz-2", allDataGlobal, scatterConfig2);
            createScatterPlot("#scatter-viz-3", allDataGlobal, scatterConfig3);
            createScatterPlot("#scatter-viz-4", allDataGlobal, scatterConfig4); // This now uses cleaned data
            applyGlobalFilterAndSearch(); // Apply initial filter state to static plots


            // --- View Transition Functions ---
            function toSphere() {
                if (currentView === 'sphere') return; // Avoid redundant transitions
                console.log("Transitioning to Sphere");
                currentView = "sphere";
                window.IO?.disconnect(); // DEACTIVATE Intersection Observer
                activeQuad = 'all'; // Reset quadrant highlighting
                observerInitialized = false; // Reset IO flag
                sphereAnimation.play(); // Resume sphere rotation
                updateSearchControlsVisibility(); // Show/hide search based on view
                // Remove non-sphere elements (axes, titles, lines, etc.)
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();
                updateSphereVisuals(); // Trigger sphere position update and filter application
            }

            function toMap() {
                if (currentView === 'map') return; // Avoid redundant transitions
                console.log("Transitioning to Map");
                currentView = "map";
                window.IO?.disconnect(); // DEACTIVATE Intersection Observer
                activeQuad = 'all'; // Reset quadrant highlighting
                observerInitialized = false; // Reset IO flag
                sphereAnimation.pause(); // Pause sphere rotation
                updateSearchControlsVisibility(); // Show/hide search based on view
                // Remove non-map elements
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();
                // Add Map Titles
                svgMain.append("text").attr("class", "map-title")
                    .attr("x", mainWidth / 2).attr("y", marginMain.top / 2)
                    .text("Distribu»õia c√¢»ôtigƒÉtorilor pe localitƒÉ»õi");
                svgMain.append("text").attr("class", "map-subtitle")
                    .attr("x", mainWidth / 2).attr("y", marginMain.top / 2 + 22)
                    .text("Dimensiunea cercurilor indicƒÉ procentul ob»õinut de c√¢»ôtigƒÉtor.");

                // Transition main circles to map positions
                mainCircles.transition("mapPos").duration(1500).ease(d3.easeCubicInOut)
                    .attr("cx", d => (d.Long && !isNaN(xGeo(d.Long))) ? xGeo(d.Long) : -100) // Use geo coords or hide
                    .attr("cy", d => (d.Lat && !isNaN(yGeo(d.Lat))) ? yGeo(d.Lat) : -100) // Use geo coords or hide
                    .attr("r", d => (d.Lat && d.Long && areaScale) ? areaScale(d["Procent castigator"]) : 0) // Use area scale or hide
                    .end().then(applyGlobalFilterAndSearch).catch(err => { // Apply filters after transition
                        console.error("Map transition error:", err);
                        applyGlobalFilterAndSearch(); // Ensure filters applied even on error
                    });
                applyGlobalFilterAndSearch(); // Apply filters immediately for responsiveness
            }

            function toScatter() {
                if (currentView === 'scatter') return; // Avoid redundant transitions
                console.log("Transitioning to Main Scatter");
                currentView = "scatter";
                sphereAnimation.pause(); // Pause sphere rotation
                updateSearchControlsVisibility(); // Show/hide search based on view
                // Remove non-scatter elements
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();

                const config = mainScatterConfig; // Use the pre-defined main config
                // Define inner dimensions using main margins
                const innerWidth = mainWidth - marginMain.left - marginMain.right;
                const innerHeight = mainHeight - marginMain.top - marginMain.bottom;

                // Setup scales using main scatter config and dimensions
                const xExtent = d3.extent(allDataGlobal, d => d[config.xField]);
                const yExtent = d3.extent(allDataGlobal, d => d[config.yField]);
                const xDomain = (xExtent[0] === undefined || xExtent[1] === undefined) ? [0, 1] : xExtent;
                const yDomain = (yExtent[0] === undefined || yExtent[1] === undefined) ? [0, 1] : yExtent;
                // Scales map data to SVG coordinates within the main margins
                const x = d3.scaleLinear().domain(xDomain).nice().range([marginMain.left, mainWidth - marginMain.right]);
                const y = d3.scaleLinear().domain(yDomain).nice().range([mainHeight - marginMain.bottom, marginMain.top]); // Inverted for SVG y-axis

                const xMedian = config._xMedian; // Use cached median
                const yMedian = config._yMedian; // Use cached median

                 // --- Draw Axes, Titles, Median Lines for main plot ---
                 svgMain.append("text").attr("class", "plot-title")
                     .attr("x", mainWidth / 2).attr("y", marginMain.top / 2 - 5) // Centered above plot
                     .text(config.title);
                 svgMain.append("g").attr("class", "x-axis axis")
                     .attr("transform", `translate(0,${mainHeight - marginMain.bottom})`) // Positioned at bottom
                     .call(d3.axisBottom(x).ticks(7));
                 svgMain.append("text").attr("class", "x-label axis-label")
                     .attr("x", mainWidth / 2).attr("y", mainHeight - 15) // Centered below x-axis
                     .text(config.xLabelFull);
                 svgMain.append("g").attr("class", "y-axis axis")
                     .attr("transform", `translate(${marginMain.left},0)`) // Positioned at left
                     .call(d3.axisLeft(y).ticks(7));
                 svgMain.append("text").attr("class", "y-label axis-label")
                     .attr("transform", "rotate(-90)") // Rotated for y-axis
                     .attr("x", -(marginMain.top + innerHeight / 2)) // Centered along y-axis height
                     .attr("y", marginMain.left - 50) // Positioned left of y-axis
                     .text(config.yLabelFull);
                 // Draw median lines if valid
                 if (xMedian !== undefined && xMedian !== null) {
                     svgMain.append("line").attr("class", "quadrant-line")
                         .attr("x1", x(xMedian)).attr("x2", x(xMedian))
                         .attr("y1", marginMain.top).attr("y2", mainHeight - marginMain.bottom); // Vertical line
                 }
                 if (yMedian !== undefined && yMedian !== null) {
                     svgMain.append("line").attr("class", "quadrant-line")
                         .attr("x1", marginMain.left).attr("x2", mainWidth - marginMain.right)
                         .attr("y1", y(yMedian)).attr("y2", y(yMedian)); // Horizontal line
                 }

                 // --- Draw Quadrant Labels OUTSIDE the plot area for main plot ---
                 const isMobile = window.innerWidth <= 600;
                 const mainOuterLabelPadding = isMobile ? 8 : 12; // Padding from plot edge
                 const mainOuterLabelYOffset = isMobile ? -10 : -15; // Negative offset for above top edge
                 const mainOuterLabelYOffsetBottom = isMobile ? 15 : 20; // Positive offset for below bottom edge

                 if (config.quadLabels && xMedian !== undefined && yMedian !== undefined && xMedian !== null && yMedian !== null) {
                     // Positions are relative to the SVG root (0,0 top-left), using margin values

                     // Quadrant II (Top Right Area)
                     svgMain.append("text").attr("class", "quadrant-label quadrant-label-outer")
                         .attr("x", mainWidth - marginMain.right + mainOuterLabelPadding) // Right of plot area
                         .attr("y", marginMain.top + mainOuterLabelYOffset) // Above plot area top
                         .attr("text-anchor", "end")
                         .text(config.quadLabels.II);

                     // Quadrant I (Top Left Area)
                     svgMain.append("text").attr("class", "quadrant-label quadrant-label-outer")
                         .attr("x", marginMain.left - mainOuterLabelPadding) // Left of plot area
                         .attr("y", marginMain.top + mainOuterLabelYOffset) // Above plot area top
                         .attr("text-anchor", "start")
                         .text(config.quadLabels.I);

                     // Quadrant III (Bottom Left Area)
                     svgMain.append("text").attr("class", "quadrant-label quadrant-label-outer")
                         .attr("x", marginMain.left - mainOuterLabelPadding) // Left of plot area
                         .attr("y", mainHeight - marginMain.bottom + mainOuterLabelYOffsetBottom) // Below plot area bottom
                         .attr("text-anchor", "start")
                         .text(config.quadLabels.III);

                     // Quadrant IV (Bottom Right Area)
                     svgMain.append("text").attr("class", "quadrant-label quadrant-label-outer")
                         .attr("x", mainWidth - marginMain.right + mainOuterLabelPadding) // Right of plot area
                         .attr("y", mainHeight - marginMain.bottom + mainOuterLabelYOffsetBottom) // Below plot area bottom
                         .attr("text-anchor", "end")
                         .text(config.quadLabels.IV);
                 }
                 // --- End NEW Quadrant Labels ---


                 // --- Draw Quadrant Overlays (for highlighting) ---
                 const overlays = svgMain.selectAll(".quadrant-overlay").data(["I","II","III","IV"]);
                 overlays.enter().append("rect")
                    .attr("class","quadrant-overlay")
                    .merge(overlays)
                    .attr("opacity", 0) // Start hidden
                    .attr("pointer-events","none") // Not interactive
                    .each(function(q){ // Calculate position and size for each quadrant overlay
                        if (xMedian === undefined || yMedian === undefined || xMedian === null || yMedian === null) return; // Skip if medians invalid
                        const isLeft = q==="I" || q==="III";
                        const isTop = q==="I" || q==="II";
                        // Calculate position based on margins and median lines
                        const xPos = isLeft ? marginMain.left : x(xMedian);
                        const yPos = isTop ? marginMain.top : y(yMedian);
                        // Calculate width/height based on margins and median lines
                        const width = Math.max(0, isLeft ? x(xMedian)-marginMain.left : mainWidth-marginMain.right-x(xMedian));
                        const height = Math.max(0, isTop ? y(yMedian)-marginMain.top : mainHeight-marginMain.bottom-y(yMedian));
                        // Apply dimensions only if valid numbers
                        if (isFinite(xPos) && isFinite(yPos) && isFinite(width) && width >= 0 && isFinite(height) && height >= 0) {
                            d3.select(this).attr("x", xPos).attr("y", yPos).attr("width", width).attr("height", height);
                        } else {
                            // Fallback if calculation fails
                            d3.select(this).attr("width", 0).attr("height", 0);
                        }
                 });

                 // --- Transition Main Circles to Scatter Positions ---
                 mainCircles.transition("scatterPos").duration(1500).ease(d3.easeCubicInOut)
                    // Position circles using scatter scales, hide if data invalid
                    .attr("cx", d => { const val = d[config.xField]; return (val !== undefined && val !== null && !isNaN(x(val))) ? x(val) : -100; })
                    .attr("cy", d => { const val = d[config.yField]; return (val !== undefined && val !== null && !isNaN(y(val))) ? y(val) : -100; })
                    // Set radius, hide if data invalid
                    .attr("r", d => { const xVal = d[config.xField], yVal = d[config.yField]; return (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 1.1 : 0; })
                    .end().then(() => {
                         // After transition: apply filters and setup Intersection Observer
                         console.log("Scatter transition finished. Setting up IO.");
                         applyGlobalFilterAndSearch();
                         setupIntersectionObserver(config); // Pass the correct config
                    }).catch(err => {
                         // Handle transition errors
                         console.error("Scatter transition error:", err);
                         applyGlobalFilterAndSearch(); // Ensure filters are applied
                         setupIntersectionObserver(config); // Still try to setup IO
                    });
                applyGlobalFilterAndSearch(); // Apply filters immediately for responsiveness
            }


            // --- Intersection Observer for Scroll Steps ---
            const steps = document.querySelectorAll("#scatter-steps .step");

            function setupIntersectionObserver(config) { // Expects mainScatterConfig
                window.IO?.disconnect(); // Disconnect previous observer if exists
                observerInitialized = false; // Reset flag
                console.log("[IO] Setting up Intersection Observer");

                window.IO = new IntersectionObserver(entries => {
                    // Ignore callbacks if not in scatter view
                    if (currentView !== 'scatter') return;

                    const minVisibilityThreshold = 0.05; // Minimum ratio to be considered "visible"

                    // Find the step elements that are currently intersecting above the threshold
                    const visibleSteps = entries.filter(entry =>
                        entry.isIntersecting && entry.intersectionRatio >= minVisibilityThreshold
                    );

                    let highestVisibleStep = null;
                    if (visibleSteps.length > 0) {
                        // Sort visible steps by their top position (lowest top value = highest on screen)
                        visibleSteps.sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top);
                        // The first one in the sorted list is the highest visible step
                        highestVisibleStep = visibleSteps[0].target;
                    }

                    // Determine the quadrant associated with the highest visible step, default to 'all'
                    const nextActiveQuad = highestVisibleStep ? highestVisibleStep.dataset.quad : 'all';

                    // Only update if the active quadrant changes
                    if (nextActiveQuad !== activeQuad) {
                        console.log(`[IO Callback] *** Changing highlight: ${activeQuad} -> ${nextActiveQuad} *** (Highest visible: ${highestVisibleStep ? highestVisibleStep.dataset.quad : 'None'})`);
                        activeQuad = nextActiveQuad; // Update the global state
                        renderHighlight(activeQuad, config); // Render the highlight effect
                    }
                }, {
                    // Use multiple thresholds to trigger callback frequently during scroll
                    threshold: Array.from({ length: 21 }, (_, i) => i * 0.05) // [0, 0.05, 0.1, ..., 1.0]
                });

                // Observe each step element
                steps.forEach(s => window.IO.observe(s));
                console.log("[IO] Observer attached to steps.");

                 // Initial check in case a step is already visible on load/transition
                 if (!observerInitialized) {
                      console.log("[IO Initial Check] Scheduling...");
                      // Use setTimeout to allow layout settling after transition
                      setTimeout(() => {
                         // Abort if view changed during timeout
                         if (currentView !== 'scatter') { console.log("[IO Initial Check] Aborted, view changed."); return; }
                         console.log("[IO Initial Check] Running...");

                         const minVisibilityThreshold = 0.05;
                         const currentVisibleSteps = [];
                         // Manually check visibility of each step
                         steps.forEach(step => {
                            const rect = step.getBoundingClientRect();
                            // Check if vertically within viewport
                            const isIntersecting = rect.top < window.innerHeight && rect.bottom > 0;
                            if (isIntersecting) {
                                // Calculate approximate intersection ratio
                                const visibleHeight = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
                                const ratio = Math.max(0, Math.min(1, visibleHeight / rect.height));
                                if (ratio >= minVisibilityThreshold) {
                                    // Store step and its top position if visible enough
                                    currentVisibleSteps.push({ target: step, top: rect.top });
                                }
                            }
                         });

                         let initialHighestStep = null;
                         if (currentVisibleSteps.length > 0) {
                             // Find the highest visible step (lowest top value)
                             currentVisibleSteps.sort((a, b) => a.top - b.top);
                             initialHighestStep = currentVisibleSteps[0].target;
                         }

                         // Determine the initial quadrant based on the highest visible step
                         const initialActiveQuad = initialHighestStep ? initialHighestStep.dataset.quad : 'all';
                         console.log(`[IO Initial Check] Determined initial quad: ${initialActiveQuad}.`);

                         // Update state and render highlight only if different from default
                         if (initialActiveQuad !== activeQuad) {
                              console.log(`[IO Initial Check] *** Setting initial highlight: ${activeQuad} -> ${initialActiveQuad} ***`);
                              activeQuad = initialActiveQuad;
                         }
                         renderHighlight(activeQuad, config); // Render initial highlight state
                         observerInitialized = true; // Mark as initialized
                     }, 350); // Delay to ensure transitions/layout are stable
                 }
             }

            function renderHighlight(quad, config) { // Expects mainScatterConfig
                // Guard against rendering if not in scatter view or SVG is gone
                if (currentView !== 'scatter' || !svgMain || !svgMain.node()) {
                    console.warn(`[RenderHighlight] Aborting. View: ${currentView}, SVG exists: ${!!svgMain?.node()}`);
                    if (currentView !== 'scatter') activeQuad = 'all'; // Reset if view changed
                    return;
                }
                console.log(`[RenderHighlight] Rendering for quad: ${quad}`);
                // Transition the opacity of the quadrant overlays
                svgMain.selectAll(".quadrant-overlay")
                    .filter(qData => qData) // Ensure data is bound
                    .transition("overlayHighlight").duration(300)
                    // Show the overlay for the active quad, hide others
                    .attr("opacity", qData => (quad === "all") ? 0 : (qData === quad ? 0.12 : 0));

                // Re-apply global filters/search, which now includes quadrant dimming logic
                applyGlobalFilterAndSearch();
            }


            // --- Scroll Listener for View Changes ---
            const chartWrapper = document.querySelector('.chart-wrapper');
            const scatterStepsSection = document.getElementById('scatter-steps');

            window.addEventListener("scroll", () => {
                const y = window.scrollY;
                const wh = window.innerHeight;
                // Exit if essential elements aren't found
                if (!chartWrapper || !scatterStepsSection) return;

                // Get positions and dimensions needed for calculations
                const wrapperRect = chartWrapper.getBoundingClientRect();
                const stepsRect = scatterStepsSection.getBoundingClientRect();
                const wrapperTop = wrapperRect.top + y; // Absolute top position of wrapper
                const stepsTop = stepsRect.top + y;     // Absolute top position of steps section
                const wrapperHeight = chartWrapper.offsetHeight;

                // Define scroll thresholds for changing views
                // Transition to Map when 1/3 of the wrapper has scrolled past the bottom of the viewport
                const mapStartPoint = wrapperTop + wrapperHeight * 0.33 - wh;
                // Transition to Scatter when the top of the steps section is about 60% up the viewport
                const scatterStartPoint = stepsTop - wh * 0.6;

                let targetView; // Determine the target view based on scroll position

                if (y < mapStartPoint) {
                    targetView = "sphere";
                } else if (y >= mapStartPoint && y < scatterStartPoint) {
                    targetView = "map";
                } else { // y >= scatterStartPoint
                    targetView = "scatter";
                }

                // If the target view is different from the current view, trigger the transition
                if (targetView !== currentView) {
                    console.log(`Scroll Trigger: Changing view from ${currentView} to ${targetView} (y=${y.toFixed(0)}, mapStart=${mapStartPoint.toFixed(0)}, scatterStart=${scatterStartPoint.toFixed(0)})`);
                    if (targetView === "sphere") toSphere();
                    else if (targetView === "map") toMap();
                    else if (targetView === "scatter") toScatter();
                }

                // Update search controls visibility based on the current view
                updateSearchControlsVisibility();

                // Hide intro overlay when scrolling down or not in sphere view
                const intro = document.getElementById("sphere-intro");
                if (intro) {
                    if (y < 80 && currentView === 'sphere') intro.classList.remove("hidden");
                    else intro.classList.add("hidden");
                }

            }, { passive: true }); // Use passive listener for better scroll performance


            // --- Intersection Observer for Fading Main Chart ---
            const chartContainer = document.getElementById("chart-container");
            const staticPlotsSection = document.getElementById("flourish-block");

             if (chartContainer && staticPlotsSection) {
                new IntersectionObserver(
                    entries => {
                        const staticPlotsEntry = entries[0];
                        const fadeStartRatio = 0.05; // Start fading when 5% visible
                        const fadeEndRatio = 0.25; // Fully faded when 25% visible
                        let opacity = 1; // Default opacity

                        staticPlotsVisible = staticPlotsEntry.isIntersecting; // Update visibility flag

                        if (staticPlotsEntry.isIntersecting) {
                            // Calculate opacity based on intersection ratio within the fade range
                            const ratio = staticPlotsEntry.intersectionRatio;
                            if (ratio >= fadeStartRatio) {
                                opacity = 1 - Math.min(1, Math.max(0, (ratio - fadeStartRatio) / (fadeEndRatio - fadeStartRatio)));
                            }
                        } else if (staticPlotsEntry.boundingClientRect.top < 0) {
                            // If scrolled past (top is negative), force opacity to 0
                            opacity = 0;
                            staticPlotsVisible = false;
                        } else {
                            // If not intersecting and above the viewport, opacity is 1
                            opacity = 1;
                            staticPlotsVisible = false;
                        }

                        // Apply opacity and pointer events
                        chartContainer.style.opacity = opacity;
                        chartContainer.style.pointerEvents = opacity < 0.5 ? "none" : "auto";

                        updateSearchControlsVisibility(); // Update search controls based on visibility

                        // Hide intro if chart starts fading
                        const intro = document.getElementById("sphere-intro");
                        if (intro && opacity < 0.8) intro.classList.add("hidden");

                        // Disconnect Intersection Observer for steps if main chart is mostly hidden
                        if (opacity < 0.5 && window.IO) {
                             console.log("Disconnecting IO due to main chart fade");
                             window.IO.disconnect();
                             activeQuad = 'all'; // Reset active quadrant
                             observerInitialized = false; // Reset IO flag
                        }
                    },
                    { threshold: Array.from({ length: 21 }, (_, i) => i * 0.05) } // Multiple thresholds for smooth fade calculation
                ).observe(staticPlotsSection); // Observe the static plots section
             }

            // --- Intro Button ---
            const intro = document.getElementById("sphere-intro");
            const introOk = document.getElementById("intro-ok");
            if (intro && introOk) {
                function hideIntro() { intro.classList.add("hidden"); }
                introOk.addEventListener("click", hideIntro);
                // Optional: Hide intro on first scroll
                // window.addEventListener('scroll', hideIntro, { once: true });
            }

            // --- Initial View Setup on Load ---
            // Use setTimeout to ensure layout is stable before calculating positions
            setTimeout(() => {
                 const y = window.scrollY;
                 const wh = window.innerHeight;
                 // Check if elements exist before proceeding
                 if (!chartWrapper || !scatterStepsSection) {
                     console.error("Initial view check failed: Elements not found.");
                     toSphere(); // Default to sphere view
                     applyGlobalFilterAndSearch();
                     updateSearchControlsVisibility();
                     return;
                 }
                 // Recalculate positions (same logic as scroll handler)
                 const wrapperRect = chartWrapper.getBoundingClientRect();
                 const stepsRect = scatterStepsSection.getBoundingClientRect();
                 const wrapperTop = wrapperRect.top + y;
                 const stepsTop = stepsRect.top + y;
                 const wrapperHeight = chartWrapper.offsetHeight;
                 const mapStartPoint = wrapperTop + wrapperHeight * 0.33 - wh;
                 const scatterStartPoint = stepsTop - wh * 0.6;

                 let initialViewFunction = toSphere; // Default view

                 // Determine initial view based on current scroll position
                 if (y >= mapStartPoint && y < scatterStartPoint) {
                     initialViewFunction = toMap;
                 } else if (y >= scatterStartPoint) {
                     initialViewFunction = toScatter;
                 }

                 console.log(`Setting initial view: ${initialViewFunction.name} (y=${y.toFixed(0)}, mapStart=${mapStartPoint.toFixed(0)}, scatterStart=${scatterStartPoint.toFixed(0)})`);
                 initialViewFunction(); // Call the function to set the initial view

                 // Update search visibility after a short delay to ensure view is set
                 setTimeout(updateSearchControlsVisibility, 200);

                 // Handle initial intro visibility
                 const introElem = document.getElementById("sphere-intro");
                 if (introElem) {
                     if (y < 80 && currentView === 'sphere') {
                         introElem.classList.remove("hidden");
                     } else {
                         introElem.classList.add("hidden");
                     }
                 }
                 console.log("Initial view determined:", currentView);
            }, 150); // Short delay for safety


        }).catch(error => {
            // --- Error Handling ---
            console.error("Error loading or processing data:", error);
            // Display user-friendly error message
            document.body.innerHTML = `<div style="color: red; padding: 50px; text-align: center; font-size: 1.2em;">A apƒÉrut o eroare la √ÆncƒÉrcarea datelor (${error.message}). VƒÉ rugƒÉm re√ÆncƒÉrca»õi pagina.</div>`;
        });

    </script>
    </body>
    </html>