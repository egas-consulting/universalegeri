<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Universul Rom√¢nesc</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        *, *:before, *:after { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            overflow-x: hidden;
            background-color: #000;
            color: #fff;
        }

        .headline-wrapper {
            position: relative;
            z-index: 3;
            text-align: center;
            padding-top: 8vh;
            padding-bottom: 4vh;
            color: white;
        }

        .cosmic-supratitle {
            font-family: 'Roboto', sans-serif;
            font-size: 1.4em;
            font-weight: 300;
            color: white;
            text-shadow: 0 0 6px #88b5ff, 0 0 10px #5573d6;
            margin-bottom: 10px;
        }

        .cosmic-title {
            font-family: 'Roboto', sans-serif;
            font-size: 1.6em;
            font-weight: 400;
            padding: 0 6vw;
            line-height: 1.4;
            color: white;
            text-shadow: 0 0 6px #88b5ff, 0 0 12px #335bc4;
        }

        .text-container {
            max-width: 600px;
            margin: 0 auto;
            padding: 0 5vw;
            padding-top: 5vh;
            color: #fff;
        }

        p {
            text-align: center;
            font-size: 1em;
            margin: 1em 0;
        }


        .chart-wrapper {
            position: relative;
            height: 170vh;
            margin-bottom: 5vh;
        }

        .chart-container {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100vh;
            background: radial-gradient(ellipse at center, #0b1f4c 0%, #000000 100%);
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.6s ease;
        }


        .svg-inner {
            width: 100%;
            max-width: 1000px;
            position: relative;
        }
        svg {
            width: 100%;
            height: auto;
            display: block;
            background-color: transparent;
            overflow: visible;
        }


        .tooltip {
            position: absolute;
            background: rgba(255,255,255,0.95);
            border: 1px solid #aaa;
            padding: 0.85em 1em;
            font-size: 0.9em;
            pointer-events: none;
            opacity: 0;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            border-radius: 4px;
            max-width: 90vw;
            min-width: 80px;
            color: #333;
            transition: opacity 0.2s ease;
        }

        .top-spacer { height: 15vh; }


        #search-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 11;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            display: none;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            max-width: 90vw;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
        }
         #search-container.visible {
            display: block;
            opacity: 1;
            pointer-events: auto;
         }
        #search-input, #clear-search, #winner-filter {
            padding: 8px 12px;
            font-size: 0.9em;
            margin: 4px;
            border: 1px solid #555;
            border-radius: 5px;
            background-color: #333;
            color: #eee;
        }
        #search-input::placeholder { color: #aaa; }
        #clear-search {
            padding: 8px 10px;
            margin-left: 6px;
            cursor: pointer;
            background-color: #555;
            border-color: #777;
        }
         #clear-search:hover { background-color: #666; }
        #winner-filter {
            cursor: pointer;
            background-color: #333;
             border-color: #555;
             color: #eee;
             flex-grow: 1;
             min-width: 150px;
        }
        #search-container > div {
             display: flex;
             align-items: center;
             gap: 5px;
             flex-wrap: wrap;
         }
         #search-container > div:last-child { margin-top: 8px; }
         #search-container label {
             color: white;
             margin-right: 6px;
             font-size: 0.9em;
             white-space: nowrap;
         }


        #scatter-steps {
            position: relative;
            z-index: 5;

             margin-top: 100vh;
             padding-top: 1vh;
             padding-bottom: 5vh;
        }
        .step {
            position: relative;
            max-width: min(90vw, 340px);

            margin: 70vh auto;
            padding: 1.25em 1.5em;
            background: rgba(255,255,255,0.92);
            border-radius: 8px;
            font-size: .95em;
            line-height: 1.35;
            box-shadow: 0 2px 10px rgba(0,0,0,.25);
            color: #333;
        }

         .step:first-child { margin-top: 40vh; }
         .step:last-child { margin-bottom: 50vh; }


        #sphere-intro{
            position:fixed; inset:0; z-index:6; display:flex;
            flex-direction:column; justify-content:center; align-items:center;
            text-align:center; gap:1.5rem; font-family:'Roboto',sans-serif;
            background:rgba(0,0,0,0.88); color:#fff; opacity:1;
            pointer-events:auto; transition:opacity .6s ease;
        }
        #sphere-intro h2{font-size:1.4rem; margin:0;}
        #sphere-intro p {
    font-size: 1rem;
    line-height: 1.4;
    margin: 0;
    max-width: 600px;
    width: 90%;

    padding-left: 15px;
    padding-right: 15px;
    box-sizing: border-box;

    /* The <p> block itself will be centered by #sphere-intro's align-items: center */
}
        #sphere-intro button{
            padding:.6rem 1.4rem; font-size:1rem; border:none; border-radius:6px;
            background:rgb(0, 140, 255); color:#ffffff; cursor:pointer;
        }
        #sphere-intro.hidden{ opacity:0; pointer-events:none; }


        #flourish-block{
            padding: 10vh 0 6vh;
            background: #000;
            text-align:left;
            position:relative;
            z-index:3;
        }
        .scatter-plot-container {
            max-width: 950px;
            width: 92%;
            margin: 10vh auto;
            background-color: rgba(11, 31, 76, 0.2);
            border-radius: 8px;
            padding: 25px 15px 15px 15px;
            box-shadow: 0 0 15px rgba(136, 181, 255, 0.15);
        }
        .scatter-explainer {
            font-size: 1em; color: #ccc; margin-top: 10px;
            max-width: 850px; margin-left: auto; margin-right: auto;
            padding: 0 15px; line-height: 1.4; text-align: left;
            margin-top: 50px;


        }



        .axis path, .axis line { stroke: #aaa; stroke-width: 0.5; shape-rendering: crispEdges; }
        .axis text { fill: #ccc; font-weight: 300; font-size: 10px; }
        .axis-label { fill: #ddd; font-size: 0.85em; text-anchor: middle; }
        .plot-title { fill: #fff; font-size: 2em; font-weight: 600; text-anchor: middle; } /* Adjusted from 2em for balance */
        .map-title { fill: #fff; font-size: 2em; font-weight: 600; text-anchor: middle; }
        .map-subtitle { fill: #ccc; font-size: 0.9em; text-anchor: middle; }
        .quadrant-line { stroke: #ffffff; stroke-dasharray: 3 3; stroke-width: 1.5px; opacity: 0.8; }


        .quadrant-label {
            fill: #ffffff;
            font-size: 1em;
            font-weight: 400;
            opacity: 0.9;
         }
         .quadrant-label-outer {

             font-size: 1.4em;

             fill: #e0e0e0;
             font-weight: 500;
             opacity: 0.95;

             text-shadow: 0 0 3px rgba(0, 0, 0, 0.7);
             pointer-events: none;
         }

         .quadrant-label-outer tspan {

         }


         .quadrant-overlay {
             fill: #ffffff;
             opacity: 0;
             pointer-events: none;
             transition: opacity 0.3s ease;
         }


        #candidate-summary-popup {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(40, 40, 60, 0.95);
            border: 1px solid #777;
            border-radius: 8px;
            padding: 18px 25px;
            max-width: 400px;
            z-index: 12;
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            color: #eee;
            font-size: 0.9em;
            line-height: 1.45;
        }

        #candidate-summary-popup.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        #summary-text p {
            margin: 0 0 10px 0;
            text-align: left;
             font-size: inherit;
             color: inherit;
        }
         #summary-text strong {
             color: #fff;
         }
         #summary-text i {
             color: #bbb;
             font-style: normal;
             font-weight: 500;
         }

        #mini-chart-container {
            margin-top: 10px;
            height: 60px;
            width: 100%;
        }

        #mini-chart-svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        .mini-axis path, .mini-axis line {
            stroke: #888;
            stroke-width: 0.5;
            shape-rendering: crispEdges;
        }
        .mini-axis .tick text {
             fill: #ccc;
             font-size: 9px;
        }
        .mini-axis-label {
            fill: #ccc;
            font-size: 9px;
            text-anchor: middle;
        }
        .mini-bar {
            fill: #88b5ff;
            stroke: #fff;
            stroke-width: 0.5;
        }
        .mini-median-line {

            stroke-width: 1.5;
            stroke-dasharray: 2 2;
        }
         .mini-median-label {

             font-size: 10px;
             font-weight: bold;
         }

        #close-summary-popup {
            position: absolute;
            top: 5px;
            right: 8px;
            background: none;
            border: none;
            color: #ccc;
            font-size: 1.8em;
            line-height: 1;
            cursor: pointer;
            padding: 0 5px;
        }
        #close-summary-popup:hover {
            color: #fff;
        }



        @media (max-width: 600px) {
             #search-container {
                 top: 10px; left: 50%; right: auto; transform: translateX(-50%);
                 width: 90vw; max-width: 350px; padding: 8px 10px;
             }
             #search-container > div {
                 flex-direction: column; align-items: stretch; width: 100%; gap: 6px;
             }
             #search-input, #clear-search, #winner-filter, #search-container label {
                 font-size: 0.85em; width: 100%; margin: 0; box-sizing: border-box;
             }
             #search-input { padding: 7px 10px; }
              #clear-search { padding: 7px 10px; margin-top: 4px; }
             #search-container label { margin-bottom: 4px; text-align: center; margin-right: 0; }
             #winner-filter { padding: 7px 10px; min-width: 0; }
             #search-container > div:last-child { margin-top: 10px; }

            .scatter-plot-container {
                width: 98%; padding: 10px 5px 5px 5px; margin: 5vh auto; box-shadow: none;
            }
            .scatter-explainer { padding: 0 5px; font-size: 0.9em; margin-top: 30px; line-height: 1.3; }
             .plot-title { font-size: 1.1em; }
             .axis-label { font-size: 0.8em; }


             .quadrant-label {
                 font-size: 1.1em;
             }
             .quadrant-label-outer {
                  font-size: 1.1em;
                  text-shadow: 0 0 2px rgba(0, 0, 0, 0.6);
             }

             .axis text { font-size: 8px; }


            .step { margin: 60vh auto; }
            .step:first-child { margin-top: 30vh; }
            .step:last-child { margin-bottom: 40vh; }

            .map-title { font-size: 2em; }
            .map-subtitle { font-size: 1em; }
            .cosmic-title { font-size: 1.5em; }
            .cosmic-supratitle { font-size: 1.3em; }


            #candidate-summary-popup {
                left: 10px;
                right: 10px;
                bottom: 10px;
                max-width: none;
                width: auto;
                padding: 16px 20px;
                font-size: 0.85em;
            }
            #close-summary-popup {
                top: 3px;
                right: 5px;
                 font-size: 1.6em;
            }
             #mini-chart-container {
                 height: 50px;
             }
             .mini-axis-label { font-size: 8px; }
             .mini-median-label { font-size: 9px; }
             .mini-axis .tick text { font-size: 8px; }

             .scatter-plot-container svg .static-circle {
                 r: 5;
             }
        }


        body { min-height: 500vh; }
        html,body{ overscroll-behavior: none; }

        .highlight {
            background-color: rgb(0, 140, 255);
            color: #ffffff;
            padding: 0px 1px;
            border-radius: 0px;
        }

        a {
    color: rgb(0, 140, 255);
  }

  a:hover {
    color: rgb(255, 217, 0);
  }



    </style>
</head>
<body>
    <div class="headline-wrapper">
        <div class="cosmic-supratitle">INTERACTIV | Voturile din turul I, explicate altfel</div>
        <h1 class="cosmic-title">
            Cum a votat Rom√¢nia √Æn func»õie de opt indicatori socio-economici »ôi cum s-au diferen»õiat victoriile lui Simon de cele ale lui Nicu»ôor Dan
        </h1>
    </div>
    <div class="text-container">
        <p>
            Am analizat <strong>rezultatele ob»õinute</strong> <br>
            <strong>Scroll</strong> pentru a explora vizualizarea interactivƒÉ. Mai jos gƒÉsi»õi analize detaliate pe indicatori specifici.<br>
            <i>Filtrele »ôi cƒÉutarea (sus dreapta) se aplicƒÉ tuturor graficelor.</i>
        </p>
    </div>

    <div id="search-container">
        <div>
            <input id="search-input" type="text" placeholder="CautƒÉ localitate..." list="localitati-list">
            <button id="clear-search" title="ReseteazƒÉ cƒÉutarea">Reset</button>
            <datalist id="localitati-list"></datalist>
        </div>
        <div >
            <label for="winner-filter">FiltreazƒÉ dupƒÉ c√¢»ôtigƒÉtor:</label>
            <!-- *** UPDATED FILTER OPTIONS START *** -->
             <select id="winner-filter">
                <option value="all">To»õi</option>
                <!-- Use full names from CSV in the 'value' attribute -->
                <option value="GEORGE-NICOLAE SIMION">GEORGE SIMION</option>
                <option value="GEORGE-CRIN-LAUREN»öIU ANTONESCU">CRIN ANTONESCU</option>
                <option value="NICU»òOR-DANIEL DAN">NICU»òOR DAN</option>
                <option value="VICTOR-VIOREL PONTA">VICTOR PONTA</option>
            </select>
             <!-- *** UPDATED FILTER OPTIONS END *** -->
        </div>
    </div>

    <div class="top-spacer"></div>

    <div class="chart-wrapper">
        <div class="chart-container" id="chart-container">
            <div class="svg-inner">
                <svg id="viz" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet"></svg>
                <!-- Note: Arrowhead <defs> would go here if implemented -->
            </div>
        </div>
    </div>

    <div id="sphere-intro">
        <h2>INTERACTIV | Voturile din turul I, explicate altfel</h2>
        <p>
        <a href="https://www.hotnews.ro" target="_blank" rel="noopener noreferrer">HotNews.ro</a> a analizat <span class="highlight">rezultatele primului tur</span> al alegerilor preziden»õiale din 2025
        »ôi le-a corelat cu <span class="highlight">8 indicatori socio-economici</span> de la INS √Æntr-o serie de grafice
        interactive care ne aratƒÉ cum influen»õeazƒÉ ace»ôtia op»õiunile electorale.<br> <br>
        Scopul a fost sƒÉ observƒÉm cum voteazƒÉ rom√¢nii din diferite zone ale »õƒÉrii, √Æn func»õie de specificul economic »ôi social al acestora.<br><br>
        √éntregul material este <span class="highlight">interactiv.</span> <span class="highlight">Click</span>pe cercuri, grafice »ôi filtre pentru a-l explora.
        <span class="highlight">FiltreazƒÉ graficele</span> √Æn func»õie de c√¢»ôtigƒÉtor pentru a vedea
        statistica medie a candidatului pe fiecare grafic. <br><br>
        Materialul este √ÆmpƒÉr»õit √Æn sec»õiuni care
        se activeazƒÉ pe mƒÉsurƒÉ ce derulezi pagina √Æn jos.
        <span class="highlight">Scroll</span> pentru a explora toate sec»õiunile.
    </p>
        <button id="intro-ok">√éncepe</button>
    </div>

    <section id="scatter-steps">
        <div class="step" data-quad="I">
            <p><strong><span style="font-size: 1.2em;">Cum am structurat graficele</span></strong><br>
                Am selectat <strong>8 indicatori</strong> socio-economici de la Institutul Na»õional de StatisticƒÉ »ôi i-am reprezentat √Æn <strong>patru grafice diferite</strong>.
Fiecare grafic are douƒÉ axe, iar pe fiecare axƒÉ este reprezentat c√¢te un indicator din cei 8.
<strong>LocalitƒÉ»õile</strong> din Rom√¢nia apar sub formƒÉ de <strong>puncte</strong> pe aceste grafice. Pozi»õia unui punct (adicƒÉ a unei localitƒÉ»õi) ne aratƒÉ care
este situa»õia acelei localitƒÉ»õi fa»õƒÉ de cei doi indicatori ale»ôi.
Pentru o √Æn»õelegere »ôi mai u»ôoarƒÉ »ôi pentru a ajuta la navigare »ôi interpretare,
<strong>fiecare grafic</strong> este <strong>√ÆmpƒÉr»õit √Æn patru zone (cadrane)</strong>, folosind valorile mediane (valorile de mijloc)
ale indicatorilor. Astfel, putem vedea clar categoriile √Æn care se aflƒÉ localitƒÉ»õile
»ôi putem compara situa»õiile din diferite zone ale »õƒÉrii.</p>
        </div>
        <div class="step" data-quad="II">
            <p><strong><span style="font-size: 1.2em;">Cum interpretezi cadranele</span></strong><br>
                <strong>Cele patru cadrane</strong> din fiecare grafic reprezintƒÉ <strong>patru tipuri diferite de situa»õii.</strong>
                De exemplu, dacƒÉ o localitate are v√¢rsta medie a popula»õiei mare »ôi suprafa»õa locuibilƒÉ
                pe cap de locuitor micƒÉ, asta aratƒÉ cƒÉ popula»õia este √ÆmbƒÉtr√¢nitƒÉ »ôi locuie»ôte √Æn zone
                aglomerate sau cu situa»õie financiarƒÉ mai modestƒÉ.
                Cu c√¢t o localitate este pozi»õionatƒÉ mai aproape de marginile graficului (extremele cadranului),
                cu at√¢t situa»õia respectivƒÉ este mai accentuatƒÉ. Am dat c√¢te un nume generic fiecƒÉrui tip de situa»õie
                din cadrane, dar aceste denumiri sunt doar orientative »ôi exemplele nu se limiteazƒÉ strict la ele.</p>
        </div>
        <div class="step" data-quad="III">
            <p><strong><span style="font-size: 1.2em;">De ce sunt utile cadranele</span></strong><br>
                √én loc sƒÉ analizƒÉm fiecare indicator separat, am ales sƒÉ vedem <strong>cum se combinƒÉ doi indicatori importan»õi pentru a √Æn»õelege povestea localitƒÉ»õii.</strong>
                Astfel, putem observa dacƒÉ »ôi cum sunt legate √Æntre ele situa»õia economicƒÉ, socialƒÉ »ôi politicƒÉ.
                Acest tip de analizƒÉ ne ajutƒÉ sƒÉ √Æn»õelegem mai u»ôor rela»õia dintre indicatorii analiza»õi »ôi realitatea din fiecare zonƒÉ.</p>
        </div>
        <div class="step" data-quad="IV">
            <p><strong><span style="font-size: 1.2em;">CautƒÉ localitatea, filtreazƒÉ informa»õia »ôi exploreazƒÉ graficele</span></strong><br>
                Graficul este interactiv. Po»õi muta cursorul peste un cerc pentru a vedea detalii despre localitatea respectivƒÉ,
                po»õi cƒÉuta direct numele unei localitƒÉ»õi sau po»õi alege sƒÉ vezi doar localitƒÉ»õile √Æn care a c√¢»ôtigat
                un anumit candidat.</p>
        </div>
         <div class="step" data-quad="all"> <!-- This step helps reset when scrolling past the last specific quadrant step -->
             <p><strong>Scroll √Æn continuare pentru a explora graficele</strong></p>
         </div>
    </section>

    <section id="flourish-block">
        <h2 class="cosmic-title" style="margin-bottom: 5vh; padding-top: 5vh;">Analiza detaliatƒÉ pe indicatori statici</h2>
        <!-- Added data-chart-id attribute matching the SVG ID -->
        <div id="scatter-container-1" class="scatter-plot-container" data-chart-id="scatter-viz-1">
            <svg id="scatter-viz-1" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer">
                <strong>Ce ne poate spune combina»õia dintre v√¢rsta medie a popula»õiei »ôi suprafa»õa locuibilƒÉ pe persoanƒÉ?</strong><br>
                AceastƒÉ combina»õie scoate la ivealƒÉ tipuri distincte de comunitƒÉ»õi: locuri unde popula»õia e √ÆmbƒÉtr√¢nitƒÉ dar trƒÉie»ôte √Æn locuin»õe mari,
                zone tinere, dar dense »ôi aglomerate, sau suburbii √Æn cre»ôtere cu familii tinere »ôi spa»õiu generos.
                Graficul ne aratƒÉ nu doar nivelul de trai, ci »ôi direc»õii demografice: unde s-au retras v√¢rstnicii,
                unde se concentreazƒÉ familiile √ÆnstƒÉrite, sau care sunt zonele unde tinerii trƒÉiesc √Æn condi»õii mai restr√¢nse.
                √én ansamblu, aceste rela»õii reflectƒÉ mobilitatea socialƒÉ, presiunea urbanƒÉ »ôi transformƒÉrile economice ale fiecƒÉrei regiuni.<br><br>
                <ul>
<li><strong>LocalitƒÉ»õile din dreapta sus (v√¢rstƒÉ medie mare »ôi spa»õiu generos)</strong>sunt adesea foste ora»ôe istorice sau sta»õiuni,
unde popula»õia t√¢nƒÉrƒÉ a plecat, iar cei rƒÉma»ôi trƒÉiesc √Æn case mari.</li><br>
<li><strong>√én dreapta jos,</strong> vedem ora»ôe mici sau cartiere vechi, unde locuiesc oameni mai
√Æn v√¢rstƒÉ √Æn locuin»õe mici ‚Äì semn al unor condi»õii mai modeste.</li><br>
<li><strong>St√¢nga sus</strong> ne aratƒÉ suburbii sau localitƒÉ»õi periurbane
mai √ÆnstƒÉrite, cu familii tinere care trƒÉiesc √Æn case mari.</li><br>
<li><strong>St√¢nga jos</strong> indicƒÉ ora»ôe mari »ôi aglomerate, dominate de popula»õie t√¢nƒÉrƒÉ
care locuie»ôte √Æn spa»õii restr√¢nse.</li></ul><br>
<strong>Simion, √ÆnvingƒÉtor √Æn localitƒÉ»õi cu media de v√¢rstƒÉ mai mare »ôi spa»õiu locuibil mic </strong><br><br>
Din dispunerea rezultatelor pe grafic se observƒÉ cum Nicu»ôor Dan iese clar √Æn eviden»õƒÉ
c√¢»ôtig√¢nd √Æn ora»ôe »ôi localitƒÉ»õi periurbane prospere - suprafa»õa medie pe
locuitor fiind de 34,9 mp. Dan a c√¢»ôtigat votul »ôi pe zone unde v√¢rsta medie
a popula»õiei este situatƒÉ √Æntre 35 »ôi 45 de ani, media de v√¢rstƒÉ √Æn localitƒÉ»õile
c√¢»ôtigate fiind de 38,1 ani.<br><br>
De cealaltƒÉ parte, scorurile √Ænregistrate de George Simion sunt mult mai
rƒÉsfirate pe grafic - practic Simion a c√¢»ôtigat din toate categoriile
de v√¢rstƒÉ »ôi din toate mediile. Pe grafic √ÆnsƒÉ se poate vedea o concentra»õie spre zonele rurale sau urbane medii »ôi mici, cu medie de v√¢rstƒÉ mai √ÆnaintatƒÉ (41,8 ani) »ôi suprafe»õe locuibile pe cap de locuitor mai mici √Æn general (20,7 mp).

            </p>
        </div>

        <div id="scatter-container-2" class="scatter-plot-container" data-chart-id="scatter-viz-2">
            <svg id="scatter-viz-2" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce ne aratƒÉ rela»õia dintre plecƒÉrile cu domiciliul »ôi »ôomajul local?</strong><br>
            Combina»õia dintre c√¢»õi oameni pleacƒÉ dintr-o localitate »ôi c√¢»õi nu au un loc de muncƒÉ ne spune multe despre
            c√¢t de bine func»õioneazƒÉ acea comunitate. PlecƒÉrile cu domiciliul aratƒÉ c√¢t de atractiv (sau nu)
            este un loc pentru a trƒÉi. »òomajul aratƒÉ c√¢t de greu este sƒÉ gƒÉse»ôti un loc de muncƒÉ acolo.
            C√¢nd ambele sunt ridicate, √ÆnseamnƒÉ cƒÉ oamenii pleacƒÉ din cauza lipsei de oportunitƒÉ»õi. Este semnul unei comunitƒÉ»õi
            aflate √Æn dificultate. √én schimb, acolo unde oamenii rƒÉm√¢n »ôi »ôomajul este scƒÉzut,
            avem o localitate mai stabilƒÉ, unde locuitorii √Æ»ôi pot construi un viitor. AceastƒÉ combina»õie
            ne ajutƒÉ sƒÉ √Æn»õelegem care sunt zonele vulnerabile, dar »ôi care reu»ôesc sƒÉ-»ôi pƒÉstreze echilibrul
            economic »ôi social.</p>
            <ul>
<li><strong>Dreapta sus:</strong> localitƒÉ»õi cu »ôomaj mare »ôi plecƒÉri frecvente ‚Äì oamenii pleacƒÉ din cauza lipsei oportunitƒÉ»õilor.</li><br>
<li><strong>Dreapta jos:</strong> localitƒÉ»õi cu plecƒÉri frecvente, dar »ôomaj scƒÉzut ‚Äì oamenii pleacƒÉ, de»ôi existƒÉ locuri de muncƒÉ. Pot fi zone tranzitorii.</li><br>
<li><strong>St√¢nga sus:</strong> plecƒÉri pu»õine »ôi »ôomaj mare ‚Äì popula»õia rƒÉm√¢ne, de»ôi nu are acces la locuri de muncƒÉ, posibil din lipsƒÉ de alternative.</li><br>
<li><strong>St√¢nga jos:</strong> localitƒÉ»õi stabile, cu plecƒÉri reduse »ôi »ôomaj mic, semn de echilibru »ôi atractivitate localƒÉ.</li><br>
            </ul>
<strong>Nicu»ôor Dan, c√¢»ôtigƒÉtor √Æn localitƒÉ»õi cu »ôomaj mic</strong><br><br>
Simion a c√¢»ôtigat votul din primul tur √Æn 2701 localitƒÉ»õi, iar media
√Æn localitƒÉ»õile c√¢»ôtigate aratƒÉ un »ôomaj de 2%, cu o popula»õie plecatƒÉ de 1,9%.
√én compara»õie, Nicu»ôor a c√¢»ôtigat doar 34 de localitƒÉ»õi, dar toate sunt
zone urbane sau periurbane, cu mari ora»ôe care √ÆnregistreazƒÉ o pondere
mai mare de plecƒÉri cu domiciliul (media de 2,7%). √én schimb localitƒÉ»õile
adjudecate de Nicu»ôor Dan au o medie micƒÉ de »ôomeri: 0,3%.


        </div>

        <div id="scatter-container-3" class="scatter-plot-container" data-chart-id="scatter-viz-3">
            <svg id="scatter-viz-3" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce ne aratƒÉ rela»õia dintre numƒÉrul de salaria»õi »ôi veniturile fiscale locale?</strong><br>
            AceastƒÉ combina»õie ne ajutƒÉ sƒÉ √Æn»õelegem c√¢t de activƒÉ este economia localƒÉ »ôi c√¢t de eficientƒÉ este administra»õia
            √Æn a colecta bani pentru bugetul comunitƒÉ»õii. datele despre cotele de impozit sunt luate de la Ministerul Finan»õelor »ôi se referƒÉ la anul 2022.
            Am √ÆmpƒÉr»õit aceste valori la popula»õie din 2022 pentru a vedea √Æmpozitul mediu/cap de locuitor.
            NumƒÉrul de salaria»õi raportat la popula»õie aratƒÉ c√¢»õi oameni contribuie efectiv la economie prin muncƒÉ.
            Veniturile fiscale locale per locuitor reflectƒÉ c√¢»õi bani se colecteazƒÉ.
            C√¢nd ambele valori sunt ridicate, vorbim de comunitƒÉ»õi dinamice, cu o economie puternicƒÉ
            »ôi administra»õie func»õionalƒÉ. C√¢nd ambele sunt scƒÉzute, e semn de slƒÉbiciune economicƒÉ,
            adesea legatƒÉ de migra»õie, »ôomaj sau lipsa unei baze de impozitare solide.</p>
            <ul>
<li><strong>Dreapta sus:</strong> localitƒÉ»õi cu mul»õi salaria»õi »ôi venituri fiscale mari. Sunt comunitƒÉ»õi prospere, bine administrate »ôi cu economie diversificatƒÉ.</li><br>
<li><strong>Dreapta jos:</strong> localitƒÉ»õi cu mul»õi salaria»õi, dar venituri fiscale mici, semn cƒÉ sunt zone cu salarii foarte mici, probabil zone industriale</li><br>
<li><strong>St√¢nga sus:</strong> localitƒÉ»õi cu pu»õini salaria»õi, dar venituri fiscale mari. Sunt posibile zone turistice, cu venituri din proprietƒÉ»õi sau venituri speciale.</li><br>
            <li><strong>St√¢nga jos:</strong> localitƒÉ»õi fragile, cu pu»õini salaria»õi »ôi venituri fiscale scƒÉzute, semn al unui poten»õial economic slab.</li>
            </ul>
            <strong>Impozitul mediu √Æn localitƒÉ»õile c√¢»ôtigate de Simion: sub 200 de lei / √én cele ale lui Nicu»ôor Dan: 1.300 lei</strong><br><br>
Pe acest grafic ies √Æn eviden»õƒÉ localitƒÉ»õile c√¢»ôtigate de Nicu»ôor Dan care
se pozi»õioneazƒÉ preponderent ca zone cu mai mul»õi salaria»õi (35%)
»ôi solide din punct de vedere al colectƒÉrii fiscale (1.319 impozit mediu/loc).
√én compara»õie, Simion a c√¢»ôtigat √Æn peste 2.700 de localitƒÉ»õi care oferƒÉ o medie
a salaria»õilor de 6,9% din totalul popula»õiei, cu un impozit mediu per locuitor
de 188 de lei. <br><br>
√én acela»ôi timp din grafic reies o serie de localitƒÉ»õi unde »ôi Simion »ôi Antonescu au c√¢»ôtigat ce au caracteristicile unor zone sƒÉrace sau zone unde, √Æn ciuda numƒÉrului mai mici de angaja»õi, existƒÉ un grad mare de impozitare (cadranul I din grafic).

        </div>

        <div id="scatter-container-4" class="scatter-plot-container" data-chart-id="scatter-viz-4">
            <svg id="scatter-viz-4" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce ne aratƒÉ rela»õia dintre fondurile europene atrase pe cap de locuitor »ôi numƒÉrul de pacien»õi care revin unui medic?</strong><br>
            AceastƒÉ combina»õie de indicatori, de»ôi pare necorelatƒÉ, ne ajutƒÉ sƒÉ √Æn»õelegem dacƒÉ
            investi»õiile publice contribuie, direct sau indirect, la √ÆmbunƒÉtƒÉ»õirea accesului
            la servicii medicale. Rom√¢nia are √Æn continuare zone √Æn care medicii nu sunt atra»ôi sƒÉ se stabileascƒÉ.
            Ne referim aici cel mai frecvent la medicii de familie. Fondurile europene atrase,
            indiferent de sectorul √Æn care sunt folosite, sprijinƒÉ dezvoltarea localƒÉ prin infrastructurƒÉ mai bunƒÉ,
            servicii publice modernizate, condi»õii mai bune de trai. Toate acestea pot face o localitate
            mai atractivƒÉ pentru medici »ôi al»õi speciali»ôti. NumƒÉrul mare de pacien»õi per medic
            indicƒÉ un sistem medical suprasolicitat. DacƒÉ o localitate atrage fonduri europene consistente,
            dar rƒÉm√¢ne cu pu»õini medici, e semn cƒÉ banii nu se transformƒÉ √ÆncƒÉ √Æn servicii publice eficiente.
            √én schimb, acolo unde fondurile sunt mari »ôi pacien»õii per medic pu»õini,
            investi»õiile par sƒÉ contribuie la o re»õea medicalƒÉ mai echilibratƒÉ.</p>
            <ul>
<li><strong>Dreapta sus:</strong> localitƒÉ»õi cu fonduri europene mari »ôi mul»õi pacien»õi per medic indicƒÉ investi»õii mari, dar lipsƒÉ de personal medical sau acces slab la sƒÉnƒÉtate.</li><br>
<li><strong>Dreapta jos:</strong> localitƒÉ»õi cu fonduri mari »ôi pu»õini pacien»õi per medic unde investi»õiile contribuie la servicii publice mai bune care atrage medici.</li><br>
<li><strong>St√¢nga sus:</strong> localitƒÉ»õi cu fonduri reduse »ôi mul»õi pacien»õi per medic. Sunt zone vulnerabile, cu acces medical limitat »ôi pu»õine investi»õii.</li><br>
<li><strong>St√¢nga jos:</strong> localitƒÉ»õi cu fonduri reduse »ôi mai pu»õini pacien»õi per medic sunt posibile excep»õii, unde re»õeaua medicalƒÉ func»õioneazƒÉ √Æn ciuda lipsei de investi»õii majore.</li>
            </ul>
<strong>Mai mul»õi bani europeni atra»ôi de localitƒÉ»õile c√¢»ôtigate de Dan »ôi Antonescu, dec√¢t cele adjudecate de Simion</strong><br><br>
√én aceastƒÉ reprezentare graficƒÉ apar, √Æn dreptul localitƒÉ»õilor c√¢»ôtigate la vot de
George Simion, o polarizare a zonelor unde investi»õiile europene sunt minime
sau chiar zero, iar √Æn cazul multor localitƒÉ»õi »ôi numƒÉrul de pacien»õi pe
medic este foarte ridicat. <br><br>
√én medie, √Æn dreptul localitƒÉ»õilor adjudecate de Simon vorbim de 1.931
de pacien»õi per medic, cu o investi»õie medie de fonduri europene per cap de
locuitor de doar 18 lei. √én cazul localitƒÉ»õilor adjudecate de Nicu»ôor Dan acestea
sunt pozi»õionate √Æn partea de jos a graficului, cu investi»õii europene
mai mari pe cap de locuitor (43 de lei), dar cu acces mult mai bun la medici
(725 de pacien»õi per medic). <br><br>
LocalitƒÉ»õile c√¢»ôtigate la vot de Crin Antonescu aratƒÉ o dispunere mai echilibratƒÉ, cu multe zone unde sunt contabilizate »ôi investi»õii din fonduri europene (25 de lei/loc), dar »ôi zone unde numƒÉrul de pacien»õi per medic este ridicat (media de 1.722 pacien»õi/medic).


        </div>
    </section>

    <div class="tooltip" id="tooltip"></div>

    <!-- START: Candidate Summary Pop-up HTML -->
    <div id="candidate-summary-popup">
        <div id="summary-text"></div>
        <div id="mini-chart-container">
            <svg id="mini-chart-svg"></svg>
        </div>
        <button id="close-summary-popup" title="√énchide">&times;</button>
    </div>



    <script>

        const DEBUG_MODE = true;


        function throttle(func, limit) {
            let lastFunc;
            let lastRan;
            return function(...args) {
                const context = this;
                if (!lastRan) {
                    func.apply(context, args);
                    lastRan = Date.now();
                } else {
                    clearTimeout(lastFunc);
                    lastFunc = setTimeout(function() {
                        if ((Date.now() - lastRan) >= limit) {
                            func.apply(context, args);
                            lastRan = Date.now();
                        }
                    }, limit - (Date.now() - lastRan));
                }
            }
        }

        let allDataGlobal;
        const mainWidth = 1000, mainHeight = 700;
        const plotWidth = 900, plotHeight = 550;
        const margin = { top: 60, right: 60, bottom: 60, left: 80 };
        const marginMain = { top: 60, right: 80, bottom: 70, left: 90 };

        const mobileDiameter = 3;
        const desktopDiameterLarge = 4.2;
        const desktopDiameterMedium = 4;
        const baseCircleDiameter = window.innerWidth <= 600 ? mobileDiameter : window.innerWidth > 800 ? desktopDiameterLarge : desktopDiameterMedium;

        const svgMain = d3.select("#viz");
        const tooltip = d3.select("#tooltip");
        const chartMain = svgMain.append("g").attr("id", "chartGroup");
        const searchEl = d3.select("#search-container");

        const summaryPopup = d3.select("#candidate-summary-popup");
        const summaryTextEl = d3.select("#summary-text");
        const miniChartSvg = d3.select("#mini-chart-svg");
        const closeSummaryButton = d3.select("#close-summary-popup");

        const winnerColors = {
            "GEORGE-NICOLAE SIMION": "#FFB623",
            "GEORGE-CRIN-LAUREN»öIU ANTONESCU": "#00B7FF",
            "NICU»òOR-DANIEL DAN": "#4DD400",
            "VICTOR-VIOREL PONTA": "#FF2A1F"
        };
        const colorScale = d3.scaleOrdinal(Object.keys(winnerColors), Object.values(winnerColors));

        let currentView = "sphere";
        let currentFilter = "all";
        let mainCircles;
        let staticCircles = [];
        let staticConfigs = {};
        let activeQuad = "all";
        let mainScatterConfig = {};
        let staticPlotsVisible = false;
        let observerInitialized = false;
        let activeStaticPlotConfig = null;

        let isViewTransitioning = false;
        const SCROLL_THROTTLE_LIMIT = 150;


        const normalize = str => (str || "").toString().normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().trim();


        function showSearchControls() { searchEl.classed("visible", true); }
        function hideSearchControls() { searchEl.classed("visible", false); }
        function updateSearchControlsVisibility() {
            if ((currentView === 'map' || currentView === 'scatter') || staticPlotsVisible) {
                showSearchControls();
            } else {
                hideSearchControls();
            }
        }


        function basicTooltip(d) {
            const jud = d.jud || 'N/A';
            const uat = d.uat || 'N/A';
            const castigator = d.Castigator || 'N/A';
            const procentCastigator = d["Procent castigator"] != null ? d["Procent castigator"].toFixed(2) + '%' : 'N/A';
            const prezenta = d.Prezenta != null ? d.Prezenta.toFixed(2) + '%' : 'N/A';
            return `<strong>${jud}</strong><br/>${uat}<br/>C√¢»ôtigƒÉtor: ${castigator}<br/>Procent: ${procentCastigator}<br/>Prezen»õa: ${prezenta}`;
        }

        function scatterTooltip(d, config) {
            const xValue = d[config.xField] !== undefined && d[config.xField] !== null ? d[config.xField].toFixed(config.xDecimals ?? 2) : 'N/A';
            const yValue = d[config.yField] !== undefined && d[config.yField] !== null ? d[config.yField].toFixed(config.yDecimals ?? 2) : 'N/A';
            const jud = d.jud || 'N/A';
            const uat = d.uat || 'N/A';
            const castigator = d.Castigator || 'N/A';
            const procentCastigator = d["Procent castigator"] != null ? d["Procent castigator"].toFixed(2) + '%' : 'N/A';
            const prezenta = d.Prezenta != null ? d.Prezenta.toFixed(2) + '%' : 'N/A';
            return `<strong>${jud}</strong><br/>${uat}<br/>${config.xLabel}: ${xValue}${config.xUnit ?? ''}<br/>${config.yLabel}: ${yValue}${config.yUnit ?? ''}<br/>C√¢»ôtigƒÉtor: ${castigator}<br/>Procent: ${procentCastigator}<br/>Prezen»õa: ${prezenta}`;
         }
         function updateTooltipPosition(event) {
            const tRect = tooltip.node().getBoundingClientRect();
            let left = event.pageX + 10, top = event.pageY - 15;
            const marginTT = 10;
            if (left + tRect.width > window.innerWidth - marginTT) left = event.pageX - tRect.width - 10;
            if (top + tRect.height > window.innerHeight - marginTT) top = event.pageY - tRect.height - 5;
            if (top < marginTT) top = marginTT;
            if (left < marginTT) left = marginTT;
            tooltip.style("left", left + "px").style("top", top + "px");
         }


        function createSpherePositions(data, radius = 250){
            data.forEach((d,i) => {
                const phi = Math.acos(-1 + (2 * i) / data.length);
                const theta = Math.sqrt(data.length * Math.PI) * phi;
                d.sphere_x = radius * Math.sin(phi) * Math.cos(theta);
                d.sphere_y = radius * Math.sin(phi) * Math.sin(theta);
                d.sphere_z = radius * Math.cos(phi);
            });
        }
        let rotationAngle = 0;
        const sphereAnimation = anime({
            targets: { angle: 0 }, angle: 2 * Math.PI, duration: 35000, easing: 'linear',
            loop: true, autoplay: false,
            update: anim => {
                rotationAngle = anim.animations[0].currentValue;
                if (currentView === "sphere") updateSphereVisuals();
            }
        });
        function updateSphereVisuals() {
            const f = 400, cx = mainWidth / 2, cy = mainHeight / 2;
            if (!mainCircles) return;
            mainCircles.each(function(d) {
                const xRot = d.sphere_x * Math.cos(rotationAngle) - d.sphere_z * Math.sin(rotationAngle);
                const zRot = d.sphere_x * Math.sin(rotationAngle) + d.sphere_z * Math.cos(rotationAngle);
                const scale = f / (f + zRot + 1e-6);
                d.display_x = cx + xRot * scale;
                d.display_y = cy + d.sphere_y * scale;
                d.base_sphere_r = Math.max(1, baseCircleDiameter * (scale > 0 ? scale : 0));
                d.display_opacity_z = Math.max(0.1, Math.min(1, (f - zRot) / (f * 1.5)));
            });
            applyGlobalFilterAndSearch();
        }


        function isPointInQuad(d, config, quad) {
            if (!config || !config.xField || !config.yField || !allDataGlobal) return false;
            const xMedian = config._xMedian ?? (config._xMedian = d3.median(allDataGlobal, dataPoint => dataPoint[config.xField]));
            const yMedian = config._yMedian ?? (config._yMedian = d3.median(allDataGlobal, dataPoint => dataPoint[config.yField]));
            if (xMedian === undefined || yMedian === undefined || xMedian === null || yMedian === null) return false;
            const xVal = d[config.xField], yVal = d[config.yField];
            if (xVal === undefined || yVal === undefined || xVal === null || yVal === null) return false;

            let pointQuad = "";
            if (xVal <= xMedian && yVal >= yMedian) pointQuad = "I";
            else if (xVal > xMedian && yVal >= yMedian) pointQuad = "II";
            else if (xVal <= xMedian && yVal < yMedian) pointQuad = "III";
            else if (xVal > xMedian && yVal < yMedian) pointQuad = "IV";
            return pointQuad === quad;
         }

        function hideSummaryPopup() {
            summaryPopup.classed("visible", false);
            miniChartSvg.selectAll("*").remove();
        }

        function showSummaryPopup(candidateName, candidateData, config) {
            if (DEBUG_MODE) console.log("[showSummaryPopup] Called. Candidate:", candidateName, "Config ID:", config ? config.id : "N/A", "Config Title:", config ? config.title : "N/A");
            if (!config || !config.xField || !config.yField) {
                if (DEBUG_MODE) console.warn("[showSummaryPopup] Invalid config provided:", config);
                hideSummaryPopup();
                return;
            }
            if (!candidateData) {
                hideSummaryPopup();
                return;
            }

            const validCandidateData = candidateData.filter(d =>
                d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number' &&
                d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number'
            );

            if (validCandidateData.length === 0) {
                 summaryTextEl.html(`<p><strong>${candidateName.replace(/-/g, ' ')}</strong> a c√¢»ôtigat ${candidateData.length} localitƒÉ»õi, dar nu existƒÉ date valide pentru axele curente (<i>${config.xLabel}</i> / <i>${config.yLabel}</i>) √Æn aceste localitƒÉ»õi.</p>`);
                 miniChartSvg.selectAll("*").remove();
                 summaryPopup.classed("visible", true);
                 return;
            }

            const medianX = d3.median(validCandidateData, d => d[config.xField]);
            const medianY = d3.median(validCandidateData, d => d[config.yField]);
            const count = candidateData.length;
            const xValStr = medianX !== undefined ? medianX.toFixed(config.xDecimals ?? 1) + (config.xUnit ?? '') : 'N/A';
            const yValStr = medianY !== undefined ? medianY.toFixed(config.yDecimals ?? 1) + (config.yUnit ?? '') : 'N/A';

            summaryTextEl.html(`<p><strong>${candidateName.replace(/-/g, ' ')}</strong> a c√¢»ôtigat ${count} localitƒÉ»õi.
               Mediane √Æn localitƒÉ»õile c√¢»ôtigate:
                <br> ‚Ä¢ <i>${config.xLabel}</i>: ${xValStr}
                <br> ‚Ä¢ <i>${config.yLabel}</i>: ${yValStr}</p>`);
            drawMiniChart(validCandidateData, config, medianX, medianY, candidateName);
            summaryPopup.classed("visible", true);
        }

        function drawMiniChart(data, config, medianX, medianY, candidateName) {
            miniChartSvg.selectAll("*").remove();
            const candidateColor = winnerColors[candidateName] || '#AAAAAA';
            const miniMargin = { top: 5, right: 20, bottom: 20, left: 45 };
            const containerWidth = parseInt(miniChartSvg.style("width"));
            const containerHeight = parseInt(miniChartSvg.style("height"));

            if (!containerWidth || !containerHeight || containerWidth <= 0 || containerHeight <= 0) {
                 if (DEBUG_MODE) console.warn("[drawMiniChart] Mini chart container has no valid dimensions.");
                 return;
            }
            const miniWidth = containerWidth - miniMargin.left - miniMargin.right;
            const miniHeight = containerHeight - miniMargin.top - miniMargin.bottom;
            if (miniWidth <= 0 || miniHeight <= 0) {
                 if (DEBUG_MODE) console.warn("[drawMiniChart] Mini chart calculated dimensions are invalid.");
                 return;
            }

            const chartGroup = miniChartSvg.append("g")
                .attr("transform", `translate(${miniMargin.left},${miniMargin.top})`);
            let contextXScale, contextYScale;
            const validDataForExtentContext = allDataGlobal.filter(d =>
                 d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number' &&
                 d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number'
            );

            if (validDataForExtentContext.length > 0) {
                 const xExtentContext = d3.extent(validDataForExtentContext, d => d[config.xField]);
                 const yExtentContext = d3.extent(validDataForExtentContext, d => d[config.yField]);
                 const xDomainContext = (xExtentContext[0] === undefined || xExtentContext[1] === undefined) ? [0, 1] : xExtentContext;
                 const yDomainContext = (yExtentContext[0] === undefined || yExtentContext[1] === undefined) ? [0, 1] : yExtentContext;
                 contextXScale = d3.scaleLinear().domain(xDomainContext).nice();
                 contextYScale = d3.scaleLinear().domain(yDomainContext).nice();
            }

            if (!contextXScale || !contextYScale) {
                 if (DEBUG_MODE) console.warn("[drawMiniChart] Cannot be drawn without context scales for config:", config ? config.id : "N/A");
                 chartGroup.append("text").attr("x", miniWidth / 2).attr("y", miniHeight / 2).attr("text-anchor", "middle").attr("font-size", "10px").attr("fill", "#aaa").text("Eroare scalƒÉ");
                 return;
            }

            const miniX = d3.scaleLinear().domain(contextXScale.domain()).range([0, miniWidth]);
            chartGroup.append("g").attr("class", "mini-axis").attr("transform", `translate(0, ${miniHeight})`)
                .call(d3.axisBottom(miniX).ticks(3).tickSize(3).tickPadding(2));
            chartGroup.append("text").attr("class", "mini-axis-label").attr("x", miniWidth / 2).attr("y", miniHeight + miniMargin.bottom - 0.1).text(config.xLabel);

            if (medianX !== undefined && isFinite(miniX(medianX))) {
                chartGroup.append("line").attr("class", "mini-median-line").attr("x1", miniX(medianX)).attr("x2", miniX(medianX)).attr("y1", 0).attr("y2", miniHeight).style("stroke", candidateColor);
                chartGroup.append("text").attr("class", "mini-median-label").attr("x", miniX(medianX)).attr("y", -2).attr("text-anchor", "middle").text(medianX.toFixed(config.xDecimals ?? 1)).style("fill", candidateColor);
            }

            const miniY = d3.scaleLinear().domain(contextYScale.domain()).range([miniHeight, 0]);
            chartGroup.append("g").attr("class", "mini-axis").call(d3.axisLeft(miniY).ticks(3).tickSize(3).tickPadding(2));
            chartGroup.append("text").attr("class", "mini-axis-label").attr("transform", "rotate(-90)").attr("x", -miniHeight / 2).attr("y", -miniMargin.left + 12).text(config.yLabel);

            if (medianY !== undefined && isFinite(miniY(medianY))) {
                 chartGroup.append("line").attr("class", "mini-median-line").attr("x1", 0).attr("x2", miniWidth).attr("y1", miniY(medianY)).attr("y2", miniY(medianY)).style("stroke", candidateColor);
                 chartGroup.append("text").attr("class", "mini-median-label").attr("x", -3).attr("y", miniY(medianY)).attr("text-anchor", "end").attr("alignment-baseline", "middle").text(medianY.toFixed(config.yDecimals ?? 1)).style("fill", candidateColor);
             }
        }


        function applyGlobalFilterAndSearch() {
            const searchTerm = normalize(d3.select("#search-input").property("value"));
            const isSearching = searchTerm.length > 0;
            const selectedWinner = d3.select("#winner-filter").property("value");
            currentFilter = selectedWinner;

            let showPopupDecision = false;
            let configForPopup = null;
            const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);

            if (selectedWinner !== 'all' && !isSearching) {
                if (staticPlotsVisible && activeStaticPlotConfig) {
                    configForPopup = activeStaticPlotConfig;
                    if (DEBUG_MODE) console.log(`[applyGlobalFilterAndSearch] Popup Context: ACTIVE STATIC (${activeStaticPlotConfig.id}), staticPlotsVisible=${staticPlotsVisible}, MainOpacity: ${mainChartOpacity.toFixed(2)}`);
                }
                else if (currentView === 'scatter' && mainChartOpacity >= 0.5) {
                    configForPopup = mainScatterConfig;
                    if (DEBUG_MODE) console.log(`[applyGlobalFilterAndSearch] Popup Context: MAIN SCATTER (${mainScatterConfig.id}), MainOpacity: ${mainChartOpacity.toFixed(2)}, staticPlotsVisible=${staticPlotsVisible}, activeStaticPlotConfig=${activeStaticPlotConfig?.id}`);
                } else {
                    if (DEBUG_MODE) {
                        console.log(`[applyGlobalFilterAndSearch] Popup Context: No specific config or conditions not met. SelectedWinner: ${selectedWinner}, IsSearching: ${isSearching}, staticPlotsVisible=${staticPlotsVisible}, activeStaticPlotConfig=${activeStaticPlotConfig?.id}, mainChartOpacity=${mainChartOpacity.toFixed(2)}, currentView=${currentView}, mainScatterConfig=${mainScatterConfig?.id}`);
                    }
                }
            }

            if (configForPopup) {
                const candidateSpecificData = allDataGlobal.filter(d => d.Castigator === selectedWinner);
                showSummaryPopup(selectedWinner, candidateSpecificData, configForPopup);
                showPopupDecision = true;
            }

            if (!showPopupDecision) {
                hideSummaryPopup();
                 if (DEBUG_MODE && selectedWinner !== 'all' && !isSearching) {
                    console.log(`[applyGlobalFilterAndSearch] Hiding Pop-up. Reason: No suitable configForPopup or filter not active/search active. SelectedWinner: ${selectedWinner}, IsSearching: ${isSearching}, configForPopup: ${configForPopup?.id}`);
                 }
            }

            let areaScale;
            if (allDataGlobal) {
                const validPercentages = allDataGlobal.map(d => d["Procent castigator"]).filter(p => p != null && !isNaN(p));
                if (validPercentages.length > 0) {
                    const extent = d3.extent(validPercentages);
                     if (extent[0] !== undefined && extent[1] !== undefined) {
                        areaScale = d3.scaleSqrt().domain(extent).range([baseCircleDiameter * 0.8, baseCircleDiameter * 2.2]);
                     }
                }
            }

            d3.selectAll(".data-circle").each(function(d) {
                if (isSearching && normalize(d.uat) === searchTerm) d3.select(this).raise();
            });

            d3.selectAll(".data-circle")
                .transition("filterSearch").duration(350)
                .attr("opacity", function(d) {
                    const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                    const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                    if (!isWinnerMatch || !isSearchMatch) return 0.08;
                    let baseOpacity = 1.0;
                    const isMain = d3.select(this).classed('main-circle');
                    const isStatic = d3.select(this).classed('static-circle');
                    if (isStatic) {
                         const parentSvgId = d3.select(this.ownerSVGElement).attr('id');
                         const config = staticConfigs[parentSvgId];
                         if(config && (d[config.xField] === null || d[config.yField] === null || d[config.xField] === undefined || d[config.yField] === undefined )) baseOpacity = 0.05;
                         else baseOpacity = 0.75;
                    } else if (isMain) {
                        if (currentView === 'sphere') baseOpacity = d.display_opacity_z ?? 1.0;
                        else if (currentView === 'map') baseOpacity = (d.Lat && d.Long) ? 0.8 : 0;
                        else if (currentView === 'scatter') {
                            const config = mainScatterConfig;
                             if (!config || !config.xField || !config.yField) return 0;
                            const xVal = d[config.xField], yVal = d[config.yField];
                            const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                            if (!hasValidScatterData) return 0;
                            const isQuadActive = activeQuad !== 'all';
                            const inActiveQuad = isQuadActive && isPointInQuad(d, config, activeQuad);
                            if (isQuadActive && !inActiveQuad) baseOpacity = 0.05;
                            else baseOpacity = 0.8;
                        }
                    }
                    if (isSearching && !exactSearchMatch && isWinnerMatch && isSearchMatch) baseOpacity *= 0.6;
                    if (exactSearchMatch) baseOpacity = isStatic ? 0.9 : 1.0;
                    return Math.max(0.05, baseOpacity);
                })
                .attr("stroke", function(d) {
                    const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                    const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                    if (!isWinnerMatch || !isSearchMatch) return "none";
                    if (exactSearchMatch) return "#FFFFFF";
                    if (currentFilter !== "all" && isWinnerMatch) return "#FFFFFF";
                    const isMain = d3.select(this).classed('main-circle');
                    if (isMain && currentView === 'scatter' && activeQuad !== 'all') {
                         const config = mainScatterConfig;
                          if (!config || !config.xField || !config.yField) return "none";
                         const xVal = d[config.xField], yVal = d[config.yField];
                         const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                         if (hasValidScatterData && isPointInQuad(d, config, activeQuad)) return "#FFF";
                    }
                    return "none";
                })
                .attr("stroke-width", function(d) {
                     const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                     const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                     if (!isWinnerMatch || !isSearchMatch) return 0;
                     const isMain = d3.select(this).classed('main-circle');
                     if (exactSearchMatch) return isMain ? 3 : 2.5;
                     if (currentFilter !== "all" && isWinnerMatch) return 1;
                     if (isMain && currentView === 'scatter' && activeQuad !== 'all') {
                          const config = mainScatterConfig;
                           if (!config || !config.xField || !config.yField) return 0;
                          const xVal = d[config.xField], yVal = d[config.yField];
                          const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                          if (hasValidScatterData && isPointInQuad(d, config, activeQuad)) return 1;
                     }
                     return 0;
                 })
                 .attr("cx", function(d) {
                    if (currentView === 'sphere' && d3.select(this).classed('main-circle')) return d.display_x;
                    const currentCx = d3.select(this).attr("cx");
                    return isFinite(currentCx) ? currentCx : -100;
                 })
                 .attr("cy", function(d) {
                    if (currentView === 'sphere' && d3.select(this).classed('main-circle')) return d.display_y;
                    const currentCy = d3.select(this).attr("cy");
                    return isFinite(currentCy) ? currentCy : -100;
                 })
                 .attr("r", function(d) {
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                     const boostFactor = 1.8;
                     const isMain = d3.select(this).classed('main-circle');
                     let baseRadius = 0;
                     const procent = d["Procent castigator"];
                     if (isMain) {
                         if (currentView === 'sphere') baseRadius = d.base_sphere_r ?? 0;
                         else if (currentView === 'map' && areaScale && procent != null && !isNaN(procent)) baseRadius = (d.Lat != null && d.Long != null) ? areaScale(procent) : 0;
                         else if (currentView === 'scatter') {
                             const config = mainScatterConfig;
                              if (!config || !config.xField || !config.yField) return 0;
                             const xVal = d[config.xField], yVal = d[config.yField];
                             baseRadius = (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 1.1 : 0;
                         }
                     } else {
                          const parentSvgId = d3.select(this.ownerSVGElement).attr('id');
                          const config = staticConfigs[parentSvgId];
                          if (config) {
                              const xVal = d[config.xField], yVal = d[config.yField];
                              baseRadius = (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 0.75 : 0;
                          } else baseRadius = 0;
                     }
                     baseRadius = (typeof baseRadius === 'number' && !isNaN(baseRadius)) ? baseRadius : 0;
                     return (exactSearchMatch && baseRadius > 0) ? baseRadius * boostFactor : baseRadius;
                 })
                 .style("pointer-events", function(d) {
                    const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                    const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                    const opacity = parseFloat(d3.select(this).attr("opacity"));
                    const radius = parseFloat(d3.select(this).attr("r"));
                    if (isWinnerMatch && isSearchMatch && radius > 0.1 && opacity > 0.06) return 'auto';
                    return 'none';
                 });
         }


        function createScatterPlot(containerSelector, data, config) {
             const svg = d3.select(containerSelector);
             const svgId = svg.attr('id');
             staticConfigs[svgId] = config;
             if (allDataGlobal && allDataGlobal.length > 0) {
                config._xMedian = d3.median(allDataGlobal, d => (d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number') ? d[config.xField] : undefined);
                config._yMedian = d3.median(allDataGlobal, d => (d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number') ? d[config.yField] : undefined);
             } else {
                 config._xMedian = undefined;
                 config._yMedian = undefined;
             }
             svg.selectAll("*").remove();
             const plotGroup = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
             const innerWidth = plotWidth - margin.left - margin.right;
             const innerHeight = plotHeight - margin.top - margin.bottom;
             const scatterPlotData = data.filter(d =>
                d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number' &&
                d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number'
             );
             const validDataForExtent = scatterPlotData;
             const xExtent = d3.extent(validDataForExtent, d => d[config.xField]);
             const yExtent = d3.extent(validDataForExtent, d => d[config.yField]);
             const xDomain = (xExtent[0] === undefined || xExtent[1] === undefined) ? [0, 1] : xExtent;
             const yDomain = (yExtent[0] === undefined || yExtent[1] === undefined) ? [0, 1] : yExtent;
             const x = d3.scaleLinear().domain(xDomain).nice().range([0, innerWidth]);
             const y = d3.scaleLinear().domain(yDomain).nice().range([innerHeight, 0]);
             const xMedian = config._xMedian, yMedian = config._yMedian;

            plotGroup.append("g").attr("class", "x-axis axis").attr("transform", `translate(0,${innerHeight})`).call(d3.axisBottom(x).ticks(7).tickSizeOuter(0));
            plotGroup.append("text").attr("class", "axis-label x-label").attr("x", innerWidth / 2).attr("y", innerHeight + margin.bottom - 15).text(config.xLabelFull || config.xLabel);
            plotGroup.append("g").attr("class", "y-axis axis").call(d3.axisLeft(y).ticks(7).tickSizeOuter(0));
            plotGroup.append("text").attr("class", "axis-label y-label").attr("transform", "rotate(-90)").attr("x", -innerHeight / 2).attr("y", -margin.left + 20).text(config.yLabelFull || config.yLabel);
            svg.append("text").attr("class", "plot-title").attr("x", margin.left + innerWidth / 2).attr("y", margin.top - 90).text(config.title); // Adjusted title Y

            if (xMedian !== undefined && xMedian !== null && isFinite(x(xMedian))) plotGroup.append("line").attr("class", "quadrant-line").attr("x1", x(xMedian)).attr("x2", x(xMedian)).attr("y1", 0).attr("y2", innerHeight);
            if (yMedian !== undefined && yMedian !== null && isFinite(y(yMedian))) plotGroup.append("line").attr("class", "quadrant-line").attr("x1", 0).attr("x2", innerWidth).attr("y1", y(yMedian)).attr("y2", y(yMedian));

            const isMobile = window.innerWidth <= 600;
            const outerLabelPadding = isMobile ? 20 : 30;
            const outerLabelYOffset = isMobile ? -25 : -35;
            const outerLabelYOffsetBottom = isMobile ? 35 : 45;

            if (config.quadLabels && xMedian !== undefined && yMedian !== undefined && xMedian !== null && yMedian !== null && isFinite(x(xMedian)) && isFinite(y(yMedian))) {
                 const labelData = [
                     { quad: 'II', anchor: 'end', xPos: innerWidth + outerLabelPadding, yPos: outerLabelYOffset },
                     { quad: 'I', anchor: 'start', xPos: -outerLabelPadding, yPos: outerLabelYOffset },
                     { quad: 'III', anchor: 'start', xPos: -outerLabelPadding, yPos: innerHeight + outerLabelYOffsetBottom },
                     { quad: 'IV', anchor: 'end', xPos: innerWidth + outerLabelPadding, yPos: innerHeight + outerLabelYOffsetBottom }
                 ];
                 labelData.forEach(lbl => {
                     const labelText = config.quadLabels[lbl.quad];
                     if (!labelText) return;
                     const lines = labelText.split('\n');
                     const textElement = plotGroup.append("text").attr("class", "quadrant-label quadrant-label-outer").attr("x", lbl.xPos).attr("y", lbl.yPos).attr("text-anchor", lbl.anchor);
                     lines.forEach((line, i) => textElement.append("tspan").attr("x", lbl.xPos).attr("dy", i === 0 ? "0" : "1.1em").text(line));
                 });
             }
             const circles = plotGroup.selectAll(".data-circle").data(scatterPlotData, d => d.uat + d.jud)
                .enter().append("circle").attr("class", "data-circle static-circle").attr("cx", d => x(d[config.xField])).attr("cy", d => y(d[config.yField]))
                .attr("r", baseCircleDiameter * 0.75).attr("fill", d => colorScale(d.Castigator) || "#999").attr("opacity", 0.75)
                .attr("stroke", "none").attr("stroke-width", 0).style("pointer-events", 'auto')
                .on("mouseover", (event, d) => {
                     tooltip.style("opacity", 1).html(scatterTooltip(d, config));
                     d3.select(event.currentTarget).raise().attr("stroke", "#000").attr("stroke-width", 1.5);
                 })
                .on("mousemove", updateTooltipPosition)
                .on("mouseout", (event, d) => {
                    tooltip.style("opacity", 0);
                     const searchTerm = normalize(d3.select("#search-input").property("value"));
                     const isSearching = searchTerm.length > 0;
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                     const isHighlightedByFilter = currentFilter !== "all" && d.Castigator === currentFilter;
                     let finalStroke = "none", finalStrokeWidth = 0;
                     if (exactSearchMatch) { finalStroke = "#FFFFFF"; finalStrokeWidth = 2.5; }
                     else if (isHighlightedByFilter) { finalStroke = "#FFFFFF"; finalStrokeWidth = 1; }
                     d3.select(event.currentTarget).attr("stroke", finalStroke).attr("stroke-width", finalStrokeWidth);
                });
             staticCircles.push(circles);
             return circles;
         }


        d3.csv("scatter.csv", d3.autoType).then(data => {
            allDataGlobal = data.filter(d => d.Castigator && d.uat && d.jud);
            allDataGlobal.forEach(d => {
                const checkAndConvert = (value) => {
                    if (value === "#N/A" || value === "#DIV/0!") return null;
                    if (value != null && typeof value === 'string') {
                        const cleanedValue = parseFloat(String(value).replace(",", "."));
                        return isNaN(cleanedValue) ? null : cleanedValue;
                    }
                     if (value == null || isNaN(value)) return null;
                    return value;
                };
                const fieldsToClean = ["Procent castigator", "Prezenta", "Lat", "Long", "Procent plecari din populatie (2023)", "Suprafata locuibila/cap de locuitor (m patrati) 2023", "Numarul de salariati raportat la populatie (% din populatie) 2023", "Cote de impozit raportat la populatie (2022)", "Fonduri pe cap de locuitor (2022)", "Pacienti la un medic 2023", "Varsta medie a populatiei in 2023", "Ponderea somerilor in 2023"];
                fieldsToClean.forEach(field => {
                    if (d.hasOwnProperty(field)) d[field] = checkAndConvert(d[field]);
                    else d[field] = null;
                });
            });

            const scatterConfig1 = { id: "scatter-viz-1", xField: "Varsta medie a populatiei in 2023", yField: "Suprafata locuibila/cap de locuitor (m patrati) 2023", xLabel: "V√¢rsta medie", yLabel: "Suprafa»õƒÉ/loc.", xUnit: " ani", yUnit: " m¬≤", xDecimals: 1, yDecimals: 1, title: "V√¢rsta medie a popula»õiei »ôi suprafa»õa locuibilƒÉ/cap de locuitor", xLabelFull: "V√¢rsta medie a popula»õiei (ani)", yLabelFull: "Suprafa»õƒÉ locuibilƒÉ/locuitor (m¬≤)", quadLabels: { I: "I. Suburbii sau localitƒÉ»õi \nperiurbane prospere, \nspa»õiu mare", II: "II. LocalitƒÉ»õi √ÆmbƒÉtr√¢nite\n »ôi spa»õii de locuit mari", III: "III. Ora»ôe cu cartiere \naglomerate/densitate mare", IV: "IV. Zone rurale sƒÉrace \ncu pop. v√¢rstnicƒÉ" } };
            const scatterConfig2 = { id: "scatter-viz-2", xField: "Procent plecari din populatie (2023)", yField: "Ponderea somerilor in 2023", xLabel: "PlecƒÉri", yLabel: "»òomeri", xUnit: "%", yUnit: "%", xDecimals: 1, yDecimals: 1, title: "PlecƒÉrile din localitate »ôi ponderea »ôomerilor", xLabelFull: "Procent plecƒÉri din popula»õie (%)", yLabelFull: "Pondere »ôomeri √Æn popula»õie (%)", quadLabels: { I: "I. Zone unde popula»õia \nrƒÉm√¢ne din lipsƒÉ \nde alternative", II: "II. Zone aflate \n√Æn declin economic sever", III: "III. Zone stabile economic", IV: "IV. Zone dinamice, \ndar tranzitorii" } };
            const scatterConfig3 = { id: "scatter-viz-3", xField: "Numarul de salariati raportat la populatie (% din populatie) 2023", yField: "Cote de impozit raportat la populatie (2022)", xLabel: "Salaria»õi", yLabel: "Impozit/loc.", xUnit: "%", yUnit: " lei", xDecimals: 1, yDecimals: 0, title: "Salaria»õi vs. Venituri din Impozite", xLabelFull: "Salaria»õi / Popula»õie (%)", yLabelFull: "Cote impozit / Popula»õie (lei/loc.)", quadLabels: { I: "I. ComunitƒÉ»õi mici/turistice \nsau cu venituri speciale", II: "II. Economie solidƒÉ, \ncolectare fiscalƒÉ eficientƒÉ", III: "III. Zone sƒÉrace, \nfƒÉrƒÉ activitate economicƒÉ", IV: "IV. Zone industriale \nsau muncitore»ôti \ncu salarii mici" } };
            const scatterConfig4 = { id: "scatter-viz-4", xField: "Fonduri pe cap de locuitor (2022)", yField: "Pacienti la un medic 2023", xLabel: "Fonduri UE/loc.", yLabel: "Pacien»õi/medic", xUnit: " lei", yUnit: "", xDecimals: 0, yDecimals: 0, title: "Fonduri Europene vs. Acces la Medici", xLabelFull: "Fonduri europene / Locuitor (lei)", yLabelFull: "NumƒÉr pacien»õi / medic", quadLabels: { I: "I. Zone sƒÉrace, \nfƒÉrƒÉ fonduri", II: "II. Investi»õii recente \nfƒÉrƒÉ impact asupra sistemului medical", III: "III. Zone izolate, popula»õie \nmicƒÉ sau posibile excep»õii", IV: "IV. Investi»õii consistente, \ninfrastructurƒÉ bunƒÉ" } };

            mainScatterConfig = scatterConfig1;
            if (allDataGlobal && allDataGlobal.length > 0) {
                 const validDataForMedianX = allDataGlobal.map(d => d[mainScatterConfig.xField]).filter(v => v != null && !isNaN(v) && typeof v === 'number');
                 const validDataForMedianY = allDataGlobal.map(d => d[mainScatterConfig.yField]).filter(v => v != null && !isNaN(v) && typeof v === 'number');
                 mainScatterConfig._xMedian = validDataForMedianX.length > 0 ? d3.median(validDataForMedianX) : undefined;
                 mainScatterConfig._yMedian = validDataForMedianY.length > 0 ? d3.median(validDataForMedianY) : undefined;
            } else { mainScatterConfig._xMedian = undefined; mainScatterConfig._yMedian = undefined; }

            const validPercentagesMap = allDataGlobal.map(d => d["Procent castigator"]).filter(p => p != null && !isNaN(p));
            let areaScale;
            if (validPercentagesMap.length > 0) {
                 const extent = d3.extent(validPercentagesMap);
                 if (extent[0] !== undefined && extent[1] !== undefined) areaScale = d3.scaleSqrt().domain(extent).range([baseCircleDiameter * 0.8, baseCircleDiameter * 2.2]);
            }
            const validLongs = allDataGlobal.map(d => d.Long).filter(l => l != null && !isNaN(l));
            const validLats = allDataGlobal.map(d => d.Lat).filter(l => l != null && !isNaN(l));
            let xGeo, yGeo;
            if (validLongs.length > 0 && validLats.length > 0) {
                 xGeo = d3.scaleLinear().domain(d3.extent(validLongs)).range([marginMain.left, mainWidth - marginMain.right]);
                 yGeo = d3.scaleLinear().domain(d3.extent(validLats)).range([mainHeight - marginMain.bottom, marginMain.top]);
            }
            createSpherePositions(allDataGlobal, 250);

            mainCircles = chartMain.selectAll("circle.main-circle").data(allDataGlobal, d => d.uat + d.jud)
                .enter().append("circle").attr("class", "data-circle main-circle").attr("fill", d => colorScale(d.Castigator) || "#999")
                .attr("opacity", 0).style("pointer-events", "auto")
                .on("mouseover", (event, d) => {
                     tooltip.style("opacity", 1);
                     let configForTooltip = mainScatterConfig;
                      const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);
                      if (mainChartOpacity < 0.5 && staticPlotsVisible && activeStaticPlotConfig) configForTooltip = activeStaticPlotConfig;
                      else if (currentView !== 'scatter') configForTooltip = null;
                     if (currentView === 'sphere' || currentView === 'map' || !configForTooltip) tooltip.html(basicTooltip(d));
                     else {
                         const xVal = d[configForTooltip.xField], yVal = d[configForTooltip.yField];
                         if (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) tooltip.html(scatterTooltip(d, configForTooltip));
                         else tooltip.html(basicTooltip(d));
                     }
                     d3.select(event.currentTarget).raise().attr("stroke", "#000").attr("stroke-width", currentView === 'sphere' ? 2.5 : 2);
                 })
                .on("mousemove", updateTooltipPosition)
                .on("mouseout", (event, d) => {
                    tooltip.style("opacity", 0);
                    const searchTerm = normalize(d3.select("#search-input").property("value"));
                    const isSearching = searchTerm.length > 0;
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                    const isHighlightedByFilter = currentFilter !== "all" && d.Castigator === currentFilter;
                    let inActiveQuadHighlight = false;
                     if (currentView === 'scatter' && activeQuad !== 'all') {
                         const config = mainScatterConfig;
                          if (config && config.xField && config.yField) {
                            const xVal = d[config.xField], yVal = d[config.yField];
                            const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                            if (hasValidScatterData && isPointInQuad(d, config, activeQuad)) inActiveQuadHighlight = true;
                          }
                     }
                    let finalStroke = "none", finalStrokeWidth = 0;
                    if (exactSearchMatch) { finalStroke = "#FFFFFF"; finalStrokeWidth = 3; }
                    else if (isHighlightedByFilter) { finalStroke = "#FFFFFF"; finalStrokeWidth = 1; }
                    else if (inActiveQuadHighlight) { finalStroke = "#FFFFFF"; finalStrokeWidth = 1; }
                    d3.select(event.currentTarget).attr("stroke", finalStroke).attr("stroke-width", finalStrokeWidth);
                });
            updateSphereVisuals();
            sphereAnimation.play();

            const datalist = document.getElementById("localitati-list");
            [...new Set(allDataGlobal.map(d => d.uat).filter(Boolean))].sort((a, b) => a.localeCompare(b, "ro-RO"))
                .forEach(name => { const opt = document.createElement("option"); opt.value = name; datalist.appendChild(opt); });
            d3.select("#search-input").on("input", applyGlobalFilterAndSearch);
            d3.select("#clear-search").on("click", () => { d3.select("#search-input").property("value", ""); applyGlobalFilterAndSearch(); });
            d3.select("#winner-filter").on("change", applyGlobalFilterAndSearch);
            closeSummaryButton.on("click", hideSummaryPopup);

            staticCircles = []; staticConfigs = {};
            createScatterPlot("#scatter-viz-1", allDataGlobal, scatterConfig1);
            createScatterPlot("#scatter-viz-2", allDataGlobal, scatterConfig2);
            createScatterPlot("#scatter-viz-3", allDataGlobal, scatterConfig3);
            createScatterPlot("#scatter-viz-4", allDataGlobal, scatterConfig4);
            applyGlobalFilterAndSearch();


            function toSphere() {
                if (currentView === 'sphere' || isViewTransitioning) return;
                isViewTransitioning = true;
                hideSummaryPopup(); activeStaticPlotConfig = null;
                if (DEBUG_MODE) console.log("[ViewChange] Transitioning to Sphere");
                currentView = "sphere"; window.IO?.disconnect(); activeQuad = 'all'; observerInitialized = false;
                sphereAnimation.play(); updateSearchControlsVisibility();
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .map-scroll-hint, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();
                updateSphereVisuals();
                setTimeout(() => { isViewTransitioning = false; }, 50);
            }

            function toMap() {
                if (currentView === 'map' || !xGeo || !yGeo || isViewTransitioning) return;
                isViewTransitioning = true;
                hideSummaryPopup(); activeStaticPlotConfig = null;
                if (DEBUG_MODE) console.log("[ViewChange] Transitioning to Map");
                currentView = "map"; window.IO?.disconnect(); activeQuad = 'all'; observerInitialized = false;
                sphereAnimation.pause(); updateSearchControlsVisibility();
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .map-scroll-hint, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();

                svgMain.append("text").attr("class", "map-title").attr("x", mainWidth / 2).attr("y", marginMain.top / 2).text("Distribu»õia c√¢»ôtigƒÉtorilor pe localitƒÉ»õi");
                svgMain.append("text").attr("class", "map-subtitle").attr("x", mainWidth / 2).attr("y", marginMain.top / 2 + 22).text("Dimensiunea cercurilor indicƒÉ procentul ob»õinut de c√¢»ôtigƒÉtor.");

                
                svgMain.append("text")
                    .attr("class", "map-scroll-hint") // New class for this text
                    .attr("x", mainWidth / 2)
                    .attr("y", mainHeight - (marginMain.bottom / 2) + 10) // Position it in the bottom margin area
                    .attr("text-anchor", "middle")
                    .style("font-size", "1.2em")
                    .style("fill", "#ffffff")
                    .text("Scroll √Æn continuare pentru grafice");
               

                mainCircles.transition("mapPos").duration(1500).ease(d3.easeCubicInOut)
                    .attr("cx", d => (d.Long != null && !isNaN(d.Long) && isFinite(xGeo(d.Long))) ? xGeo(d.Long) : -100)
                    .attr("cy", d => (d.Lat != null && !isNaN(d.Lat) && isFinite(yGeo(d.Lat))) ? yGeo(d.Lat) : -100)
                    .attr("r", d => (d.Lat != null && d.Long != null && areaScale && d["Procent castigator"] != null && !isNaN(d["Procent castigator"])) ? areaScale(d["Procent castigator"]) : 0)
                    .end().then(() => {
                        applyGlobalFilterAndSearch();
                        isViewTransitioning = false;
                    }).catch(err => {
                        console.error("Map transition error:", err);
                        applyGlobalFilterAndSearch();
                        isViewTransitioning = false;
                    });
            }

            function toScatter() {
                if (currentView === 'scatter' || isViewTransitioning) return;
                isViewTransitioning = true;
                hideSummaryPopup(); activeStaticPlotConfig = null;
                if (DEBUG_MODE) console.log("[ViewChange] Transitioning to Main Scatter");
                currentView = "scatter"; sphereAnimation.pause(); updateSearchControlsVisibility();
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .map-scroll-hint, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();
                const config = mainScatterConfig;
                 if (!config || !config.xField || !config.yField) {
                     console.error("Main scatter config invalid for transition.");
                     isViewTransitioning = false; return;
                 }
                const innerWidth = mainWidth - marginMain.left - marginMain.right;
                const innerHeight = mainHeight - marginMain.top - marginMain.bottom;
                const validScatterData = allDataGlobal.filter(d =>
                     d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number' &&
                     d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number'
                 );
                 if (validScatterData.length === 0) {
                     if (DEBUG_MODE) console.warn("[toScatter] No valid data points for the main scatter plot.");
                     svgMain.append("text").attr("x", mainWidth/2).attr("y", mainHeight/2).attr("text-anchor", "middle").attr("fill", "#ccc").text("Date insuficiente pentru acest grafic.");
                     isViewTransitioning = false; return;
                 }
                const xExtent = d3.extent(validScatterData, d => d[config.xField]);
                const yExtent = d3.extent(validScatterData, d => d[config.yField]);
                const xDomain = (xExtent[0] === undefined || xExtent[1] === undefined) ? [0, 1] : xExtent;
                const yDomain = (yExtent[0] === undefined || yExtent[1] === undefined) ? [0, 1] : yExtent;
                const x = d3.scaleLinear().domain(xDomain).nice().range([marginMain.left, mainWidth - marginMain.right]);
                const y = d3.scaleLinear().domain(yDomain).nice().range([mainHeight - marginMain.bottom, marginMain.top]);
                const xMedian = config._xMedian, yMedian = config._yMedian;

                 svgMain.append("text").attr("class", "plot-title").attr("x", mainWidth / 2).attr("y", marginMain.top - 90).text(config.title); // Adjusted Y
                 svgMain.append("g").attr("class", "x-axis axis").attr("transform", `translate(0,${mainHeight - marginMain.bottom})`).call(d3.axisBottom(x).ticks(7));
                 svgMain.append("text").attr("class", "x-label axis-label").attr("x", mainWidth / 2).attr("y", mainHeight - 20).text(config.xLabelFull || config.xLabel);
                 svgMain.append("g").attr("class", "y-axis axis").attr("transform", `translate(${marginMain.left},0)`).call(d3.axisLeft(y).ticks(7));
                 svgMain.append("text").attr("class", "y-label axis-label").attr("transform", "rotate(-90)").attr("x", -(marginMain.top + innerHeight / 2)).attr("y", marginMain.left - 60).text(config.yLabelFull || config.yLabel);
                 if (xMedian !== undefined && xMedian !== null && isFinite(x(xMedian))) svgMain.append("line").attr("class", "quadrant-line").attr("x1", x(xMedian)).attr("x2", x(xMedian)).attr("y1", marginMain.top).attr("y2", mainHeight - marginMain.bottom);
                 if (yMedian !== undefined && yMedian !== null && isFinite(y(yMedian))) svgMain.append("line").attr("class", "quadrant-line").attr("x1", marginMain.left).attr("x2", mainWidth - marginMain.right).attr("y1", y(yMedian)).attr("y2", y(yMedian));

                 const isMobileMain = window.innerWidth <= 600;
                 const mainOuterLabelPadding = isMobileMain ? 20 : 30;
                 const mainOuterLabelYOffset = isMobileMain ? -25 : -35;
                 const mainOuterLabelYOffsetBottom = isMobileMain ? 35 : 45;
                 if (config.quadLabels && xMedian !== undefined && yMedian !== undefined && xMedian !== null && yMedian !== null && isFinite(x(xMedian)) && isFinite(y(yMedian))) {
                     const mainLabelData = [
                         { quad: 'II', anchor: 'end', xPos: mainWidth - marginMain.right + mainOuterLabelPadding, yPos: marginMain.top + mainOuterLabelYOffset },
                         { quad: 'I', anchor: 'start', xPos: marginMain.left - mainOuterLabelPadding, yPos: marginMain.top + mainOuterLabelYOffset },
                         { quad: 'III', anchor: 'start', xPos: marginMain.left - mainOuterLabelPadding, yPos: mainHeight - marginMain.bottom + mainOuterLabelYOffsetBottom },
                         { quad: 'IV', anchor: 'end', xPos: mainWidth - marginMain.right + mainOuterLabelPadding, yPos: mainHeight - marginMain.bottom + mainOuterLabelYOffsetBottom }
                     ];
                     mainLabelData.forEach(lbl => {
                         const labelText = config.quadLabels[lbl.quad]; if (!labelText) return;
                         const lines = labelText.split('\n');
                         const textElement = svgMain.append("text").attr("class", "quadrant-label quadrant-label-outer").attr("x", lbl.xPos).attr("y", lbl.yPos).attr("text-anchor", lbl.anchor);
                         lines.forEach((line, i) => textElement.append("tspan").attr("x", lbl.xPos).attr("dy", i === 0 ? "0" : "1.1em").text(line));
                     });
                 }
                 const overlays = svgMain.selectAll(".quadrant-overlay").data(["I","II","III","IV"]);
                 overlays.enter().append("rect").attr("class","quadrant-overlay").merge(overlays).attr("opacity", 0).attr("pointer-events","none")
                    .each(function(q){
                        if (xMedian === undefined || yMedian === undefined || xMedian === null || yMedian === null || !isFinite(x(xMedian)) || !isFinite(y(yMedian))) return;
                        const isLeft = q==="I" || q==="III", isTop = q==="I" || q==="II";
                        const xPos = isLeft ? marginMain.left : x(xMedian);
                        const yPos = isTop ? marginMain.top : y(yMedian);
                        const width = Math.max(0, isLeft ? x(xMedian)-marginMain.left : mainWidth-marginMain.right-x(xMedian));
                        const height = Math.max(0, isTop ? y(yMedian)-marginMain.top : mainHeight-marginMain.bottom-y(yMedian));
                        if (isFinite(xPos) && isFinite(yPos) && isFinite(width) && width >= 0 && isFinite(height) && height >= 0) d3.select(this).attr("x", xPos).attr("y", yPos).attr("width", width).attr("height", height);
                        else d3.select(this).attr("width", 0).attr("height", 0);
                 });
                 mainCircles.transition("scatterPos").duration(1500).ease(d3.easeCubicInOut)
                    .attr("cx", d => { const xVal = d[config.xField]; return (xVal != null && !isNaN(xVal) && typeof xVal === 'number' && isFinite(x(xVal))) ? x(xVal) : -100; })
                    .attr("cy", d => { const yVal = d[config.yField]; return (yVal != null && !isNaN(yVal) && typeof yVal === 'number' && isFinite(y(yVal))) ? y(yVal) : -100; })
                    .attr("r", d => { const xVal = d[config.xField], yVal = d[config.yField]; return (xVal != null && !isNaN(xVal) && typeof xVal === 'number' && yVal != null && !isNaN(yVal) && typeof yVal === 'number') ? baseCircleDiameter * 1.1 : 0; })
                    .end().then(() => {
                         if (DEBUG_MODE) console.log("[toScatter] Scatter transition finished. Setting up IO.");
                         applyGlobalFilterAndSearch(); setupIntersectionObserver(mainScatterConfig);
                         isViewTransitioning = false;
                    }).catch(err => {
                         console.error("Scatter transition error:", err);
                         applyGlobalFilterAndSearch();
                         isViewTransitioning = false;
                    });
            }


            const steps = document.querySelectorAll("#scatter-steps .step");
            function setupIntersectionObserver(config) {
                window.IO?.disconnect(); observerInitialized = false;
                 if (!config || !config.xField || !config.yField) {
                     if (DEBUG_MODE) console.error("[IO Setup] Aborting: Invalid config provided for steps IO.", config);
                     return;
                 }
                if (DEBUG_MODE) console.log("[IO Steps] Setting up Intersection Observer for Steps with config:", config.id);
                window.IO = new IntersectionObserver(entries => {
                    const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);
                    if (currentView !== 'scatter' || mainChartOpacity < 0.1) {
                        if (DEBUG_MODE && currentView !== 'scatter') console.log("[IO Steps Callback] Aborted, not in scatter view or main chart faded.");
                        return;
                    }
                    const minVisibilityThreshold = 0.05;
                    const visibleSteps = entries.filter(entry => entry.isIntersecting && entry.intersectionRatio >= minVisibilityThreshold);
                    let highestVisibleStep = null;
                    if (visibleSteps.length > 0) {
                        visibleSteps.sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top);
                        highestVisibleStep = visibleSteps[0].target;
                    }
                    const nextActiveQuad = highestVisibleStep ? highestVisibleStep.dataset.quad : 'all';
                    if (nextActiveQuad !== activeQuad) {
                        if (DEBUG_MODE) console.log(`[IO Steps Callback] *** Changing highlight: ${activeQuad} -> ${nextActiveQuad} *** (Highest visible: ${highestVisibleStep ? highestVisibleStep.dataset.quad : 'None'})`);
                        activeQuad = nextActiveQuad; renderHighlight(activeQuad, config);
                    }
                }, { threshold: Array.from({ length: 21 }, (_, i) => i * 0.05) });
                steps.forEach(s => window.IO.observe(s));
                if (DEBUG_MODE) console.log("[IO Steps] Observer attached to steps.");
                 if (!observerInitialized) {
                      if (DEBUG_MODE) console.log("[IO Steps Initial Check] Scheduling...");
                      setTimeout(() => {
                           const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);
                         if (currentView !== 'scatter' || !config || !config.xField || !config.yField || mainChartOpacity < 0.1) {
                            if (DEBUG_MODE) console.log("[IO Steps Initial Check] Aborted, view/config/opacity changed or invalid for initial check.");
                            return;
                         }
                         if (DEBUG_MODE) console.log("[IO Steps Initial Check] Running...");
                         const minVisibilityThreshold = 0.05;
                         const currentVisibleSteps = [];
                         steps.forEach(step => {
                            const rect = step.getBoundingClientRect();
                            const isIntersecting = rect.top < window.innerHeight && rect.bottom > 0;
                            if (isIntersecting) {
                                const visibleHeight = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
                                const ratio = Math.max(0, Math.min(1, visibleHeight / rect.height));
                                if (ratio >= minVisibilityThreshold) currentVisibleSteps.push({ target: step, top: rect.top });
                            }
                         });
                         let initialHighestStep = null;
                         if (currentVisibleSteps.length > 0) {
                             currentVisibleSteps.sort((a, b) => a.top - b.top);
                             initialHighestStep = currentVisibleSteps[0].target;
                         }
                         const initialActiveQuad = initialHighestStep ? initialHighestStep.dataset.quad : 'all';
                         if (DEBUG_MODE) console.log(`[IO Steps Initial Check] Determined initial quad: ${initialActiveQuad}.`);
                         if (initialActiveQuad !== activeQuad) {
                              if (DEBUG_MODE) console.log(`[IO Steps Initial Check] *** Setting initial highlight: ${activeQuad} -> ${initialActiveQuad} ***`);
                              activeQuad = initialActiveQuad;
                         }
                         renderHighlight(activeQuad, config); observerInitialized = true;
                     }, 350);
                 }
             }

            function renderHighlight(quad, config) {
                if (currentView !== 'scatter' || !svgMain || !svgMain.node() || !config || !config.xField || !config.yField) {
                    if (DEBUG_MODE) console.warn(`[RenderHighlight] Aborting. View: ${currentView}, SVG exists: ${!!svgMain?.node()}, Config valid: ${!!(config && config.xField && config.yField)}`);
                    if (currentView !== 'scatter') activeQuad = 'all';
                    return;
                }
                 const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);
                 if (mainChartOpacity < 0.1) {
                     if (DEBUG_MODE) console.log("[RenderHighlight] Aborting, main chart faded.");
                      activeQuad = 'all';
                      svgMain.selectAll(".quadrant-overlay").transition("overlayFadeOut").duration(100).attr("opacity", 0);
                     return;
                 }
                if (DEBUG_MODE) console.log(`[RenderHighlight] Rendering for quad: ${quad} with config: ${config.id}`);
                svgMain.selectAll(".quadrant-overlay").filter(qData => qData).transition("overlayHighlight").duration(300)
                    .attr("opacity", qData => (quad === "all") ? 0 : (qData === quad ? 0.12 : 0));
                applyGlobalFilterAndSearch();
            }


            const chartWrapper = document.querySelector('.chart-wrapper');
            const scatterStepsSection = document.getElementById('scatter-steps');

            const processScroll = () => {
                if (isViewTransitioning) {
                    if (DEBUG_MODE) console.log("[Scroll Process] Skipped due to active view transition.");
                    return;
                }
                const y = window.scrollY;
                const wh = window.innerHeight;
                if (!chartWrapper || !scatterStepsSection) return;
                const wrapperRect = chartWrapper.getBoundingClientRect();
                const stepsRect = scatterStepsSection.getBoundingClientRect();
                const wrapperTopDoc = wrapperRect.top + window.scrollY;
                const stepsTopDoc = stepsRect.top + window.scrollY;
                const wrapperHeight = chartWrapper.offsetHeight;

                const mapStartTrigger = wrapperTopDoc + (wrapperHeight * 0.30) - wh;
                const scatterStartTrigger = stepsTopDoc - (wh * 0.50);

                if (DEBUG_MODE && Math.random() < 0.05) {
                     console.log(`[Scroll Debug] y:${y.toFixed(0)} | mapStart:${mapStartTrigger.toFixed(0)} | scatterStart:${scatterStartTrigger.toFixed(0)} | currentView:${currentView}`);
                }
                let targetView;
                if (y < mapStartTrigger) targetView = "sphere";
                else if (y >= mapStartTrigger && y < scatterStartTrigger) targetView = "map";
                else targetView = "scatter";

                if (targetView !== currentView && !isViewTransitioning) {
                    if (DEBUG_MODE) console.log(`[Scroll Trigger] Changing view from ${currentView} to ${targetView} (y=${y.toFixed(0)})`);
                    if (targetView === "sphere") toSphere();
                    else if (targetView === "map") toMap();
                    else if (targetView === "scatter") toScatter();
                }
                updateSearchControlsVisibility();
                const intro = document.getElementById("sphere-intro");
                if (intro) {
                    if ( (currentView !== 'sphere' || y >= 80 || isViewTransitioning) && !intro.classList.contains("hidden")) {
                        intro.classList.add("hidden");
                    } else if (currentView === 'sphere' && y < 80 && !isViewTransitioning && intro.classList.contains("hidden")) {
                        intro.classList.remove("hidden");
                    }
                }
            };
            const throttledScrollHandler = throttle(processScroll, SCROLL_THROTTLE_LIMIT);
            window.addEventListener("scroll", throttledScrollHandler, { passive: true });


            const chartContainer = document.getElementById("chart-container");
            const staticPlotsSection = document.getElementById("flourish-block");
             if (chartContainer && staticPlotsSection) {
                new IntersectionObserver(
                    entries => {
                        const staticPlotsEntry = entries[0];
                        const fadeStartRatio = 0.05, fadeEndRatio = 0.25;
                        let opacity = 1;
                        const oldStaticPlotsVisible = staticPlotsVisible;
                        if (staticPlotsEntry.isIntersecting) {
                            staticPlotsVisible = true;
                            const ratio = staticPlotsEntry.intersectionRatio;
                            if (ratio >= fadeStartRatio) opacity = 1 - Math.min(1, Math.max(0, (ratio - fadeStartRatio) / (fadeEndRatio - fadeStartRatio)));
                        } else if (staticPlotsEntry.boundingClientRect.top < 0) {
                            opacity = 0; staticPlotsVisible = true;
                        } else { opacity = 1; staticPlotsVisible = false; }

                        chartContainer.style.opacity = opacity;
                        chartContainer.style.pointerEvents = opacity < 0.5 ? "none" : "auto";
                        updateSearchControlsVisibility();
                        const intro = document.getElementById("sphere-intro");
                        if (intro && opacity < 0.8) intro.classList.add("hidden");
                         if (staticPlotsVisible !== oldStaticPlotsVisible || Math.abs(parseFloat(chartContainer.style.opacity) - opacity) > 0.01) {
                             if (DEBUG_MODE && staticPlotsVisible !== oldStaticPlotsVisible) console.log(`[Flourish IO] staticPlotsVisible changed from ${oldStaticPlotsVisible} to ${staticPlotsVisible}. Opacity: ${opacity.toFixed(2)}`);
                             applyGlobalFilterAndSearch();
                         }
                        if (opacity < 0.1 && window.IO) {
                             if (DEBUG_MODE) console.log("[Flourish IO] Disconnecting Step IO due to main chart fade");
                             window.IO.disconnect(); activeQuad = 'all'; observerInitialized = false; renderHighlight('all', mainScatterConfig);
                        } else if (opacity >= 0.1 && currentView === 'scatter' && !observerInitialized && window.IO && mainScatterConfig) {
                             if (DEBUG_MODE) console.log("[Flourish IO] Re-enabling Step IO as main chart became visible");
                              setupIntersectionObserver(mainScatterConfig);
                        }
                    }, { threshold: Array.from({ length: 21 }, (_, i) => i * 0.05) }
                ).observe(staticPlotsSection);
             }

            const staticPlotContainers = document.querySelectorAll('.scatter-plot-container');
            if (staticPlotContainers.length > 0 && staticConfigs) {
                const staticPlotObserver = new IntersectionObserver(entries => {
                    let newActiveStaticPlotConfig = activeStaticPlotConfig;
                    if (!staticPlotsVisible) {
                         if (activeStaticPlotConfig !== null) {
                             if (DEBUG_MODE) console.log("[Static Plot IO] Static plots section no longer primary for context, resetting activeStaticPlotConfig.");
                             newActiveStaticPlotConfig = null;
                         }
                    } else {
                        let mostVisibleStaticPlot = null, maxRatio = -1;
                        entries.forEach(entry => {
                            if (entry.isIntersecting && entry.intersectionRatio > maxRatio) {
                                maxRatio = entry.intersectionRatio; mostVisibleStaticPlot = entry.target;
                            }
                        });
                        if (mostVisibleStaticPlot) {
                            const chartId = mostVisibleStaticPlot.dataset.chartId;
                            if (chartId && staticConfigs[chartId]) newActiveStaticPlotConfig = staticConfigs[chartId];
                        } else newActiveStaticPlotConfig = null;
                    }
                    if (newActiveStaticPlotConfig?.id !== activeStaticPlotConfig?.id || (newActiveStaticPlotConfig === null && activeStaticPlotConfig !== null) || (newActiveStaticPlotConfig !== null && activeStaticPlotConfig === null)) {
                        if (DEBUG_MODE) console.log(`[Static Plot IO] Active static config changing. Old: ${activeStaticPlotConfig?.id}, New: ${newActiveStaticPlotConfig?.id}. staticPlotsVisible: ${staticPlotsVisible}`);
                        activeStaticPlotConfig = newActiveStaticPlotConfig; applyGlobalFilterAndSearch();
                    }
                }, { threshold: Array.from({ length: 11 }, (_, i) => i * 0.1), rootMargin: "-10% 0px -30% 0px" });
                staticPlotContainers.forEach(container => staticPlotObserver.observe(container));
                 if (DEBUG_MODE) console.log("[Static Plot IO] Observer attached to static plot containers.");
            }

            const intro = document.getElementById("sphere-intro");
            const introOk = document.getElementById("intro-ok");
            if (intro && introOk) {
                function hideIntro() { intro.classList.add("hidden"); }
                introOk.addEventListener("click", hideIntro);
            }

            setTimeout(() => {
                 const y = window.scrollY; const wh = window.innerHeight;
                 if (!chartWrapper || !scatterStepsSection) { console.error("Initial view check failed: Elements not found."); toSphere(); applyGlobalFilterAndSearch(); updateSearchControlsVisibility(); return; }
                 const wrapperRect = chartWrapper.getBoundingClientRect(); const stepsRect = scatterStepsSection.getBoundingClientRect();
                 const wrapperTop = wrapperRect.top + y; const stepsTop = stepsRect.top + y;
                 const wrapperHeight = chartWrapper.offsetHeight;
                 const mapStartPoint = wrapperTop + wrapperHeight * 0.30 - wh; // Adjusted trigger
                 const scatterStartPoint = stepsTop - wh * 0.50; // Adjusted trigger

                 let initialViewFunction = toSphere;
                 if (y >= mapStartPoint && y < scatterStartPoint) initialViewFunction = toMap;
                 else if (y >= scatterStartPoint) initialViewFunction = toScatter;

                 if (DEBUG_MODE) console.log(`[Initial Load] Setting initial view: ${initialViewFunction.name} (y=${y.toFixed(0)}, mapStart=${mapStartPoint.toFixed(0)}, scatterStart=${scatterStartPoint.toFixed(0)})`);
                 initialViewFunction();
                 setTimeout(updateSearchControlsVisibility, 200);
                 setTimeout(applyGlobalFilterAndSearch, 250);
                 const introElem = document.getElementById("sphere-intro");
                 if (introElem) {
                     if (y < 80 && currentView === 'sphere' && !isViewTransitioning) introElem.classList.remove("hidden");
                     else introElem.classList.add("hidden");
                 }
                 if (DEBUG_MODE) console.log("[Initial Load] Initial view determined:", currentView);
            }, 150);

        }).catch(error => {
            console.error("Error loading or processing data:", error);
            document.body.innerHTML = `<div style="color: red; padding: 50px; text-align: center; font-size: 1.2em;">A apƒÉrut o eroare la √ÆncƒÉrcarea datelor (${error.message}). VƒÉ rugƒÉm re√ÆncƒÉrca»õi pagina.</div>`;
        });

    </script>
    </body>
    </html>
