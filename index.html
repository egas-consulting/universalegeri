<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Universul Rom√¢nesc</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        *, *:before, *:after { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            overflow-x: hidden;
            background-color: #000;
            color: #fff; 
        }

        .headline-wrapper {
            position: relative;
            z-index: 3;
            text-align: center;
            padding-top: 8vh;
            padding-bottom: 4vh;
            color: white;
        }

        .cosmic-supratitle {
            font-family: 'Roboto', sans-serif;
            font-size: 1.6em;
            font-weight: 300;
            color: white;
            text-shadow: 0 0 6px #88b5ff, 0 0 10px #5573d6;
            margin-bottom: 10px;
        }

        .cosmic-title {
            font-family: 'Roboto', sans-serif;
            font-size: 1.8em;
            font-weight: 400;
            padding: 0 6vw;
            line-height: 1.4;
            color: white;
            text-shadow: 0 0 6px #88b5ff, 0 0 12px #335bc4;
        }

        .text-container {
            max-width: 600px;
            margin: 0 auto;
            padding: 0 5vw;
            padding-top: 5vh;
            color: #fff;
        }

        p {
            text-align: center;
            font-size: 1em;
            margin: 1em 0;
        }

       
        .chart-wrapper {
            position: relative;
            
            height: 250vh; 
            margin-bottom: 5vh;
        }

        .chart-container {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100vh;
            background: radial-gradient(ellipse at center, #0b1f4c 0%, #000000 100%);
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.6s ease;
        }

        
        .svg-inner { 
            width: 100%;
            max-width: 1000px;
            position: relative;
        }
        svg { 
            width: 100%;
            height: auto;
            display: block;
            background-color: transparent;
        }

       
        .tooltip {
            position: absolute;
            background: rgba(255,255,255,0.95);
            border: 1px solid #aaa;
            padding: 0.85em 1em;
            font-size: 0.9em;
            pointer-events: none;
            opacity: 0;
            z-index: 10; /* Below search controls */
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            border-radius: 4px;
            max-width: 90vw;
            min-width: 80px;
            color: #333;
            transition: opacity 0.2s ease;
        }

        .top-spacer { height: 15vh; }

        
        #search-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 11;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            display: none;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            max-width: 90vw;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
        }
         #search-container.visible {
            display: block;
            opacity: 1;
            pointer-events: auto;
         }
        #search-input, #clear-search, #winner-filter {
            padding: 8px 12px;
            font-size: 0.9em;
            margin: 4px;
            border: 1px solid #555;
            border-radius: 5px;
            background-color: #333;
            color: #eee;
        }
        #search-input::placeholder { color: #aaa; }
        #clear-search {
            padding: 8px 10px;
            margin-left: 6px;
            cursor: pointer;
            background-color: #555;
            border-color: #777;
        }
         #clear-search:hover { background-color: #666; }
        #winner-filter {
            cursor: pointer;
            background-color: #333;
             border-color: #555;
             color: #eee;
             flex-grow: 1;
             min-width: 150px;
        }
        #search-container > div {
             display: flex;
             align-items: center;
             gap: 5px;
             flex-wrap: wrap;
         }
         #search-container > div:last-child { margin-top: 8px; }
         #search-container label {
             color: white;
             margin-right: 6px;
             font-size: 0.9em;
             white-space: nowrap;
         }

        
        #scatter-steps {
            position: relative; 
            z-index: 5;
            
             margin-top: 100vh; 
             padding-top: 1vh; 
             padding-bottom: 5vh; 
        }
        .step {
            position: relative;
            max-width: min(90vw, 340px);
           
            margin: 70vh auto; 
            padding: 1.25em 1.5em;
            background: rgba(255,255,255,0.92);
            border-radius: 8px;
            font-size: .95em;
            line-height: 1.35;
            box-shadow: 0 2px 10px rgba(0,0,0,.25);
            color: #333;
        }
        
         .step:first-child { margin-top: 40vh; } 
         .step:last-child { margin-bottom: 50vh; } 

        
        #sphere-intro{
            position:fixed; inset:0; z-index:6; display:flex;
            flex-direction:column; justify-content:center; align-items:center;
            text-align:center; gap:1.5rem; font-family:'Roboto',sans-serif;
            background:rgba(0,0,0,0.88); color:#fff; opacity:1;
            pointer-events:auto; transition:opacity .6s ease;
        }
        #sphere-intro h2{font-size:2rem; margin:0;}
        #sphere-intro p {font-size:1rem; line-height:1.4; margin:0;}
        #sphere-intro button{
            padding:.6rem 1.4rem; font-size:1rem; border:none; border-radius:6px;
            background:#88b5ff; color:#000; cursor:pointer;
        }
        #sphere-intro.hidden{ opacity:0; pointer-events:none; }

        
        #flourish-block{
            padding: 10vh 0 6vh;
            background: #000;
            text-align:center;
            position:relative;
            z-index:3;
        }
        .scatter-plot-container {
            max-width: 950px;
            width: 92%;
            margin: 10vh auto;
            background-color: rgba(11, 31, 76, 0.2);
            border-radius: 8px;
            padding: 25px 15px 15px 15px;
            box-shadow: 0 0 15px rgba(136, 181, 255, 0.15);
        }
        .scatter-explainer {
            font-size: 0.9em; color: #ccc; margin-top: 10px;
            max-width: 850px; margin-left: auto; margin-right: auto;
            padding: 0 15px; line-height: 1.4; text-align: center;
        }

        
        .axis path, .axis line { stroke: #aaa; stroke-width: 0.5; shape-rendering: crispEdges; }
        .axis text { fill: #ccc; font-weight: 300; font-size: 10px; }
        .axis-label { fill: #ddd; font-size: 0.85em; text-anchor: middle; }
        .plot-title { fill: #fff; font-size: 1.25em; font-weight: 600; text-anchor: middle; }
        .map-title { fill: #fff; font-size: 1.3em; font-weight: 600; text-anchor: middle; }
        .map-subtitle { fill: #ccc; font-size: 0.9em; text-anchor: middle; }
        .quadrant-line { stroke: #ffffff; stroke-dasharray: 3 3; stroke-width: 1.5px; opacity: 0.8; }
        .quadrant-label { fill: #ffffff; font-size: 0.8em; font-weight: 400; opacity: 0.9; }
         .quadrant-overlay {
             fill: #ffffff;
             opacity: 0;
             pointer-events: none;
             transition: opacity 0.3s ease;
         }

        
        @media (max-width: 600px) {
             #search-container {
                 top: 10px; left: 50%; right: auto; transform: translateX(-50%);
                 width: 90vw; max-width: 350px; padding: 8px 10px;
             }
             #search-container > div {
                 flex-direction: column; align-items: stretch; width: 100%; gap: 6px;
             }
             #search-input, #clear-search, #winner-filter, #search-container label {
                 font-size: 0.85em; width: 100%; margin: 0; box-sizing: border-box;
             }
             #search-input { padding: 7px 10px; }
              #clear-search { padding: 7px 10px; margin-top: 4px; }
             #search-container label { margin-bottom: 4px; text-align: center; margin-right: 0; }
             #winner-filter { padding: 7px 10px; min-width: 0; }
             #search-container > div:last-child { margin-top: 10px; }

            .scatter-plot-container {
                width: 98%; padding: 10px 5px 5px 5px; margin: 5vh auto; box-shadow: none;
            }
            .scatter-explainer { padding: 0 5px; font-size: 0.8em; margin-top: 8px; line-height: 1.3; }
             .plot-title { font-size: 1.1em; }
             .axis-label { font-size: 0.75em; }
             
             .quadrant-label {
                 font-size: 0.65em; 
             }
            
             .axis text { font-size: 9.5px; }

            
            .step { margin: 60vh auto; } 
            .step:first-child { margin-top: 30vh; }
            .step:last-child { margin-bottom: 40vh; }

            .map-title { font-size: 1.15em; }
            .map-subtitle { font-size: 0.85em; }
            .cosmic-title { font-size: 1.5em; }
            .cosmic-supratitle { font-size: 1.3em; }
        }

       
        body { min-height: 500vh; } 
        html,body{ overscroll-behavior: none; }

    </style>
</head>
<body>
    <div class="headline-wrapper">
        <div class="cosmic-supratitle">Universul Rom√¢nesc</div>
        <h1 class="cosmic-title">
            C√¢t de mult impacteazƒÉ statutul socio-economic al localitƒÉ»õilor rezultatele la preziden»õiale
        </h1>
    </div>
    <div class="text-container">
        <p>
            Am corelat <strong>rezultatele ob»õinute</strong> »ôi <strong>prezen»õa</strong> √Æn alegerile preziden»õiale din 2024.<br>
            <strong>Scroll</strong> pentru a explora vizualizarea interactivƒÉ principalƒÉ. Mai jos gƒÉsi»õi analize detaliate pe indicatori specifici.<br>
            <i>Filtrele »ôi cƒÉutarea (sus dreapta) se aplicƒÉ tuturor graficelor.</i>
        </p>
    </div>

    <div id="search-container">
        <div>
            <input id="search-input" type="text" placeholder="CautƒÉ localitate..." list="localitati-list">
            <button id="clear-search" title="ReseteazƒÉ cƒÉutarea">Reset</button>
            <datalist id="localitati-list"></datalist>
        </div>
        <div >
            <label for="winner-filter">FiltreazƒÉ dupƒÉ c√¢»ôtigƒÉtor:</label>
            <select id="winner-filter">
                <option value="all">To»õi</option>
                <option value="ION-MARCEL CIOLACU">ION-MARCEL CIOLACU</option>
                <option value="NICOLAE-IONEL CIUCƒÇ">NICOLAE-IONEL CIUCƒÇ</option>
                <option value="ELENA-VALERICA LASCONI">ELENA-VALERICA LASCONI</option>
                <option value="GEORGE-NICOLAE SIMION">GEORGE-NICOLAE SIMION</option>
                <option value="HUNOR KELEMEN">HUNOR KELEMEN</option>
                <option value="CƒÇLIN GEORGESCU">CƒÇLIN GEORGESCU</option>
            </select>
        </div>
    </div>

    <div class="top-spacer"></div>

    <div class="chart-wrapper">
        <div class="chart-container" id="chart-container">
            <div class="svg-inner">
                <svg id="viz" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet"></svg>
            </div>
        </div>
    </div>

    <div id="sphere-intro">
        <h2>Universul Rom√¢nesc</h2>
        <p>Am analizat rezultatele din primul tur al alegerilor preziden»õiale din 2024<br>
            »ôi le-am corelat cu 8 indicatori economici »ôi sociali relevan»õi, <br>
            pentru a √Æn»õelege cum influen»õeazƒÉ ace»ôtia op»õiunile electorale.<br>
            Fiecare cerc din grafic este interactiv. Scroll pentru a explora toate sec»õiunile.
        </p>
        <button id="intro-ok">√éncepe</button>
    </div>

    <section id="scatter-steps">
        <div class="step" data-quad="I">
            <p><strong>Cum este √ÆmpƒÉr»õit graficul</strong><br>
                Fiecare grafic este √ÆmpƒÉr»õit √Æn patru pƒÉr»õi, folosind valorile mediane de pe fiecare axƒÉ pentru a identifica tipare clare √Æntre localitƒÉ»õi</p>
        </div>
        <div class="step" data-quad="II">
            <p><strong>Cum interpretezi cadranele</strong><br>
                Astfel, fiecare axƒÉ creeazƒÉ o linie de referin»õƒÉ echitabilƒÉ, iar cele patru cadrane aratƒÉ combina»õii diferite de situa»õii (de exemplu: localitƒÉ»õi cu valori mari pe ambele axe, sau localitƒÉ»õi cu o valoare mare pe una »ôi micƒÉ pe cealaltƒÉ).</p>
        </div>
        <div class="step" data-quad="III">
            <p><strong>De ce sunt utile cadranele</strong><br>
                √én loc sƒÉ analizƒÉm fiecare indicator separat, vedem rapid cum se leagƒÉ √Æntre ele douƒÉ variabile importante. Astfel, putem √Æn»õelege mai bine rela»õia dintre factori economici, sociali sau politici »ôi op»õiunile electorale sau dezvoltarea localƒÉ.</p>
        </div>
        <div class="step" data-quad="IV">
            <p><strong>CautƒÉ localitatea sau filtreazƒÉ informa»õia</strong><br>
                Graficul este interactiv: po»õi plasa cursorul pe un cerc pentru a vedea detalii, cƒÉuta direct o localitate sau filtra localitƒÉ»õile dupƒÉ candidatul c√¢»ôtigƒÉtor.</p>
        </div>
         <div class="step" data-quad="all"> <!-- This step helps reset when scrolling past the last specific quadrant step -->
             <p><strong>Scroll √Æn continuare pentru a explora graficele</strong></p>
         </div>
    </section>

    <section id="flourish-block">
        <h2 class="cosmic-title" style="margin-bottom: 5vh; padding-top: 5vh;">Analiza detaliatƒÉ pe indicatori statici</h2>
        <div id="scatter-container-1" class="scatter-plot-container">
            <svg id="scatter-viz-1" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce poate spune despre o comunitate combina»õia dintre v√¢rsta medie a popula»õiei »ôi suprafa»õa locuibilƒÉ disponibilƒÉ pe persoanƒÉ?</strong> <br> Prin aceastƒÉ distribu»õie √Æn scatter plot, observƒÉm contraste clare √Æntre regiuni: localitƒÉ»õile din dreapta sus, cu v√¢rstƒÉ medie ridicatƒÉ »ôi spa»õiu generos, sunt adesea foste ora»ôe istorice sau zone de vacan»õƒÉ unde popula»õia t√¢nƒÉrƒÉ a migrat. La polul opus, ora»ôele mici sau cartierele vechi, unde popula»õia √ÆmbƒÉtr√¢nitƒÉ locuie»ôte √Æn spa»õii modeste, se regƒÉsesc √Æn partea de jos a graficului. Acela»ôi tipar apare »ôi √Æn zonele rurale sƒÉrace.

                √én st√¢nga sus, gƒÉsim suburbii »ôi localitƒÉ»õi periurbane prospere, unde familiile tinere locuiesc √Æn case mari, √Æn timp ce st√¢nga jos reflectƒÉ ora»ôele mari aglomerate, dominate de tineri care trƒÉiesc √Æn locuin»õe mai mici.

                AceastƒÉ combina»õie de indicatori deschide o fereastrƒÉ spre √Æn»õelegerea dinamicii sociale, economice »ôi istorice a comunitƒÉ»õilor.</p>
        </div>
        <div id="scatter-container-2" class="scatter-plot-container">
            <svg id="scatter-viz-2" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce ne aratƒÉ rela»õia dintre plecƒÉrile cu domiciliul »ôi »ôomajul local?</strong><br>PlecƒÉrile cu domiciliul raportate la popula»õie sunt un indicator direct al mobilitƒÉ»õii »ôi al nivelului de atractivitate al unei comunitƒÉ»õi. Ponderea »ôomerilor reflectƒÉ presiunea economicƒÉ localƒÉ »ôi oportunitƒÉ»õile de muncƒÉ disponibile.

                Zonele cu rate mari de plecare »ôi »ôomaj ridicat indicƒÉ adesea o spiralƒÉ a declinului: lipsƒÉ de oportunitƒÉ»õi, migra»õie economicƒÉ, depopulare acceleratƒÉ. √én schimb, comunitƒÉ»õile unde plecƒÉrile sunt reduse »ôi »ôomajul scƒÉzut demonstreazƒÉ stabilitate »ôi capacitatea de a-»ôi pƒÉstra popula»õia activƒÉ.

                AceastƒÉ combina»õie de indicatori ajutƒÉ la identificarea zonelor vulnerabile, dar »ôi a celor care reu»ôesc sƒÉ reziste presiunilor demografice »ôi economice.</p>
        </div>
        <div id="scatter-container-3" class="scatter-plot-container">
            <svg id="scatter-viz-3" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce poate spune rela»õia dintre numƒÉrul de salaria»õi »ôi veniturile fiscale locale?</strong><br>NumƒÉrul de salaria»õi raportat la popula»õie indicƒÉ dinamismul economic al unei comunitƒÉ»õi: c√¢»õi dintre locuitori contribuie activ la economie. Cota de impozit pe cap de locuitor aratƒÉ c√¢t de mult reu»ôe»ôte administra»õia localƒÉ sƒÉ colecteze din impozitele locale pe venituri »ôi proprietƒÉ»õi.

                Zonele cu mul»õi salaria»õi »ôi cote fiscale mari per locuitor pot semnala comunitƒÉ»õi prospere, cu economie diversificatƒÉ »ôi administra»õie performantƒÉ. √én schimb, zonele cu pu»õini salaria»õi »ôi venituri fiscale scƒÉzute indicƒÉ adesea probleme structurale ‚Äì lipsa locurilor de muncƒÉ, migra»õie, economie informalƒÉ sau o administra»õie slabƒÉ.

                AceastƒÉ combina»õie de indicatori surprinde echilibrul dintre for»õa de muncƒÉ activƒÉ »ôi capacitatea realƒÉ a comunitƒÉ»õilor de a se sus»õine financiar.</p>
        </div>
        <div id="scatter-container-4" class="scatter-plot-container">
            <svg id="scatter-viz-4" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce poate spune rela»õia dintre fondurile europene atrase pe cap de locuitor »ôi numƒÉrul de pacien»õi care revin unui medic?</strong><br>AceastƒÉ combina»õie de indicatori oferƒÉ o perspectivƒÉ asupra modului √Æn care investi»õiile publice influen»õeazƒÉ accesul la servicii medicale. Fondurile europene atrase nu sunt direc»õionate exclusiv cƒÉtre sƒÉnƒÉtate, √ÆnsƒÉ dezvoltarea infrastructurii √Æn ansamblu ‚Äî drumuri mai bune, servicii publice modernizate, condi»õii de trai mai atractive ‚Äî poate contribui la stabilizarea sau atragerea de profesioni»ôti, inclusiv √Æn domeniul medical. AceastƒÉ combina»õie de indicatori oferƒÉ o perspectivƒÉ asupra modului √Æn care investi»õiile publice influen»õeazƒÉ accesul la servicii medicale. Fondurile europene atrase nu sunt direc»õionate exclusiv cƒÉtre sƒÉnƒÉtate, √ÆnsƒÉ dezvoltarea infrastructurii √Æn ansamblu ‚Äî drumuri mai bune, servicii publice modernizate, condi»õii de trai mai atractive ‚Äî poate contribui la stabilizarea sau atragerea de profesioni»ôti, inclusiv √Æn domeniul medical.</p>
        </div>
    </section>

    <div class="tooltip" id="tooltip"></div>

    <script>
        
        let allDataGlobal;
        const mainWidth = 1000, mainHeight = 700;
        const plotWidth = 900, plotHeight = 550;
        const margin = { top: 60, right: 40, bottom: 50, left: 60 };
        const marginMain = { top: 50, right: 60, bottom: 60, left: 80 };

        const baseCircleDiameter = window.innerWidth <= 600 ? 9 : window.innerWidth > 800 ? 4 : 3.5;

        const svgMain = d3.select("#viz");
        const tooltip = d3.select("#tooltip");
        const chartMain = svgMain.append("g").attr("id", "chartGroup");
        const searchEl = d3.select("#search-container");

        const winnerColors = {
            "ION-MARCEL CIOLACU": "#FF2A1F", "NICOLAE-IONEL CIUCƒÇ": "#00B7FF",
            "ELENA-VALERICA LASCONI": "#D066F2", "GEORGE-NICOLAE SIMION": "#FFB623",
            "HUNOR KELEMEN": "#36FC00", "CƒÇLIN GEORGESCU": "#865750"
        };
        const colorScale = d3.scaleOrdinal(Object.keys(winnerColors), Object.values(winnerColors));

        let currentView = "sphere"; 
        let currentFilter = "all";
        let mainCircles;
        let staticCircles = [];
        let staticConfigs = {};
        let activeQuad = "all"; 
        let mainScatterConfig = {}; 
        let staticPlotsVisible = false;
        let observerInitialized = false; 

        
        const normalize = str => (str || "").toString().normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().trim();

        
        function showSearchControls() { searchEl.classed("visible", true); }
        function hideSearchControls() { searchEl.classed("visible", false); }
        function updateSearchControlsVisibility() {
            if ((currentView === 'map' || currentView === 'scatter') || staticPlotsVisible) {
                showSearchControls();
            } else {
                hideSearchControls();
            }
        }

        
        function basicTooltip(d) {
            return `<strong>${d.jud}</strong><br/>${d.uat}<br/>C√¢»ôtigƒÉtor: ${d.Castigator}<br/>Procent: ${d["Procent castigator"]}%<br/>Prezen»õa: ${d.Prezenta}%`;
         }
        function scatterTooltip(d, config) {
            const xValue = d[config.xField] !== undefined && d[config.xField] !== null ? d[config.xField].toFixed(config.xDecimals ?? 2) : 'N/A';
            const yValue = d[config.yField] !== undefined && d[config.yField] !== null ? d[config.yField].toFixed(config.yDecimals ?? 2) : 'N/A';
            return `<strong>${d.jud}</strong><br/>${d.uat}<br/>${config.xLabel}: ${xValue}${config.xUnit ?? ''}<br/>${config.yLabel}: ${yValue}${config.yUnit ?? ''}<br/>C√¢»ôtigƒÉtor: ${d.Castigator}<br/>Procent: ${d["Procent castigator"]}%<br/>Prezen»õa: ${d.Prezenta}%`;
         }
         function updateTooltipPosition(event) {
            const tRect = tooltip.node().getBoundingClientRect();
            let left = event.pageX + 10, top = event.pageY - 15;
            const margin = 10;
            if (left + tRect.width > window.innerWidth - margin) left = event.pageX - tRect.width - 10;
            if (top + tRect.height > window.innerHeight - margin) top = event.pageY - tRect.height - 5;
            if (top < margin) top = margin;
            if (left < margin) left = margin;
            tooltip.style("left", left + "px").style("top", top + "px");
         }

        
        function createSpherePositions(data, radius = 250){
            data.forEach((d,i) => {
                const phi = Math.acos(-1 + (2 * i) / data.length);
                const theta = Math.sqrt(data.length * Math.PI) * phi;
                d.sphere_x = radius * Math.sin(phi) * Math.cos(theta);
                d.sphere_y = radius * Math.sin(phi) * Math.sin(theta);
                d.sphere_z = radius * Math.cos(phi);
            });
        }
        let rotationAngle = 0;
        const sphereAnimation = anime({
            targets: { angle: 0 }, angle: 2 * Math.PI, duration: 35000, easing: 'linear',
            loop: true, autoplay: false,
            update: anim => {
                rotationAngle = anim.animations[0].currentValue;
                if (currentView === "sphere") updateSphereVisuals();
            }
        });
        function updateSphereVisuals() {
            const f = 400, cx = mainWidth / 2, cy = mainHeight / 2;
            if (!mainCircles) return;
            mainCircles.each(function(d) {
                const xRot = d.sphere_x * Math.cos(rotationAngle) - d.sphere_z * Math.sin(rotationAngle);
                const zRot = d.sphere_x * Math.sin(rotationAngle) + d.sphere_z * Math.cos(rotationAngle);
                const scale = f / (f + zRot + 1e-6);
                d.display_x = cx + xRot * scale;
                d.display_y = cy + d.sphere_y * scale;
                d.base_sphere_r = Math.max(1, baseCircleDiameter * scale);
                d.display_opacity_z = Math.max(0.1, Math.min(1, (f - zRot) / (f * 1.5)));
            });
            applyGlobalFilterAndSearch();
        }

        
        function isPointInQuad(d, config, quad) {
            if (!config || !config.xField || !config.yField || !allDataGlobal) return false;
            const xMedian = config._xMedian ?? (config._xMedian = d3.median(allDataGlobal, dataPoint => dataPoint[config.xField]));
            const yMedian = config._yMedian ?? (config._yMedian = d3.median(allDataGlobal, dataPoint => dataPoint[config.yField]));
            if (xMedian === undefined || yMedian === undefined || xMedian === null || yMedian === null) return false;
            const xVal = d[config.xField], yVal = d[config.yField];
            if (xVal === undefined || yVal === undefined || xVal === null || yVal === null) return false;
            let pointQuad = "";
            if (xVal <= xMedian && yVal >= yMedian) pointQuad = "I";
            else if (xVal > xMedian && yVal >= yMedian) pointQuad = "II";
            else if (xVal <= xMedian && yVal < yMedian) pointQuad = "III";
            else if (xVal > xMedian && yVal < yMedian) pointQuad = "IV";
            return pointQuad === quad;
         }

        
        function applyGlobalFilterAndSearch() {
            const searchTerm = normalize(d3.select("#search-input").property("value"));
            const isSearching = searchTerm.length > 0;
            const selectedWinner = d3.select("#winner-filter").property("value");
            currentFilter = selectedWinner;

            let areaScale;
            if (allDataGlobal) {
                const extent = d3.extent(allDataGlobal, d => d["Procent castigator"]);
                if (extent[0] !== undefined && extent[1] !== undefined) {
                    areaScale = d3.scaleSqrt().domain(extent).range([baseCircleDiameter * 0.8, baseCircleDiameter * 2.2]);
                }
            }

            d3.selectAll(".data-circle").each(function(d) {
                if (isSearching && normalize(d.uat) === searchTerm) d3.select(this).raise();
            });

            d3.selectAll(".data-circle")
                .transition("filterSearch").duration(350)
                .attr("opacity", function(d) {
                    const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                    const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                    if (!isWinnerMatch || !isSearchMatch) return 0.08;

                    let baseOpacity = 1.0;
                    const isMain = d3.select(this).classed('main-circle');
                    const isStatic = d3.select(this).classed('static-circle');

                    if (isStatic) { baseOpacity = 0.75; }
                    else if (isMain) {
                        if (currentView === 'sphere') { baseOpacity = d.display_opacity_z ?? 1.0; }
                        else if (currentView === 'map') { baseOpacity = 0.8; }
                        else if (currentView === 'scatter') {
                            const isQuadActive = activeQuad !== 'all';
                            const config = mainScatterConfig; // Use main config
                            const inActiveQuad = isQuadActive && isPointInQuad(d, config, activeQuad);
                            const xVal = d[config.xField], yVal = d[config.yField];
                            const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                            // Dim if a quad is active, the point has data, BUT it's not in the active quad
                            if (isQuadActive && hasValidScatterData && !inActiveQuad) baseOpacity = 0.05;
                            else baseOpacity = 0.8; // Default scatter opacity
                        }
                    }
                    if (isSearching && !exactSearchMatch && isWinnerMatch && isSearchMatch) baseOpacity *= 0.6;
                    if (exactSearchMatch) baseOpacity = isStatic ? 0.9 : 1.0;
                    return Math.max(0.08, baseOpacity);
                })
                .attr("stroke", function(d) {
                    const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                    const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                    if (!isWinnerMatch || !isSearchMatch) return "none";
                    if (exactSearchMatch) return "#FFFFFF";
                    if (currentFilter !== "all" && isWinnerMatch) return "#FFFFFF";
                    return "none";
                })
                .attr("stroke-width", function(d) {
                     const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                     const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                     if (!isWinnerMatch || !isSearchMatch) return 0;
                     const isMain = d3.select(this).classed('main-circle');
                     if (exactSearchMatch) return isMain ? 3 : 2.5;
                     if (currentFilter !== "all" && isWinnerMatch) return 1;
                     return 0;
                 })
                 .attr("cx", function(d) {
                    if (currentView === 'sphere' && d3.select(this).classed('main-circle')) return d.display_x;
                    return d3.select(this).attr("cx");
                 })
                 .attr("cy", function(d) {
                    if (currentView === 'sphere' && d3.select(this).classed('main-circle')) return d.display_y;
                    return d3.select(this).attr("cy");
                 })
                 .attr("r", function(d) {
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                     const boostFactor = 1.8;
                     const isMain = d3.select(this).classed('main-circle');
                     let baseRadius = 0;
                     if (isMain) {
                         if (currentView === 'sphere') { baseRadius = d.base_sphere_r ?? 0; }
                         else if (currentView === 'map' && areaScale) { baseRadius = (d.Lat && d.Long) ? areaScale(d["Procent castigator"]) : 0; }
                         else if (currentView === 'scatter') {
                             const config = mainScatterConfig;
                             const xVal = d[config.xField], yVal = d[config.yField];
                             baseRadius = (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 1.1 : 0;
                         }
                     } else {
                          const parentSvgId = d3.select(this.ownerSVGElement).attr('id');
                          const config = staticConfigs[parentSvgId];
                          if (config) {
                              const xVal = d[config.xField], yVal = d[config.yField];
                              baseRadius = (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 0.75 : 0;
                          } else { baseRadius = 0; }
                     }
                     baseRadius = (typeof baseRadius === 'number' && !isNaN(baseRadius)) ? baseRadius : 0;
                     return (exactSearchMatch && baseRadius > 0) ? baseRadius * boostFactor : baseRadius;
                 });
         }

        
        function createScatterPlot(containerSelector, data, config) {
             const svg = d3.select(containerSelector);
             const svgId = svg.attr('id');
             staticConfigs[svgId] = config;
             config._xMedian = d3.median(data, d => d[config.xField]);
             config._yMedian = d3.median(data, d => d[config.yField]);
             svg.selectAll("*").remove();
             const plotGroup = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
             const innerWidth = plotWidth - margin.left - margin.right;
             const innerHeight = plotHeight - margin.top - margin.bottom;
             const xExtent = d3.extent(data, d => d[config.xField]);
             const yExtent = d3.extent(data, d => d[config.yField]);
             const xDomain = (xExtent[0] === undefined || xExtent[1] === undefined) ? [0, 1] : xExtent;
             const yDomain = (yExtent[0] === undefined || yExtent[1] === undefined) ? [0, 1] : yExtent;
             const x = d3.scaleLinear().domain(xDomain).nice().range([0, innerWidth]);
             const y = d3.scaleLinear().domain(yDomain).nice().range([innerHeight, 0]);
             const xMedian = config._xMedian, yMedian = config._yMedian;

            plotGroup.append("g").attr("class", "x-axis axis").attr("transform", `translate(0,${innerHeight})`).call(d3.axisBottom(x).ticks(7).tickSizeOuter(0));
            plotGroup.append("text").attr("class", "axis-label x-label").attr("x", innerWidth / 2).attr("y", innerHeight + margin.bottom - 10).text(config.xLabelFull || config.xLabel);
            plotGroup.append("g").attr("class", "y-axis axis").call(d3.axisLeft(y).ticks(7).tickSizeOuter(0));
            plotGroup.append("text").attr("class", "axis-label y-label").attr("transform", "rotate(-90)").attr("x", -innerHeight / 2).attr("y", -margin.left + 15).text(config.yLabelFull || config.yLabel);
            plotGroup.append("text").attr("class", "plot-title").attr("x", innerWidth / 2).attr("y", -margin.top / 2).text(config.title);
            if (xMedian !== undefined && xMedian !== null) plotGroup.append("line").attr("class", "quadrant-line").attr("x1", x(xMedian)).attr("x2", x(xMedian)).attr("y1", 0).attr("y2", innerHeight);
            if (yMedian !== undefined && yMedian !== null) plotGroup.append("line").attr("class", "quadrant-line").attr("x1", 0).attr("x2", innerWidth).attr("y1", y(yMedian)).attr("y2", y(yMedian));

            
            const isMobile = window.innerWidth <= 600;
            const labelPadding = isMobile ? 6 : 8; 
            
            const verticalLabelOffset = labelPadding * (isMobile ? 1.8 : 2); 
            

            if (config.quadLabels && xMedian !== undefined && yMedian !== undefined && xMedian !== null && yMedian !== null) {
                
                 plotGroup.append("text").attr("class", "quadrant-label").attr("x", x(xMedian) + labelPadding).attr("y", verticalLabelOffset).text(config.quadLabels.II).attr("text-anchor", "start");
                 plotGroup.append("text").attr("class", "quadrant-label").attr("x", x(xMedian) - labelPadding).attr("y", verticalLabelOffset).text(config.quadLabels.I).attr("text-anchor", "end");
                 plotGroup.append("text").attr("class", "quadrant-label").attr("x", x(xMedian) - labelPadding).attr("y", innerHeight - labelPadding).text(config.quadLabels.III).attr("text-anchor", "end"); // Bottom labels might need less vertical adjustment
                 plotGroup.append("text").attr("class", "quadrant-label").attr("x", x(xMedian) + labelPadding).attr("y", innerHeight - labelPadding).text(config.quadLabels.IV).attr("text-anchor", "start"); // Bottom labels might need less vertical adjustment
             }

             const circles = plotGroup.selectAll(".data-circle")
                .data(data, d => d.uat + d.jud)
                .enter().append("circle")
                .attr("class", "data-circle static-circle")
                .attr("cx", d => { const val = d[config.xField]; return (val !== undefined && val !== null && !isNaN(x(val))) ? x(val) : -10; })
                .attr("cy", d => { const val = d[config.yField]; return (val !== undefined && val !== null && !isNaN(y(val))) ? y(val) : -10; })
                .attr("r", d => { const xVal = d[config.xField]; const yVal = d[config.yField]; return (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 0.75 : 0; })
                .attr("fill", d => colorScale(d.Castigator) || "#999")
                .attr("opacity", 0.75).attr("stroke", "none").attr("stroke-width", 0)
                .style("pointer-events", d => { const xVal = d[config.xField]; const yVal = d[config.yField]; return (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? 'auto' : 'none'; })
                .on("mouseover", (event, d) => {
                    const xVal = d[config.xField], yVal = d[config.yField];
                    if (xVal === undefined || xVal === null || yVal === undefined || yVal === null) return;
                    tooltip.style("opacity", 1).html(scatterTooltip(d, config));
                    d3.select(event.currentTarget).raise().attr("stroke", "#000").attr("stroke-width", 1.5);
                })
                .on("mousemove", updateTooltipPosition)
                .on("mouseout", (event, d) => {
                     const xVal = d[config.xField], yVal = d[config.yField];
                     if (xVal === undefined || xVal === null || yVal === undefined || yVal === null) return;
                     tooltip.style("opacity", 0);
                     const searchTerm = normalize(d3.select("#search-input").property("value"));
                     const isSearching = searchTerm.length > 0;
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                     const isHighlightedByFilter = currentFilter !== "all" && d.Castigator === currentFilter;
                     let finalStroke = "none", finalStrokeWidth = 0;
                     const isMain = d3.select(event.currentTarget).classed('main-circle');
                     if (exactSearchMatch) { finalStroke = "#FFFFFF"; finalStrokeWidth = isMain ? 3 : 2.5; }
                     else if (isHighlightedByFilter) { finalStroke = "#FFFFFF"; finalStrokeWidth = 1; }
                     d3.select(event.currentTarget).attr("stroke", finalStroke).attr("stroke-width", finalStrokeWidth);
                });
             staticCircles.push(circles);
             return circles;
         }

        
        d3.csv("scatter.csv", d3.autoType).then(data => {
            allDataGlobal = data.filter(d => d.Lat && d.Long && d.Castigator && d.uat && d["Procent castigator"]);

            
            const scatterConfig1 = { xField: "Varsta medie a populatiei in 2023", yField: "Suprafata locuibila/cap de locuitor (m patrati) 2023", xLabel: "V√¢rsta medie", yLabel: "Suprafa»õƒÉ/loc.", xUnit: " ani", yUnit: " m¬≤", xDecimals: 1, yDecimals: 1, title: "V√¢rsta medie a popula»õiei »ôi suprafa»õa locuibilƒÉ/cap de locuitor", xLabelFull: "V√¢rsta medie a popula»õiei (ani)", yLabelFull: "Suprafa»õƒÉ locuibilƒÉ/locuitor (m¬≤)", quadLabels: { I: "I. Suburbii sau localitƒÉ»õi periurbane prospere, spa»õiu mare", II: "II. LocalitƒÉ»õi √ÆmbƒÉtr√¢nite cu case mari sau zone turistice rurale", III: "III. Ora»ôe cu cartiere aglomerate, densitate mare", IV: "IV. Zone rurale sƒÉrace, cu case modeste »ôi popula»õie v√¢rstnicƒÉ" } };
            const scatterConfig2 = { xField: "Procent plecari din populatie (2023)", yField: "Ponderea somerilor in 2023", xLabel: "PlecƒÉri", yLabel: "»òomeri", xUnit: "%", yUnit: "%", xDecimals: 1, yDecimals: 1, title: "PlecƒÉrile din localitate »ôi ponderea »ôomerilor", xLabelFull: "Procent plecƒÉri din popula»õie (%)", yLabelFull: "Pondere »ôomeri √Æn popula»õie (%)", quadLabels: { I: "I. Neatractiv", II: "II. Probleme multiple", III: "III. Stabili", IV: "IV. Exod mascat" } };
            const scatterConfig3 = { xField: "Numarul de salariati raportat la populatie (% din populatie) 2023", yField: "Cote de impozit raportat la populatie (2022)", xLabel: "Salaria»õi", yLabel: "Impozit/loc.", xUnit: "%", yUnit: " lei", xDecimals: 1, yDecimals: 0, title: "Salaria»õi vs. Venituri din Impozite", xLabelFull: "Salaria»õi / Popula»õie (%)", yLabelFull: "Cote impozit / Popula»õie (lei/loc.)", quadLabels: { I: "I. Turism/RentƒÉ?", II: "II. Autonomi", III: "III. Vulnerabili", IV: "IV. Naveti»ôti?" } };
            const scatterConfig4 = { xField: "Fonduri pe cap de locuitor (2022)", yField: "Pacienti la un medic 2023", xLabel: "Fonduri UE/loc.", yLabel: "Pacien»õi/medic", xUnit: " lei", yUnit: "", xDecimals: 0, yDecimals: 0, title: "Fonduri Europene vs. Acces la Medici", xLabelFull: "Fonduri europene / Locuitor (lei)", yLabelFull: "NumƒÉr pacien»õi / medic", quadLabels: { I: "I. Zone fƒÉrƒÉ fonduri europene semnificative »ôi cu servicii medicale sub presiune", II: "II. Zone care atrag fonduri, dar fƒÉrƒÉ impact √ÆncƒÉ asupra sistemului medical", III: "III. Zone tradi»õional stabile sau atipice", IV: "Investi»õii consistente" } };

            
            mainScatterConfig = scatterConfig1;
            mainScatterConfig._xMedian = d3.median(allDataGlobal, d => d[mainScatterConfig.xField]);
            mainScatterConfig._yMedian = d3.median(allDataGlobal, d => d[mainScatterConfig.yField]);

            
            const areaScale = d3.scaleSqrt().domain(d3.extent(allDataGlobal, d => d["Procent castigator"])).range([baseCircleDiameter * 0.8, baseCircleDiameter * 2.2]);
            const xGeo = d3.scaleLinear().domain(d3.extent(allDataGlobal, d => d.Long)).range([marginMain.left, mainWidth - marginMain.right]);
            const yGeo = d3.scaleLinear().domain(d3.extent(allDataGlobal, d => d.Lat)).range([mainHeight - marginMain.bottom, marginMain.top]);

           
            createSpherePositions(allDataGlobal, 250);
            mainCircles = chartMain.selectAll("circle.main-circle")
                .data(allDataGlobal, d => d.uat + d.jud)
                .enter().append("circle")
                .attr("class", "data-circle main-circle")
                .attr("fill", d => colorScale(d.Castigator) || "#999")
                .attr("opacity", 0).style("pointer-events", "auto")
                .on("mouseover", (event, d) => {
                     tooltip.style("opacity", 1);
                     if (currentView === 'sphere' || currentView === 'map') tooltip.html(basicTooltip(d));
                     else if (currentView === 'scatter') {
                         const config = mainScatterConfig;
                         const xVal = d[config.xField], yVal = d[config.yField];
                         if (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) tooltip.html(scatterTooltip(d, config));
                         else tooltip.html(basicTooltip(d));
                     }
                     d3.select(event.currentTarget).raise().attr("stroke", "#000").attr("stroke-width", currentView === 'sphere' ? 2.5 : 2);
                 })
                .on("mousemove", updateTooltipPosition)
                .on("mouseout", (event, d) => {
                    tooltip.style("opacity", 0);
                    const searchTerm = normalize(d3.select("#search-input").property("value"));
                    const isSearching = searchTerm.length > 0;
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                    const isHighlightedByFilter = currentFilter !== "all" && d.Castigator === currentFilter;
                    let finalStroke = "none", finalStrokeWidth = 0;
                    const isMain = d3.select(event.currentTarget).classed('main-circle');
                    if (exactSearchMatch) { finalStroke = "#FFFFFF"; finalStrokeWidth = isMain ? 3 : 2.5; }
                    else if (isHighlightedByFilter) { finalStroke = "#FFFFFF"; finalStrokeWidth = 1; }
                    d3.select(event.currentTarget).attr("stroke", finalStroke).attr("stroke-width", finalStrokeWidth);
                });
            updateSphereVisuals();
            sphereAnimation.play();

            
            const datalist = document.getElementById("localitati-list");
            [...new Set(allDataGlobal.map(d => d.uat).filter(Boolean))]
                .sort((a, b) => a.localeCompare(b, "ro-RO"))
                .forEach(name => { const opt = document.createElement("option"); opt.value = name; datalist.appendChild(opt); });

            
            d3.select("#search-input").on("input", applyGlobalFilterAndSearch);
            d3.select("#clear-search").on("click", () => { d3.select("#search-input").property("value", ""); applyGlobalFilterAndSearch(); });
            d3.select("#winner-filter").on("change", applyGlobalFilterAndSearch);

            
            staticCircles = []; staticConfigs = {};
            createScatterPlot("#scatter-viz-1", allDataGlobal, scatterConfig1);
            createScatterPlot("#scatter-viz-2", allDataGlobal, scatterConfig2);
            createScatterPlot("#scatter-viz-3", allDataGlobal, scatterConfig3);
            createScatterPlot("#scatter-viz-4", allDataGlobal, scatterConfig4);
            applyGlobalFilterAndSearch(); 

            
            function toSphere() {
                if (currentView === 'sphere') return;
                console.log("Transitioning to Sphere");
                currentView = "sphere";
                window.IO?.disconnect(); // DEACTIVATE IO
                activeQuad = 'all'; observerInitialized = false;
                sphereAnimation.play();
                updateSearchControlsVisibility();
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();
                updateSphereVisuals();
            }

            function toMap() {
                if (currentView === 'map') return;
                console.log("Transitioning to Map");
                currentView = "map";
                window.IO?.disconnect(); // DEACTIVATE IO
                activeQuad = 'all'; observerInitialized = false;
                sphereAnimation.pause();
                updateSearchControlsVisibility();
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();
                svgMain.append("text").attr("class", "map-title").attr("x", mainWidth / 2).attr("y", marginMain.top / 2).text("Distribu»õia c√¢»ôtigƒÉtorilor pe localitƒÉ»õi");
                svgMain.append("text").attr("class", "map-subtitle").attr("x", mainWidth / 2).attr("y", marginMain.top / 2 + 22).text("Dimensiunea cercurilor indicƒÉ procentul ob»õinut de c√¢»ôtigƒÉtor. Click pe fiecare localitate sau folose»ôte filtrele");
                mainCircles.transition("mapPos").duration(1500).ease(d3.easeCubicInOut)
                    .attr("cx", d => (d.Long && !isNaN(xGeo(d.Long))) ? xGeo(d.Long) : -10)
                    .attr("cy", d => (d.Lat && !isNaN(yGeo(d.Lat))) ? yGeo(d.Lat) : -10)
                    .attr("r", d => (d.Lat && d.Long && areaScale) ? areaScale(d["Procent castigator"]) : 0)
                    .end().then(applyGlobalFilterAndSearch).catch(err => { console.error("Map transition error:", err); applyGlobalFilterAndSearch(); });
                applyGlobalFilterAndSearch();
            }

            function toScatter() {
                if (currentView === 'scatter') return;
                console.log("Transitioning to Main Scatter");
                currentView = "scatter";
                sphereAnimation.pause();
                updateSearchControlsVisibility();
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();

                const config = mainScatterConfig;
                const innerWidth = mainWidth - marginMain.left - marginMain.right;
                const innerHeight = mainHeight - marginMain.top - marginMain.bottom;
                const xExtent = d3.extent(allDataGlobal, d => d[config.xField]);
                const yExtent = d3.extent(allDataGlobal, d => d[config.yField]);
                const xDomain = (xExtent[0] === undefined || xExtent[1] === undefined) ? [0, 1] : xExtent;
                const yDomain = (yExtent[0] === undefined || yExtent[1] === undefined) ? [0, 1] : yExtent;
                const x = d3.scaleLinear().domain(xDomain).nice().range([marginMain.left, mainWidth - marginMain.right]);
                const y = d3.scaleLinear().domain(yDomain).nice().range([mainHeight - marginMain.bottom, marginMain.top]);
                const xMedian = config._xMedian, yMedian = config._yMedian;

                 svgMain.append("text").attr("class", "plot-title").attr("x", mainWidth / 2).attr("y", marginMain.top / 2 - 5).text(config.title);
                 svgMain.append("g").attr("class", "x-axis axis").attr("transform", `translate(0,${mainHeight - marginMain.bottom})`).call(d3.axisBottom(x).ticks(7));
                 svgMain.append("text").attr("class", "x-label axis-label").attr("x", mainWidth / 2).attr("y", mainHeight - 15).text(config.xLabelFull);
                 svgMain.append("g").attr("class", "y-axis axis").attr("transform", `translate(${marginMain.left},0)`).call(d3.axisLeft(y).ticks(7));
                 svgMain.append("text").attr("class", "y-label axis-label").attr("transform", "rotate(-90)").attr("x", -(marginMain.top + innerHeight / 2)).attr("y", marginMain.left - 50).text(config.yLabelFull);
                 if (xMedian !== undefined && xMedian !== null) svgMain.append("line").attr("class", "quadrant-line").attr("x1", x(xMedian)).attr("x2", x(xMedian)).attr("y1", marginMain.top).attr("y2", mainHeight - marginMain.bottom);
                 if (yMedian !== undefined && yMedian !== null) svgMain.append("line").attr("class", "quadrant-line").attr("x1", marginMain.left).attr("x2", mainWidth - marginMain.right).attr("y1", y(yMedian)).attr("y2", y(yMedian));

                 
                 const isMobile = window.innerWidth <= 600;
                 const mainLabelPadding = isMobile ? 8 : 12; 
                 
                 const mainVerticalLabelOffset = mainLabelPadding * (isMobile ? 1.8 : 1.5); // Adjust multiplier as needed
                 

                 if (config.quadLabels && xMedian !== undefined && yMedian !== undefined && xMedian !== null && yMedian !== null) {
                     
                      svgMain.append("text").attr("class", "quadrant-label").attr("x", x(xMedian) + mainLabelPadding).attr("y", marginMain.top + mainVerticalLabelOffset).text(config.quadLabels.II).attr("text-anchor", "start");
                      svgMain.append("text").attr("class", "quadrant-label").attr("x", x(xMedian) - mainLabelPadding).attr("y", marginMain.top + mainVerticalLabelOffset).text(config.quadLabels.I).attr("text-anchor", "end");
                      svgMain.append("text").attr("class", "quadrant-label").attr("x", x(xMedian) - mainLabelPadding).attr("y", mainHeight - marginMain.bottom - mainLabelPadding).text(config.quadLabels.III).attr("text-anchor", "end"); // Bottom labels might need less vertical adjustment
                      svgMain.append("text").attr("class", "quadrant-label").attr("x", x(xMedian) + mainLabelPadding).attr("y", mainHeight - marginMain.bottom - mainLabelPadding).text(config.quadLabels.IV).attr("text-anchor", "start"); // Bottom labels might need less vertical adjustment
                  }

                 const overlays = svgMain.selectAll(".quadrant-overlay").data(["I","II","III","IV"]);
                 overlays.enter().append("rect").attr("class","quadrant-overlay").merge(overlays)
                    .attr("opacity", 0).attr("pointer-events","none")
                    .each(function(q){
                        if (xMedian === undefined || yMedian === undefined || xMedian === null || yMedian === null) return;
                        const isLeft = q==="I" || q==="III", isTop = q==="I" || q==="II";
                        const xPos = isLeft ? marginMain.left : x(xMedian);
                        const yPos = isTop ? marginMain.top : y(yMedian);
                        const width = Math.max(0, isLeft ? x(xMedian)-marginMain.left : mainWidth-marginMain.right-x(xMedian));
                        const height = Math.max(0, isTop ? y(yMedian)-marginMain.top : mainHeight-marginMain.bottom-y(yMedian));
                        if (isFinite(xPos) && isFinite(yPos) && isFinite(width) && width >= 0 && isFinite(height) && height >= 0) {
                            d3.select(this).attr("x", xPos).attr("y", yPos).attr("width", width).attr("height", height);
                        } else { d3.select(this).attr("width", 0).attr("height", 0); }
                 });

                 mainCircles.transition("scatterPos").duration(1500).ease(d3.easeCubicInOut)
                    .attr("cx", d => { const val = d[config.xField]; return (val !== undefined && val !== null && !isNaN(x(val))) ? x(val) : -10; })
                    .attr("cy", d => { const val = d[config.yField]; return (val !== undefined && val !== null && !isNaN(y(val))) ? y(val) : -10; })
                    .attr("r", d => { const xVal = d[config.xField], yVal = d[config.yField]; return (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 1.1 : 0; })
                    .end().then(() => {
                         console.log("Scatter transition finished. Setting up IO.");
                         applyGlobalFilterAndSearch();
                         setupIntersectionObserver(config); 
                    }).catch(err => {
                         console.error("Scatter transition error:", err);
                         applyGlobalFilterAndSearch();
                         setupIntersectionObserver(config); 
                    });
                applyGlobalFilterAndSearch();
            }


            
            const steps = document.querySelectorAll("#scatter-steps .step");

            function setupIntersectionObserver(config) { // Expects mainScatterConfig
                window.IO?.disconnect();
                observerInitialized = false; // Reset flag
                console.log("[IO] Setting up Intersection Observer (Revised Logic)");

                window.IO = new IntersectionObserver(entries => {
                    if (currentView !== 'scatter') return; 

                    const minVisibilityThreshold = 0.05; 

                    
                    const visibleSteps = entries.filter(entry =>
                        entry.isIntersecting && entry.intersectionRatio >= minVisibilityThreshold
                    );

                    let highestVisibleStep = null;
                    if (visibleSteps.length > 0) {
                        
                        visibleSteps.sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top);
                        
                        highestVisibleStep = visibleSteps[0].target;
                    }

                    
                    const nextActiveQuad = highestVisibleStep ? highestVisibleStep.dataset.quad : 'all';

                   
                    if (nextActiveQuad !== activeQuad) {
                        console.log(`[IO Callback] *** Changing highlight: ${activeQuad} -> ${nextActiveQuad} *** (Highest visible: ${highestVisibleStep ? highestVisibleStep.dataset.quad : 'None'})`);
                        activeQuad = nextActiveQuad;
                        renderHighlight(activeQuad, config); // Pass config
                    }
                }, {
                    
                    threshold: Array.from({ length: 21 }, (_, i) => i * 0.05) // Use multiple thresholds (0, 0.05, ..., 1.0)
                });

                steps.forEach(s => window.IO.observe(s));
                console.log("[IO] Observer attached to steps.");

                 
                 if (!observerInitialized) {
                      console.log("[IO Initial Check] Scheduling (Revised)...");
                      setTimeout(() => {
                         if (currentView !== 'scatter') { console.log("[IO Initial Check] Aborted, view changed."); return; }
                         console.log("[IO Initial Check] Running (Revised)...");

                         const minVisibilityThreshold = 0.05;
                         const currentVisibleSteps = [];
                         steps.forEach(step => {
                            const rect = step.getBoundingClientRect();
                            const isIntersecting = rect.top < window.innerHeight && rect.bottom > 0;
                            if (isIntersecting) {
                                const visibleHeight = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
                                const ratio = Math.max(0, Math.min(1, visibleHeight / rect.height));
                                if (ratio >= minVisibilityThreshold) {
                                    currentVisibleSteps.push({ target: step, top: rect.top });
                                }
                            }
                         });

                         let initialHighestStep = null;
                         if (currentVisibleSteps.length > 0) {
                             currentVisibleSteps.sort((a, b) => a.top - b.top);
                             initialHighestStep = currentVisibleSteps[0].target;
                         }

                         const initialActiveQuad = initialHighestStep ? initialHighestStep.dataset.quad : 'all';
                         console.log(`[IO Initial Check] Determined initial quad: ${initialActiveQuad}.`);

                         if (initialActiveQuad !== activeQuad) {
                              console.log(`[IO Initial Check] *** Setting initial highlight: ${activeQuad} -> ${initialActiveQuad} ***`);
                              activeQuad = initialActiveQuad;
                         }
                         renderHighlight(activeQuad, config); 
                         observerInitialized = true;
                     }, 350); 
                 }
             } 

            function renderHighlight(quad, config) { // Expects mainScatterConfig
                if (currentView !== 'scatter' || !svgMain || !svgMain.node()) { // GUARD
                    console.warn(`[RenderHighlight] Aborting. View: ${currentView}, SVG exists: ${!!svgMain?.node()}`);
                    if (currentView !== 'scatter') activeQuad = 'all';
                    return;
                }
                console.log(`[RenderHighlight] Rendering for quad: ${quad}`);
                svgMain.selectAll(".quadrant-overlay")
                    .filter(qData => qData).transition("overlayHighlight").duration(300)
                    .attr("opacity", qData => (quad === "all") ? 0 : (qData === quad ? 0.12 : 0));
                
                applyGlobalFilterAndSearch();
            } 


            
            const chartWrapper = document.querySelector('.chart-wrapper');
            const scatterStepsSection = document.getElementById('scatter-steps');

            window.addEventListener("scroll", () => {
                const y = window.scrollY;
                const wh = window.innerHeight;
                if (!chartWrapper || !scatterStepsSection) return;

                const wrapperRect = chartWrapper.getBoundingClientRect();
                const stepsRect = scatterStepsSection.getBoundingClientRect();
                const wrapperTop = wrapperRect.top + y;
                const stepsTop = stepsRect.top + y;
                const wrapperHeight = chartWrapper.offsetHeight;

                
                const mapStartPoint = wrapperTop + wrapperHeight * 0.33 - wh;
                
                const scatterStartPoint = stepsTop - wh * 0.6; 

                let targetView;

                if (y < mapStartPoint) {
                    targetView = "sphere";
                } else if (y >= mapStartPoint && y < scatterStartPoint) {
                    targetView = "map";
                } else { // y >= scatterStartPoint
                    targetView = "scatter";
                }

                if (targetView !== currentView) {
                    console.log(`Scroll Trigger: Changing view from ${currentView} to ${targetView} (y=${y.toFixed(0)}, mapStart=${mapStartPoint.toFixed(0)}, scatterStart=${scatterStartPoint.toFixed(0)})`);
                    if (targetView === "sphere") toSphere();
                    else if (targetView === "map") toMap();
                    else if (targetView === "scatter") toScatter();
                }

                
                updateSearchControlsVisibility();

               
                const intro = document.getElementById("sphere-intro");
                if (intro) {
                    if (y < 80 && currentView === 'sphere') intro.classList.remove("hidden");
                    else intro.classList.add("hidden");
                }

            }, { passive: true });


            
            const chartContainer = document.getElementById("chart-container");
            const staticPlotsSection = document.getElementById("flourish-block");

             if (chartContainer && staticPlotsSection) {
                new IntersectionObserver(
                    entries => {
                        const staticPlotsEntry = entries[0];
                        const fadeStartRatio = 0.05, fadeEndRatio = 0.25;
                        let opacity = 1;
                        staticPlotsVisible = staticPlotsEntry.isIntersecting;
                        if (staticPlotsEntry.isIntersecting) {
                            const ratio = staticPlotsEntry.intersectionRatio;
                            if (ratio >= fadeStartRatio) opacity = 1 - Math.min(1, Math.max(0, (ratio - fadeStartRatio) / (fadeEndRatio - fadeStartRatio)));
                        } else if (staticPlotsEntry.boundingClientRect.top < 0) { opacity = 0; staticPlotsVisible = false; }
                        else { opacity = 1; staticPlotsVisible = false; }
                        chartContainer.style.opacity = opacity;
                        chartContainer.style.pointerEvents = opacity < 0.5 ? "none" : "auto";
                        updateSearchControlsVisibility();
                        const intro = document.getElementById("sphere-intro");
                        if (intro && opacity < 0.8) intro.classList.add("hidden");
                        if (opacity < 0.5 && window.IO) { // Disconnect IO if chart hidden
                             console.log("Disconnecting IO due to main chart fade");
                             window.IO.disconnect();
                             activeQuad = 'all'; observerInitialized = false;
                        }
                    }, { threshold: Array.from({ length: 21 }, (_, i) => i * 0.05) }
                ).observe(staticPlotsSection);
             }

            
            const intro = document.getElementById("sphere-intro");
            const introOk = document.getElementById("intro-ok");
            if (intro && introOk) {
                function hideIntro() { intro.classList.add("hidden"); }
                introOk.addEventListener("click", hideIntro);
            }

            
            setTimeout(() => {
                 const y = window.scrollY;
                 const wh = window.innerHeight;
                 if (!chartWrapper || !scatterStepsSection) {
                     console.error("Initial view check failed: Elements not found.");
                     toSphere(); applyGlobalFilterAndSearch(); updateSearchControlsVisibility(); return;
                 }
                 const wrapperRect = chartWrapper.getBoundingClientRect();
                 const stepsRect = scatterStepsSection.getBoundingClientRect();
                 const wrapperTop = wrapperRect.top + y;
                 const stepsTop = stepsRect.top + y;
                 const wrapperHeight = chartWrapper.offsetHeight;

                 
                 const mapStartPoint = wrapperTop + wrapperHeight * 0.33 - wh;
                 const scatterStartPoint = stepsTop - wh * 0.6; // <<< ADJUSTED: Transition earlier

                 let initialViewFunction = toSphere;

                 if (y >= mapStartPoint && y < scatterStartPoint) {
                     initialViewFunction = toMap;
                 } else if (y >= scatterStartPoint) {
                     initialViewFunction = toScatter;
                 }

                 console.log(`Setting initial view: ${initialViewFunction.name} (y=${y.toFixed(0)}, mapStart=${mapStartPoint.toFixed(0)}, scatterStart=${scatterStartPoint.toFixed(0)})`);
                 initialViewFunction();

                 
                 setTimeout(updateSearchControlsVisibility, 200);

                 
                 const intro = document.getElementById("sphere-intro");
                 if (intro) {
                     if (y < 80 && currentView === 'sphere') intro.classList.remove("hidden");
                     else intro.classList.add("hidden");
                 }
                 console.log("Initial view determined:", currentView);
            }, 150); 


        }).catch(error => {
            console.error("Error loading or processing data:", error);
            document.body.innerHTML = `<div style="color: red; padding: 50px; text-align: center; font-size: 1.2em;">A apƒÉrut o eroare la √ÆncƒÉrcarea datelor (${error.message}). VƒÉ rugƒÉm re√ÆncƒÉrca»õi pagina.</div>`;
        });

    </script>
    </body>
    </html>