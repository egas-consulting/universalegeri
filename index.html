<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Universul Românesc</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        *, *:before, *:after { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            overflow-x: hidden;
            background-color: #000;
            color: #fff;
        }

        .headline-wrapper {
            position: relative;
            z-index: 3;
            text-align: center;
            padding-top: 8vh;
            padding-bottom: 4vh;
            color: white;
        }

        .cosmic-supratitle {
            font-family: 'Roboto', sans-serif;
            font-size: 1.6em;
            font-weight: 300;
            color: white;
            text-shadow: 0 0 6px #88b5ff, 0 0 10px #5573d6;
            margin-bottom: 10px;
        }

        .cosmic-title {
            font-family: 'Roboto', sans-serif;
            font-size: 1.8em;
            font-weight: 400;
            padding: 0 6vw;
            line-height: 1.4;
            color: white;
            text-shadow: 0 0 6px #88b5ff, 0 0 12px #335bc4;
        }

        .text-container {
            max-width: 600px;
            margin: 0 auto;
            padding: 0 5vw;
            padding-top: 5vh;
            color: #fff;
        }

        p {
            text-align: center;
            font-size: 1em;
            margin: 1em 0;
        }


        .chart-wrapper {
            position: relative;
            height: 250vh;
            margin-bottom: 5vh;
        }

        .chart-container {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100vh;
            background: radial-gradient(ellipse at center, #0b1f4c 0%, #000000 100%);
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.6s ease;
        }


        .svg-inner {
            width: 100%;
            max-width: 1000px;
            position: relative;
        }
        svg {
            width: 100%;
            height: auto;
            display: block;
            background-color: transparent;
            overflow: visible;
        }


        .tooltip {
            position: absolute;
            background: rgba(255,255,255,0.95);
            border: 1px solid #aaa;
            padding: 0.85em 1em;
            font-size: 0.9em;
            pointer-events: none;
            opacity: 0;
            z-index: 10; /* Lower than search */
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            border-radius: 4px;
            max-width: 90vw;
            min-width: 80px;
            color: #333;
            transition: opacity 0.2s ease;
        }

        .top-spacer { height: 15vh; }


        #search-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 11; /* Above tooltip, below popup */
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            display: none;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            max-width: 90vw;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
        }
         #search-container.visible {
            display: block;
            opacity: 1;
            pointer-events: auto;
         }
        #search-input, #clear-search, #winner-filter {
            padding: 8px 12px;
            font-size: 0.9em;
            margin: 4px;
            border: 1px solid #555;
            border-radius: 5px;
            background-color: #333;
            color: #eee;
        }
        #search-input::placeholder { color: #aaa; }
        #clear-search {
            padding: 8px 10px;
            margin-left: 6px;
            cursor: pointer;
            background-color: #555;
            border-color: #777;
        }
         #clear-search:hover { background-color: #666; }
        #winner-filter {
            cursor: pointer;
            background-color: #333;
             border-color: #555;
             color: #eee;
             flex-grow: 1;
             min-width: 150px;
        }
        #search-container > div {
             display: flex;
             align-items: center;
             gap: 5px;
             flex-wrap: wrap;
         }
         #search-container > div:last-child { margin-top: 8px; }
         #search-container label {
             color: white;
             margin-right: 6px;
             font-size: 0.9em;
             white-space: nowrap;
         }


        #scatter-steps {
            position: relative;
            z-index: 5;

             margin-top: 100vh;
             padding-top: 1vh;
             padding-bottom: 5vh;
        }
        .step {
            position: relative;
            max-width: min(90vw, 340px);

            margin: 70vh auto;
            padding: 1.25em 1.5em;
            background: rgba(255,255,255,0.92);
            border-radius: 8px;
            font-size: .95em;
            line-height: 1.35;
            box-shadow: 0 2px 10px rgba(0,0,0,.25);
            color: #333;
        }

         .step:first-child { margin-top: 40vh; }
         .step:last-child { margin-bottom: 50vh; }


        #sphere-intro{
            position:fixed; inset:0; z-index:6; display:flex;
            flex-direction:column; justify-content:center; align-items:center;
            text-align:center; gap:1.5rem; font-family:'Roboto',sans-serif;
            background:rgba(0,0,0,0.88); color:#fff; opacity:1;
            pointer-events:auto; transition:opacity .6s ease;
        }
        #sphere-intro h2{font-size:2rem; margin:0;}
        #sphere-intro p {font-size:1rem; line-height:1.4; margin:0;}
        #sphere-intro button{
            padding:.6rem 1.4rem; font-size:1rem; border:none; border-radius:6px;
            background:#88b5ff; color:#000; cursor:pointer;
        }
        #sphere-intro.hidden{ opacity:0; pointer-events:none; }


        #flourish-block{
            padding: 10vh 0 6vh;
            background: #000;
            text-align:center;
            position:relative;
            z-index:3;
        }
        .scatter-plot-container { /* Used for static plots */
            max-width: 950px;
            width: 92%;
            margin: 10vh auto;
            background-color: rgba(11, 31, 76, 0.2);
            border-radius: 8px;
            padding: 25px 15px 15px 15px;
            box-shadow: 0 0 15px rgba(136, 181, 255, 0.15);
        }
        .scatter-explainer {
            font-size: 1em; color: #ccc; margin-top: 10px;
            max-width: 850px; margin-left: auto; margin-right: auto;
            padding: 0 15px; line-height: 1.4; text-align: center;
            margin-top: 50px;


        }



        .axis path, .axis line { stroke: #aaa; stroke-width: 0.5; shape-rendering: crispEdges; }
        .axis text { fill: #ccc; font-weight: 300; font-size: 10px; }
        .axis-label { fill: #ddd; font-size: 0.85em; text-anchor: middle; }
        .plot-title { fill: #fff; font-size: 1.25em; font-weight: 600; text-anchor: middle; }
        .map-title { fill: #fff; font-size: 1.3em; font-weight: 600; text-anchor: middle; }
        .map-subtitle { fill: #ccc; font-size: 0.9em; text-anchor: middle; }
        .quadrant-line { stroke: #ffffff; stroke-dasharray: 3 3; stroke-width: 1.5px; opacity: 0.8; }

        /* --- START: Updated Quadrant Label Styles --- */
        .quadrant-label { /* Base style for all quadrant labels - applied to <text> */
            fill: #ffffff;
            font-size: 1em; /* Base size - inherited by outer */
            font-weight: 400;
            opacity: 0.9;
         }
         .quadrant-label-outer { /* Style for labels outside the plot */
             /* Increased font size */
             font-size: 1.4em; /* Larger base size */
             /* Improved contrast/visibility */
             fill: #e0e0e0; /* Lighter grey */
             font-weight: 500; /* Slightly bolder */
             opacity: 0.95; /* Ensure high opacity */
             /* Add subtle shadow for definition */
             text-shadow: 0 0 3px rgba(0, 0, 0, 0.7);
             pointer-events: none; /* Ensure labels don't block mouse events */
             /* Line height is controlled by 'dy' on tspans in JS */
         }
         /* Optional: Style for the tspan lines if needed */
         .quadrant-label-outer tspan {
             /* Specific styles for tspans if required */
         }
         /* --- END: Updated Quadrant Label Styles --- */

         .quadrant-overlay {
             fill: #ffffff;
             opacity: 0;
             pointer-events: none;
             transition: opacity 0.3s ease;
         }

        /* --- START: Candidate Summary Pop-up Styles --- */
        #candidate-summary-popup {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(40, 40, 60, 0.95); /* Slightly different background */
            border: 1px solid #777;
            border-radius: 8px;
            padding: 15px 20px;
            max-width: 320px; /* Adjust as needed */
            z-index: 12; /* Above search, below tooltip */
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            color: #eee;
            font-size: 0.85em;
            line-height: 1.4;
        }

        #candidate-summary-popup.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        #summary-text p {
            margin: 0 0 10px 0;
            text-align: left; /* Align text left in popup */
             font-size: inherit; /* Inherit font size */
             color: inherit; /* Inherit color */
        }
         #summary-text strong {
             color: #fff; /* Make candidate name stand out */
         }
         #summary-text i { /* Style for axis labels in text */
             color: #bbb;
             font-style: normal; /* Make italics normal for axis labels */
             font-weight: 500; /* Slightly bolder */
         }

        #mini-chart-container {
            margin-top: 10px;
            height: 60px; /* Fixed height for mini chart area */
            width: 100%;
        }

        #mini-chart-svg {
            display: block;
            width: 100%;
            height: 100%;
        }
         /* Style for mini-chart elements (adjust as needed) */
        .mini-axis path, .mini-axis line {
            stroke: #888;
            stroke-width: 0.5;
            shape-rendering: crispEdges;
        }
        .mini-axis .tick text {
             fill: #ccc;
             font-size: 9px;
        }
        .mini-axis-label {
            fill: #ccc;
            font-size: 9px;
            text-anchor: middle;
        }
        .mini-bar { /* (Not used currently, but kept for potential future use) */
            fill: #88b5ff;
            stroke: #fff;
            stroke-width: 0.5;
        }
        .mini-median-line {
            stroke: #ffcc00; /* Highlight median */
            stroke-width: 1.5;
            stroke-dasharray: 2 2;
        }
         .mini-median-label {
             fill: #ffcc00;
             font-size: 10px;
             font-weight: bold;
         }

        #close-summary-popup {
            position: absolute;
            top: 5px;
            right: 8px;
            background: none;
            border: none;
            color: #ccc;
            font-size: 1.8em;
            line-height: 1;
            cursor: pointer;
            padding: 0 5px;
        }
        #close-summary-popup:hover {
            color: #fff;
        }
        /* --- END: Candidate Summary Pop-up Styles --- */


        @media (max-width: 600px) {
             #search-container {
                 top: 10px; left: 50%; right: auto; transform: translateX(-50%);
                 width: 90vw; max-width: 350px; padding: 8px 10px;
             }
             #search-container > div {
                 flex-direction: column; align-items: stretch; width: 100%; gap: 6px;
             }
             #search-input, #clear-search, #winner-filter, #search-container label {
                 font-size: 0.85em; width: 100%; margin: 0; box-sizing: border-box;
             }
             #search-input { padding: 7px 10px; }
              #clear-search { padding: 7px 10px; margin-top: 4px; }
             #search-container label { margin-bottom: 4px; text-align: center; margin-right: 0; }
             #winner-filter { padding: 7px 10px; min-width: 0; }
             #search-container > div:last-child { margin-top: 10px; }

            .scatter-plot-container {
                width: 98%; padding: 10px 5px 5px 5px; margin: 5vh auto; box-shadow: none;
            }
            .scatter-explainer { padding: 0 5px; font-size: 0.9em; margin-top: 30px; line-height: 1.3; }
             .plot-title { font-size: 1.1em; } /* Adjusted static plot title */
             .axis-label { font-size: 0.8em; } /* Adjusted static plot axis labels */


             .quadrant-label {
                 font-size: 1.1em; /* Adjusted static quadrant labels */
             }
             .quadrant-label-outer {
                  font-size: 1.1em; /* Adjusted static quadrant labels */
                  text-shadow: 0 0 2px rgba(0, 0, 0, 0.6);
             }

             .axis text { font-size: 8px; } /* Adjusted static axis text */


            .step { margin: 60vh auto; }
            .step:first-child { margin-top: 30vh; }
            .step:last-child { margin-bottom: 40vh; }

            .map-title { font-size: 1.15em; }
            .map-subtitle { font-size: 0.85em; }
            .cosmic-title { font-size: 1.5em; }
            .cosmic-supratitle { font-size: 1.3em; }

             /* Responsive adjustments for popup */
            #candidate-summary-popup {
                left: 10px;
                right: 10px;
                bottom: 10px;
                max-width: none; /* Take full width minus padding */
                width: auto;
                padding: 12px 15px;
                font-size: 0.8em;
            }
            #close-summary-popup {
                top: 3px;
                right: 5px;
                 font-size: 1.6em;
            }
             #mini-chart-container {
                 height: 50px; /* Slightly smaller on mobile */
             }
             .mini-axis-label { font-size: 8px; } /* Slightly smaller axis labels */
             .mini-median-label { font-size: 9px; } /* Slightly smaller median labels */
             .mini-axis .tick text { font-size: 8px; } /* Slightly smaller tick labels */
        }


        body { min-height: 500vh; }
        html,body{ overscroll-behavior: none; }

    </style>
</head>
<body>
    <div class="headline-wrapper">
        <div class="cosmic-supratitle">Universul Românesc</div>
        <h1 class="cosmic-title">
            Ce impact are statutul socio-economic al localităților rezultatele la prezidențiale
        </h1>
    </div>
    <div class="text-container">
        <p>
            Am corelat <strong>rezultatele obținute</strong> și <strong>prezența</strong> în alegerile prezidențiale din 2025.<br>
            <strong>Scroll</strong> pentru a explora vizualizarea interactivă principală. Mai jos găsiți analize detaliate pe indicatori specifici.<br>
            <i>Filtrele și căutarea (sus dreapta) se aplică tuturor graficelor.</i>
        </p>
    </div>

    <div id="search-container">
        <div>
            <input id="search-input" type="text" placeholder="Caută localitate..." list="localitati-list">
            <button id="clear-search" title="Resetează căutarea">Reset</button>
            <datalist id="localitati-list"></datalist>
        </div>
        <div >
            <label for="winner-filter">Filtrează după câștigător:</label>
            <!-- *** UPDATED FILTER OPTIONS START *** -->
             <select id="winner-filter">
                <option value="all">Toți</option>
                <!-- Use full names from CSV in the 'value' attribute -->
                <option value="GEORGE-NICOLAE SIMION">GEORGE SIMION</option>
                <option value="GEORGE-CRIN-LAURENȚIU ANTONESCU">CRIN ANTONESCU</option>
                <option value="NICUȘOR-DANIEL DAN">NICUȘOR DAN</option>
                <option value="VICTOR-VIOREL PONTA">VICTOR PONTA</option>
            </select>
             <!-- *** UPDATED FILTER OPTIONS END *** -->
        </div>
    </div>

    <div class="top-spacer"></div>

    <div class="chart-wrapper">
        <div class="chart-container" id="chart-container">
            <div class="svg-inner">
                <svg id="viz" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet"></svg>
                <!-- Note: Arrowhead <defs> would go here if implemented -->
            </div>
        </div>
    </div>

    <div id="sphere-intro">
        <h2>Universul Românesc</h2>
        <p>Am analizat rezultatele din primul tur al alegerilor prezidențiale din 2025<br>
            și le-am corelat cu 8 indicatori economici și sociali relevanți, <br>
            pentru a înțelege cum influențează aceștia opțiunile electorale.<br>
            Fiecare cerc din grafic este interactiv. Scroll pentru a explora toate secțiunile.
        </p>
        <button id="intro-ok">Începe</button>
    </div>

    <section id="scatter-steps">
        <div class="step" data-quad="I">
            <p><strong>Cum este împărțit graficul</strong><br>
                Fiecare grafic este împărțit în patru părți, folosind valorile mediane de pe fiecare axă pentru a identifica tipare clare între localități</p>
        </div>
        <div class="step" data-quad="II">
            <p><strong>Cum interpretezi cadranele</strong><br>
                Astfel, fiecare axă creează o linie de referință echitabilă, iar cele patru cadrane arată combinații diferite de situații (de exemplu: localități cu valori mari pe ambele axe, sau localități cu o valoare mare pe una și mică pe cealaltă).</p>
        </div>
        <div class="step" data-quad="III">
            <p><strong>De ce sunt utile cadranele</strong><br>
                În loc să analizăm fiecare indicator separat, vedem rapid cum se leagă între ele două variabile importante. Astfel, putem înțelege mai bine relația dintre factori economici, sociali sau politici și opțiunile electorale sau dezvoltarea locală.</p>
        </div>
        <div class="step" data-quad="IV">
            <p><strong>Caută localitatea sau filtrează informația</strong><br>
                Graficul este interactiv: poți plasa cursorul pe un cerc pentru a vedea detalii, căuta direct o localitate sau filtra localitățile după candidatul câștigător.</p>
        </div>
         <div class="step" data-quad="all"> <!-- This step helps reset when scrolling past the last specific quadrant step -->
             <p><strong>Scroll în continuare pentru a explora graficele</strong></p>
         </div>
    </section>

    <section id="flourish-block">
        <h2 class="cosmic-title" style="margin-bottom: 5vh; padding-top: 5vh;">Analiza detaliată pe indicatori statici</h2>
        <!-- Added data-chart-id attribute matching the SVG ID -->
        <div id="scatter-container-1" class="scatter-plot-container" data-chart-id="scatter-viz-1">
            <svg id="scatter-viz-1" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce poate spune despre o comunitate combinația dintre vârsta medie a populației și suprafața locuibilă disponibilă pe persoană?</strong> <br> Prin această distribuție în scatter plot, observăm contraste clare între regiuni: localitățile din dreapta sus, cu vârstă medie ridicată și spațiu generos, sunt adesea foste orașe istorice sau zone de vacanță unde populația tânără a migrat. La polul opus, orașele mici sau cartierele vechi, unde populația îmbătrânită locuiește în spații modeste, se regăsesc în partea de jos a graficului. Același tipar apare și în zonele rurale sărace.

                În stânga sus, găsim suburbii și localități periurbane prospere, unde familiile tinere locuiesc în case mari, în timp ce stânga jos reflectă orașele mari aglomerate, dominate de tineri care trăiesc în locuințe mai mici.

                Această combinație de indicatori deschide o fereastră spre înțelegerea dinamicii sociale, economice și istorice a comunităților.</p>
        </div>
        <!-- Added data-chart-id attribute matching the SVG ID -->
        <div id="scatter-container-2" class="scatter-plot-container" data-chart-id="scatter-viz-2">
            <svg id="scatter-viz-2" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce ne arată relația dintre plecările cu domiciliul și șomajul local?</strong><br>Plecările cu domiciliul raportate la populație sunt un indicator direct al mobilității și al nivelului de atractivitate al unei comunități. Ponderea șomerilor reflectă presiunea economică locală și oportunitățile de muncă disponibile.

                Zonele cu rate mari de plecare și șomaj ridicat indică adesea o spirală a declinului: lipsă de oportunități, migrație economică, depopulare accelerată. În schimb, comunitățile unde plecările sunt reduse și șomajul scăzut demonstrează stabilitate și capacitatea de a-și păstra populația activă.

                Această combinație de indicatori ajută la identificarea zonelor vulnerabile, dar și a celor care reușesc să reziste presiunilor demografice și economice.</p>
        </div>
         <!-- Added data-chart-id attribute matching the SVG ID -->
        <div id="scatter-container-3" class="scatter-plot-container" data-chart-id="scatter-viz-3">
            <svg id="scatter-viz-3" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce poate spune relația dintre numărul de salariați și veniturile fiscale locale?</strong><br>Numărul de salariați raportat la populație indică dinamismul economic al unei comunități: câți dintre locuitori contribuie activ la economie. Cota de impozit pe cap de locuitor arată cât de mult reușește administrația locală să colecteze din impozitele locale pe venituri și proprietăți.

                Zonele cu mulți salariați și cote fiscale mari per locuitor pot semnala comunități prospere, cu economie diversificată și administrație performantă. În schimb, zonele cu puțini salariați și venituri fiscale scăzute indică adesea probleme structurale – lipsa locurilor de muncă, migrație, economie informală sau o administrație slabă.

                Această combinație de indicatori surprinde echilibrul dintre forța de muncă activă și capacitatea reală a comunităților de a se susține financiar.</p>
        </div>
         <!-- Added data-chart-id attribute matching the SVG ID -->
        <div id="scatter-container-4" class="scatter-plot-container" data-chart-id="scatter-viz-4">
            <svg id="scatter-viz-4" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce poate spune relația dintre fondurile europene atrase pe cap de locuitor și numărul de pacienți care revin unui medic?</strong><br>Această combinație de indicatori oferă o perspectivă asupra modului în care investițiile publice influențează accesul la servicii medicale. Fondurile europene atrase nu sunt direcționate exclusiv către sănătate, însă dezvoltarea infrastructurii în ansamblu — drumuri mai bune, servicii publice modernizate, condiții de trai mai atractive — poate contribui la stabilizarea sau atragerea de profesioniști, inclusiv în domeniul medical. Această combinație de indicatori oferă o perspectivă asupra modului în care investițiile publice influențează accesul la servicii medicale. Fondurile europene atrase nu sunt direcționate exclusiv către sănătate, însă dezvoltarea infrastructurii în ansamblu — drumuri mai bune, servicii publice modernizate, condiții de trai mai atractive — poate contribui la stabilizarea sau atragerea de profesioniști, inclusiv în domeniul medical.</p>
        </div>
    </section>

    <div class="tooltip" id="tooltip"></div>

    <!-- START: Candidate Summary Pop-up HTML -->
    <div id="candidate-summary-popup">
        <div id="summary-text"></div>
        <div id="mini-chart-container">
            <svg id="mini-chart-svg"></svg>
        </div>
        <button id="close-summary-popup" title="Închide">&times;</button>
    </div>
    <!-- END: Candidate Summary Pop-up HTML -->


    <script>

        let allDataGlobal;
        const mainWidth = 1000, mainHeight = 700;
        const plotWidth = 900, plotHeight = 550;
        // Static plot margins (might need slight adjustment with larger labels)
        const margin = { top: 60, right: 60, bottom: 60, left: 80 }; // Increased right/bottom slightly
        // Main plot margins (might need slight adjustment with larger labels)
        const marginMain = { top: 60, right: 80, bottom: 70, left: 90 }; // Increased right/bottom slightly

        const mobileDiameter = 3;    // Smaller size for mobile
        const desktopDiameterLarge = 4;  // Size for larger screens
        const desktopDiameterMedium = 3.5; // Size for medium screens

        // Set baseCircleDiameter based on screen width
        const baseCircleDiameter = window.innerWidth <= 600 ? mobileDiameter : window.innerWidth > 800 ? desktopDiameterLarge : desktopDiameterMedium;

        const svgMain = d3.select("#viz");
        const tooltip = d3.select("#tooltip");
        const chartMain = svgMain.append("g").attr("id", "chartGroup");
        const searchEl = d3.select("#search-container");

        // START: Pop-up element variables
        const summaryPopup = d3.select("#candidate-summary-popup");
        const summaryTextEl = d3.select("#summary-text");
        const miniChartSvg = d3.select("#mini-chart-svg");
        const closeSummaryButton = d3.select("#close-summary-popup");
        // END: Pop-up element variables

        // *** UPDATED WINNER COLORS START ***
        const winnerColors = {
            // Use full names from CSV as keys
            "GEORGE-NICOLAE SIMION": "#FFB623",
            "GEORGE-CRIN-LAURENȚIU ANTONESCU": "#00B7FF",
            "NICUȘOR-DANIEL DAN": "#4DD400",
            "VICTOR-VIOREL PONTA": "#FF2A1F"
        };
         // *** UPDATED WINNER COLORS END ***

        const colorScale = d3.scaleOrdinal(Object.keys(winnerColors), Object.values(winnerColors));

        let currentView = "sphere";
        let currentFilter = "all";
        let mainCircles;
        let staticCircles = [];
        let staticConfigs = {}; // Stores config keyed by static SVG ID (e.g., "scatter-viz-1")
        let activeQuad = "all";
        let mainScatterConfig = {};
        let staticPlotsVisible = false; // Is the #flourish-block intersecting?
        let observerInitialized = false;
        let activeStaticPlotConfig = null; // Stores the config of the most visible static plot


        const normalize = str => (str || "").toString().normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().trim();


        function showSearchControls() { searchEl.classed("visible", true); }
        function hideSearchControls() { searchEl.classed("visible", false); }
        function updateSearchControlsVisibility() {
            // Show controls if main map/scatter is active OR if static plots are visible (even if main chart faded)
            if ((currentView === 'map' || currentView === 'scatter') || staticPlotsVisible) {
                showSearchControls();
            } else {
                hideSearchControls();
            }
        }


        function basicTooltip(d) {
            // Safely access properties, providing a default or fallback if needed
            const jud = d.jud || 'N/A';
            const uat = d.uat || 'N/A';
            const castigator = d.Castigator || 'N/A';
            const procentCastigator = d["Procent castigator"] != null ? d["Procent castigator"].toFixed(2) + '%' : 'N/A'; // Format percentage
            const prezenta = d.Prezenta != null ? d.Prezenta.toFixed(2) + '%' : 'N/A'; // Format percentage

            return `<strong>${jud}</strong><br/>${uat}<br/>Câștigător: ${castigator}<br/>Procent: ${procentCastigator}<br/>Prezența: ${prezenta}`;
        }

        function scatterTooltip(d, config) {
            const xValue = d[config.xField] !== undefined && d[config.xField] !== null ? d[config.xField].toFixed(config.xDecimals ?? 2) : 'N/A';
            const yValue = d[config.yField] !== undefined && d[config.yField] !== null ? d[config.yField].toFixed(config.yDecimals ?? 2) : 'N/A';
            // Safely access properties for the base info
            const jud = d.jud || 'N/A';
            const uat = d.uat || 'N/A';
            const castigator = d.Castigator || 'N/A';
            const procentCastigator = d["Procent castigator"] != null ? d["Procent castigator"].toFixed(2) + '%' : 'N/A';
            const prezenta = d.Prezenta != null ? d.Prezenta.toFixed(2) + '%' : 'N/A';

            return `<strong>${jud}</strong><br/>${uat}<br/>${config.xLabel}: ${xValue}${config.xUnit ?? ''}<br/>${config.yLabel}: ${yValue}${config.yUnit ?? ''}<br/>Câștigător: ${castigator}<br/>Procent: ${procentCastigator}<br/>Prezența: ${prezenta}`;
         }
         function updateTooltipPosition(event) {
            const tRect = tooltip.node().getBoundingClientRect();
            let left = event.pageX + 10, top = event.pageY - 15;
            const marginTT = 10; // Tooltip margin
            if (left + tRect.width > window.innerWidth - marginTT) left = event.pageX - tRect.width - 10;
            if (top + tRect.height > window.innerHeight - marginTT) top = event.pageY - tRect.height - 5;
            if (top < marginTT) top = marginTT;
            if (left < marginTT) left = marginTT;
            tooltip.style("left", left + "px").style("top", top + "px");
         }


        function createSpherePositions(data, radius = 250){
            data.forEach((d,i) => {
                const phi = Math.acos(-1 + (2 * i) / data.length);
                const theta = Math.sqrt(data.length * Math.PI) * phi;
                d.sphere_x = radius * Math.sin(phi) * Math.cos(theta);
                d.sphere_y = radius * Math.sin(phi) * Math.sin(theta);
                d.sphere_z = radius * Math.cos(phi);
            });
        }
        let rotationAngle = 0;
        const sphereAnimation = anime({
            targets: { angle: 0 }, angle: 2 * Math.PI, duration: 35000, easing: 'linear',
            loop: true, autoplay: false,
            update: anim => {
                rotationAngle = anim.animations[0].currentValue;
                if (currentView === "sphere") updateSphereVisuals();
            }
        });
        function updateSphereVisuals() {
            const f = 400, cx = mainWidth / 2, cy = mainHeight / 2;
            if (!mainCircles) return;
            mainCircles.each(function(d) {
                const xRot = d.sphere_x * Math.cos(rotationAngle) - d.sphere_z * Math.sin(rotationAngle);
                const zRot = d.sphere_x * Math.sin(rotationAngle) + d.sphere_z * Math.cos(rotationAngle);
                const scale = f / (f + zRot + 1e-6); // Add small epsilon to prevent division by zero if f+zRot is exactly 0
                d.display_x = cx + xRot * scale;
                d.display_y = cy + d.sphere_y * scale;
                // Ensure scale is non-negative before calculating radius
                d.base_sphere_r = Math.max(1, baseCircleDiameter * (scale > 0 ? scale : 0));
                 // Calculate opacity based on z-coordinate for depth effect
                d.display_opacity_z = Math.max(0.1, Math.min(1, (f - zRot) / (f * 1.5)));
            });
            applyGlobalFilterAndSearch(); // Apply filters which will use the calculated opacity and radius
        }


        function isPointInQuad(d, config, quad) {
            if (!config || !config.xField || !config.yField || !allDataGlobal) return false;
            // Use cached medians if available
            const xMedian = config._xMedian ?? (config._xMedian = d3.median(allDataGlobal, dataPoint => dataPoint[config.xField]));
            const yMedian = config._yMedian ?? (config._yMedian = d3.median(allDataGlobal, dataPoint => dataPoint[config.yField]));
            if (xMedian === undefined || yMedian === undefined || xMedian === null || yMedian === null) return false; // Medians invalid
            const xVal = d[config.xField], yVal = d[config.yField];
            if (xVal === undefined || yVal === undefined || xVal === null || yVal === null) return false; // Data point invalid

            let pointQuad = "";
            // Quadrant Definition: I=TopLeft, II=TopRight, III=BottomLeft, IV=BottomRight
            if (xVal <= xMedian && yVal >= yMedian) pointQuad = "I";
            else if (xVal > xMedian && yVal >= yMedian) pointQuad = "II";
            else if (xVal <= xMedian && yVal < yMedian) pointQuad = "III";
            else if (xVal > xMedian && yVal < yMedian) pointQuad = "IV";

            return pointQuad === quad;
         }

        // START: Candidate Summary Pop-up Functions
        function hideSummaryPopup() {
            summaryPopup.classed("visible", false);
            // Optional: Clear the mini-chart when hiding
            miniChartSvg.selectAll("*").remove();
        }

        function showSummaryPopup(candidateName, candidateData, config) {
            // Check if config is valid before proceeding
            if (!config || !config.xField || !config.yField) {
                console.warn("showSummaryPopup called with invalid config:", config);
                hideSummaryPopup();
                return;
            }
            if (!candidateData || candidateData.length === 0) {
                hideSummaryPopup();
                return;
            }


            // Filter for valid numeric data points *for this candidate* on the current axes
            const validCandidateData = candidateData.filter(d =>
                d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number' &&
                d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number'
            );

            if (validCandidateData.length === 0) {
                 // Show a message if candidate won localities, but none have valid data for these axes
                 summaryTextEl.html(`<p><strong>${candidateName.replace(/-/g, ' ')}</strong> a câștigat ${candidateData.length} localități, dar nu există date valide pentru axele curente (<i>${config.xLabel}</i> / <i>${config.yLabel}</i>) în aceste localități.</p>`);
                 miniChartSvg.selectAll("*").remove(); // Clear chart
                 summaryPopup.classed("visible", true);
                 return; // Exit without chart/median calculation
            }


            // Calculate MEDIANS for the valid data
            const medianX = d3.median(validCandidateData, d => d[config.xField]);
            const medianY = d3.median(validCandidateData, d => d[config.yField]);

            // Format the text - use median values
            const count = candidateData.length; // Total localities won
            const xValStr = medianX !== undefined ? medianX.toFixed(config.xDecimals ?? 1) + (config.xUnit ?? '') : 'N/A';
            const yValStr = medianY !== undefined ? medianY.toFixed(config.yDecimals ?? 1) + (config.yUnit ?? '') : 'N/A';


            // --- UPDATED TEXT ---
            summaryTextEl.html(`<p><strong>${candidateName.replace(/-/g, ' ')}</strong> a câștigat ${count} localități.
               Mediane în localitățile câștigate:
                <br> • <i>${config.xLabel}</i>: ${xValStr}
                <br> • <i>${config.yLabel}</i>: ${yValStr}</p>`);
            // --- END UPDATED TEXT ---

            // Draw the mini chart using the current config's context
            drawMiniChart(validCandidateData, config, medianX, medianY);

            summaryPopup.classed("visible", true);
        }

        function drawMiniChart(data, config, medianX, medianY) {
            miniChartSvg.selectAll("*").remove(); // Clear previous chart

            const miniMargin = { top: 5, right: 20, bottom: 20, left: 45 }; // Adjusted left margin for labels
            const containerWidth = parseInt(miniChartSvg.style("width"));
             const containerHeight = parseInt(miniChartSvg.style("height"));

             if (!containerWidth || !containerHeight || containerWidth <= 0 || containerHeight <= 0) {
                 console.warn("Mini chart container has no valid dimensions.");
                 return; // Don't draw if container isn't sized correctly
             }

            const miniWidth = containerWidth - miniMargin.left - miniMargin.right;
            const miniHeight = containerHeight - miniMargin.top - miniMargin.bottom;


            if (miniWidth <= 0 || miniHeight <= 0) {
                 console.warn("Mini chart calculated dimensions are invalid.");
                 return; // Don't draw if calculated dimensions are invalid
            }

            const chartGroup = miniChartSvg.append("g")
                .attr("transform", `translate(${miniMargin.left},${miniMargin.top})`);

            // Get overall scales for context, based on the PROVIDED config (main or static)
            let contextXScale, contextYScale;

             // We need the overall data range for the specific axes defined in 'config'
             // Filter ALL data for valid points on these specific axes
             const validDataForExtentContext = allDataGlobal.filter(d =>
                 d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number' &&
                 d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number'
             );

             if (validDataForExtentContext.length > 0) {
                 const xExtentContext = d3.extent(validDataForExtentContext, d => d[config.xField]);
                 const yExtentContext = d3.extent(validDataForExtentContext, d => d[config.yField]);
                 const xDomainContext = (xExtentContext[0] === undefined || xExtentContext[1] === undefined) ? [0, 1] : xExtentContext;
                 const yDomainContext = (yExtentContext[0] === undefined || yExtentContext[1] === undefined) ? [0, 1] : yExtentContext;

                 // Scales representing the full range of the *current* axes across all data
                 contextXScale = d3.scaleLinear().domain(xDomainContext).nice();
                 contextYScale = d3.scaleLinear().domain(yDomainContext).nice();
             }


            if (!contextXScale || !contextYScale) {
                 console.warn("Mini chart cannot be drawn without context scales for config:", config);
                  chartGroup.append("text").attr("x", miniWidth / 2).attr("y", miniHeight / 2).attr("text-anchor", "middle").attr("font-size", "10px").attr("fill", "#aaa").text("Eroare scală");
                 return; // Cannot draw without context scales
            }

             // --- Mini X-Axis (Bottom) --- Use context scale for domain
            const miniX = d3.scaleLinear().domain(contextXScale.domain()).range([0, miniWidth]);
            chartGroup.append("g")
                .attr("class", "mini-axis")
                .attr("transform", `translate(0, ${miniHeight})`)
                .call(d3.axisBottom(miniX).ticks(3).tickSize(3).tickPadding(2)); // Fewer ticks

            // Add X Axis Label (from config)
            chartGroup.append("text")
                 .attr("class", "mini-axis-label")
                 .attr("x", miniWidth / 2)
                 .attr("y", miniHeight + miniMargin.bottom - 5) // Position below axis
                 .text(config.xLabel); // Use short label from config

            // Draw Median X Line and Label (candidate's median)
            if (medianX !== undefined && isFinite(miniX(medianX))) {
                chartGroup.append("line")
                    .attr("class", "mini-median-line")
                    .attr("x1", miniX(medianX))
                    .attr("x2", miniX(medianX))
                    .attr("y1", 0)
                    .attr("y2", miniHeight);
                chartGroup.append("text")
                     .attr("class", "mini-median-label")
                     .attr("x", miniX(medianX))
                     .attr("y", -2) // Position above the top
                     .attr("text-anchor", "middle")
                     .text(medianX.toFixed(config.xDecimals ?? 1));
            }


             // --- Mini Y-Axis (Left) --- Use context scale for domain
             const miniY = d3.scaleLinear().domain(contextYScale.domain()).range([miniHeight, 0]); // Y is inverted
             chartGroup.append("g")
                 .attr("class", "mini-axis")
                 .call(d3.axisLeft(miniY).ticks(3).tickSize(3).tickPadding(2)); // Fewer ticks

            // Add Y Axis Label (from config)
             chartGroup.append("text")
                 .attr("class", "mini-axis-label")
                 .attr("transform", "rotate(-90)")
                 .attr("x", -miniHeight / 2)
                 .attr("y", -miniMargin.left + 12) // Position left of axis, adjusted
                 .text(config.yLabel); // Use short label from config

             // Draw Median Y Line and Label (candidate's median)
             if (medianY !== undefined && isFinite(miniY(medianY))) {
                 chartGroup.append("line")
                     .attr("class", "mini-median-line")
                     .attr("x1", 0)
                     .attr("x2", miniWidth)
                     .attr("y1", miniY(medianY))
                     .attr("y2", miniY(medianY));
                 chartGroup.append("text")
                      .attr("class", "mini-median-label")
                      .attr("x", -3) // Position left of axis line
                      .attr("y", miniY(medianY))
                      .attr("text-anchor", "end")
                      .attr("alignment-baseline", "middle")
                      .text(medianY.toFixed(config.yDecimals ?? 1));
             }
        }
        // END: Candidate Summary Pop-up Functions


        function applyGlobalFilterAndSearch() {
            const searchTerm = normalize(d3.select("#search-input").property("value"));
            const isSearching = searchTerm.length > 0;
            const selectedWinner = d3.select("#winner-filter").property("value");
            currentFilter = selectedWinner; // Update currentFilter

             // --- START Updated Pop-up Logic ---
             let showPopup = false;
             let configForPopup = null;

             // Condition 1: Filter active and search inactive
             if (selectedWinner !== 'all' && !isSearching) {
                 // Condition 2: Determine relevant config
                 const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);

                 // Prioritize static plot config if main chart is significantly faded AND a static plot is active
                 if (mainChartOpacity < 0.5 && staticPlotsVisible && activeStaticPlotConfig) {
                     configForPopup = activeStaticPlotConfig;
                     showPopup = true;
                     console.log("Pop-up using ACTIVE STATIC config:", activeStaticPlotConfig.title);
                 }
                 // Otherwise, use main scatter config if the view is scatter (even if fading)
                 else if (currentView === 'scatter') {
                     configForPopup = mainScatterConfig;
                     showPopup = true;
                      console.log("Pop-up using MAIN config:", mainScatterConfig.title);
                 }
             }

             // Show or hide the popup based on the decision
             if (showPopup && configForPopup) {
                 const candidateSpecificData = allDataGlobal.filter(d => d.Castigator === selectedWinner);
                 showSummaryPopup(selectedWinner, candidateSpecificData, configForPopup);
             } else {
                 hideSummaryPopup();
                  console.log("Hiding pop-up.");
             }
             // --- END Updated Pop-up Logic ---


             // --- Existing Filter/Highlight Logic ---
            let areaScale;
            if (allDataGlobal) {
                // Ensure Procent castigator exists and is numeric before calculating extent
                const validPercentages = allDataGlobal
                    .map(d => d["Procent castigator"])
                    .filter(p => p != null && !isNaN(p)); // Filter out null/undefined/NaN

                if (validPercentages.length > 0) {
                    const extent = d3.extent(validPercentages);
                     if (extent[0] !== undefined && extent[1] !== undefined) {
                        areaScale = d3.scaleSqrt().domain(extent).range([baseCircleDiameter * 0.8, baseCircleDiameter * 2.2]);
                     }
                }
            }

            // Raise exact search matches
            d3.selectAll(".data-circle").each(function(d) {
                if (isSearching && normalize(d.uat) === searchTerm) d3.select(this).raise();
            });

            // Apply filters and styles via transition
            d3.selectAll(".data-circle")
                .transition("filterSearch").duration(350)
                .attr("opacity", function(d) {
                    const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                    const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;

                    // Basic visibility check
                    if (!isWinnerMatch || !isSearchMatch) return 0.08;

                    let baseOpacity = 1.0;
                    const isMain = d3.select(this).classed('main-circle');
                    const isStatic = d3.select(this).classed('static-circle');

                    if (isStatic) {
                         const parentSvgId = d3.select(this.ownerSVGElement).attr('id');
                         const config = staticConfigs[parentSvgId];
                         // Dim static circles if their data is invalid for the plot axes
                         if(config && (d[config.xField] === null || d[config.yField] === null || d[config.xField] === undefined || d[config.yField] === undefined )) {
                             baseOpacity = 0.05;
                         } else {
                             baseOpacity = 0.75;
                         }
                    } else if (isMain) {

                        if (currentView === 'sphere') {
                            baseOpacity = d.display_opacity_z ?? 1.0;
                        } else if (currentView === 'map') {
                            baseOpacity = (d.Lat && d.Long) ? 0.8 : 0;
                        } else if (currentView === 'scatter') {
                            const config = mainScatterConfig;
                             // Check if config and required fields exist before accessing them
                             if (!config || !config.xField || !config.yField) return 0; // Or a default low opacity

                            const xVal = d[config.xField], yVal = d[config.yField];
                            const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;

                            if (!hasValidScatterData) return 0; // Hide points with invalid scatter data in this view

                            const isQuadActive = activeQuad !== 'all';
                            const inActiveQuad = isQuadActive && isPointInQuad(d, config, activeQuad);

                            // Dim if a quad is active, BUT the point is not in the active quad
                            if (isQuadActive && !inActiveQuad) baseOpacity = 0.05;
                            else baseOpacity = 0.8; // Default scatter opacity
                        }
                    }


                    if (isSearching && !exactSearchMatch && isWinnerMatch && isSearchMatch) {
                         baseOpacity *= 0.6;
                    }
                    // Highlight exact match
                    if (exactSearchMatch) {
                        baseOpacity = isStatic ? 0.9 : 1.0;
                    }

                    return Math.max(0.05, baseOpacity);
                })
                .attr("stroke", function(d) {
                    const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                    const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;

                    if (!isWinnerMatch || !isSearchMatch) return "none";

                    if (exactSearchMatch) return "#FFFFFF";
                    if (currentFilter !== "all" && isWinnerMatch) return "#FFFFFF";


                    const isMain = d3.select(this).classed('main-circle');
                    if (isMain && currentView === 'scatter' && activeQuad !== 'all') {
                         const config = mainScatterConfig;
                          // Add checks for config and fields
                          if (!config || !config.xField || !config.yField) return "none";
                         const xVal = d[config.xField], yVal = d[config.yField];
                         const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                         if (hasValidScatterData && isPointInQuad(d, config, activeQuad)) {
                             return "#FFF";
                         }
                    }


                    return "none";
                })
                .attr("stroke-width", function(d) {
                     const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                     const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;

                     if (!isWinnerMatch || !isSearchMatch) return 0;

                     const isMain = d3.select(this).classed('main-circle');

                     if (exactSearchMatch) return isMain ? 3 : 2.5;
                     if (currentFilter !== "all" && isWinnerMatch) return 1;


                     if (isMain && currentView === 'scatter' && activeQuad !== 'all') {
                          const config = mainScatterConfig;
                           // Add checks for config and fields
                           if (!config || !config.xField || !config.yField) return 0;
                          const xVal = d[config.xField], yVal = d[config.yField];
                          const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                          if (hasValidScatterData && isPointInQuad(d, config, activeQuad)) {
                              return 1;
                          }
                     }


                     return 0;
                 })
                 .attr("cx", function(d) {
                    if (currentView === 'sphere' && d3.select(this).classed('main-circle')) return d.display_x;
                    // Keep existing calculated cx for map/scatter if transitioning
                    const currentCx = d3.select(this).attr("cx");
                    return isFinite(currentCx) ? currentCx : -100; // Ensure it's a number
                 })
                 .attr("cy", function(d) {
                    if (currentView === 'sphere' && d3.select(this).classed('main-circle')) return d.display_y;
                    // Keep existing calculated cy for map/scatter if transitioning
                    const currentCy = d3.select(this).attr("cy");
                    return isFinite(currentCy) ? currentCy : -100; // Ensure it's a number
                 })
                 .attr("r", function(d) {
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                     const boostFactor = 1.8;
                     const isMain = d3.select(this).classed('main-circle');
                     let baseRadius = 0;
                     const procent = d["Procent castigator"]; // Ensure procent value exists and is valid

                     if (isMain) {

                         if (currentView === 'sphere') {
                             baseRadius = d.base_sphere_r ?? 0;
                         } else if (currentView === 'map' && areaScale && procent != null && !isNaN(procent)) {
                             baseRadius = (d.Lat != null && d.Long != null) ? areaScale(procent) : 0; // Check Lat/Long for map
                         } else if (currentView === 'scatter') {
                             const config = mainScatterConfig;
                              // Add checks for config and fields
                              if (!config || !config.xField || !config.yField) return 0;
                             const xVal = d[config.xField], yVal = d[config.yField];
                             baseRadius = (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 1.1 : 0; // Only show if valid scatter data
                         }
                     } else { // Static plots
                          const parentSvgId = d3.select(this.ownerSVGElement).attr('id');
                          const config = staticConfigs[parentSvgId];
                          if (config) {
                              const xVal = d[config.xField], yVal = d[config.yField];
                              // Check for valid data before setting radius
                              baseRadius = (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 0.75 : 0; // Only show if valid scatter data
                          } else {
                              baseRadius = 0;
                          }
                     }


                     baseRadius = (typeof baseRadius === 'number' && !isNaN(baseRadius)) ? baseRadius : 0;


                     return (exactSearchMatch && baseRadius > 0) ? baseRadius * boostFactor : baseRadius;
                 })
                 .style("pointer-events", function(d) {
                    // Check if the circle matches the current winner filter
                    const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                    // Check if the circle matches the current search term (if any)
                    const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);

                    // Get the current opacity and radius of the circle (after potential updates in this transition)
                    const opacity = parseFloat(d3.select(this).attr("opacity"));
                    const radius = parseFloat(d3.select(this).attr("r"));

                    // A circle is interactive IF:
                    // 1. It matches the winner filter criteria
                    // 2. It matches the search term criteria (if a search is active)
                    // 3. It has a radius greater than a very small value (visible)
                    // 4. It has an opacity greater than a threshold (not completely faded out by quadrant/filter logic)
                    if (isWinnerMatch && isSearchMatch && radius > 0.1 && opacity > 0.06) { // Added opacity check
                        return 'auto'; // Make it interactive
                    }
                    return 'none'; // Make it non-interactive
                 });
         }


        function createScatterPlot(containerSelector, data, config) {
             const svg = d3.select(containerSelector);
             const svgId = svg.attr('id');
             staticConfigs[svgId] = config; // Store config keyed by SVG ID
             // Ensure data exists before calculating medians - Use ALL data for consistent medians
             if (allDataGlobal && allDataGlobal.length > 0) {
                config._xMedian = d3.median(allDataGlobal, d => (d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number') ? d[config.xField] : undefined);
                config._yMedian = d3.median(allDataGlobal, d => (d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number') ? d[config.yField] : undefined);
             } else {
                 config._xMedian = undefined;
                 config._yMedian = undefined;
             }


             svg.selectAll("*").remove();


             const plotGroup = svg.append("g")
                 .attr("transform", `translate(${margin.left},${margin.top})`);

             const innerWidth = plotWidth - margin.left - margin.right;
             const innerHeight = plotHeight - margin.top - margin.bottom;

             // --- START ADDED FILTER ---
             // Filter data for points with valid numeric values for THIS plot's axes
             const scatterPlotData = data.filter(d =>
                d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number' &&
                d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number'
             );
             // --- END ADDED FILTER ---


             // Filter *validData* for extent calculation (using the same criteria)
             const validDataForExtent = scatterPlotData; // Use the already filtered data


             // Determine data extents and setup scales using validDataForExtent
             const xExtent = d3.extent(validDataForExtent, d => d[config.xField]);
             const yExtent = d3.extent(validDataForExtent, d => d[config.yField]);
             // Handle cases where extent might be undefined (e.g., no valid data)
             const xDomain = (xExtent[0] === undefined || xExtent[1] === undefined) ? [0, 1] : xExtent;
             const yDomain = (yExtent[0] === undefined || yExtent[1] === undefined) ? [0, 1] : yExtent;

             const x = d3.scaleLinear().domain(xDomain).nice().range([0, innerWidth]);
             const y = d3.scaleLinear().domain(yDomain).nice().range([innerHeight, 0]);

             const xMedian = config._xMedian;
             const yMedian = config._yMedian;

            // --- Draw Axes and Titles ---
            plotGroup.append("g").attr("class", "x-axis axis")
                .attr("transform", `translate(0,${innerHeight})`)
                .call(d3.axisBottom(x).ticks(7).tickSizeOuter(0));
            plotGroup.append("text").attr("class", "axis-label x-label")
                .attr("x", innerWidth / 2)
                .attr("y", innerHeight + margin.bottom - 15) // Adjusted y slightly
                .text(config.xLabelFull || config.xLabel);
            plotGroup.append("g").attr("class", "y-axis axis")
                .call(d3.axisLeft(y).ticks(7).tickSizeOuter(0));
            plotGroup.append("text").attr("class", "axis-label y-label")
                .attr("transform", "rotate(-90)")
                .attr("x", -innerHeight / 2)
                .attr("y", -margin.left + 20) // Adjusted y slightly
                .text(config.yLabelFull || config.yLabel);
             // Adjusted plot title Y position
             svg.append("text").attr("class", "plot-title")
                 .attr("x", margin.left + innerWidth / 2)
                 .attr("y", margin.top / 2) // Position above the plot area
                 .text(config.title);


            if (xMedian !== undefined && xMedian !== null && isFinite(x(xMedian))) {
                plotGroup.append("line").attr("class", "quadrant-line")
                    .attr("x1", x(xMedian)).attr("x2", x(xMedian))
                    .attr("y1", 0).attr("y2", innerHeight);
            }
            if (yMedian !== undefined && yMedian !== null && isFinite(y(yMedian))) {
                plotGroup.append("line").attr("class", "quadrant-line")
                    .attr("x1", 0).attr("x2", innerWidth)
                    .attr("y1", y(yMedian)).attr("y2", y(yMedian));
            }


            // --- Draw Quadrant Labels OUTSIDE the plot area using TSPAN for wrapping ---
            const isMobile = window.innerWidth <= 600;
            // Adjusted padding values for larger/multi-line labels
            const outerLabelPadding = isMobile ? 10 : 15; // Reduced padding slightly
            const outerLabelYOffset = isMobile ? -12 : -18; // Reduced negative offset for top labels
            const outerLabelYOffsetBottom = isMobile ? 18 : 25; // Reduced positive offset for bottom labels


            if (config.quadLabels && xMedian !== undefined && yMedian !== undefined && xMedian !== null && yMedian !== null && isFinite(x(xMedian)) && isFinite(y(yMedian))) {
                 const labelData = [
                     { quad: 'II', anchor: 'end', xPos: innerWidth + outerLabelPadding, yPos: outerLabelYOffset }, // Top Right
                     { quad: 'I', anchor: 'start', xPos: -outerLabelPadding, yPos: outerLabelYOffset }, // Top Left
                     { quad: 'III', anchor: 'start', xPos: -outerLabelPadding, yPos: innerHeight + outerLabelYOffsetBottom }, // Bottom Left
                     { quad: 'IV', anchor: 'end', xPos: innerWidth + outerLabelPadding, yPos: innerHeight + outerLabelYOffsetBottom } // Bottom Right
                 ];


                 labelData.forEach(lbl => {
                     const labelText = config.quadLabels[lbl.quad];
                     if (!labelText) return; // Skip if label text is missing

                     const lines = labelText.split('\n'); // Split by newline character
                     const textElement = plotGroup.append("text") // Append to plotGroup
                         .attr("class", "quadrant-label quadrant-label-outer")
                         .attr("x", lbl.xPos) // Use calculated position
                         .attr("y", lbl.yPos) // Base y position for the first line
                         .attr("text-anchor", lbl.anchor);

                     // Append tspans for each line
                     lines.forEach((line, i) => {
                         textElement.append("tspan")
                             .attr("x", lbl.xPos) // Re-apply x for each tspan for correct anchor alignment
                             .attr("dy", i === 0 ? "0" : "1.1em") // Add vertical spacing (dy) for subsequent lines
                             .text(line);
                     });
                 });
             }
             // --- END NEW Quadrant Labels ---


             // --- Bind the FILTERED data to circles ---
             const circles = plotGroup.selectAll(".data-circle")
                .data(scatterPlotData, d => d.uat + d.jud) // Use scatterPlotData here
                .enter().append("circle")
                .attr("class", "data-circle static-circle")

                // cx, cy, r calculations now only happen for valid points in scatterPlotData
                .attr("cx", d => x(d[config.xField])) // Simpler now, as invalid points are pre-filtered
                .attr("cy", d => y(d[config.yField])) // Simpler now
                .attr("r", baseCircleDiameter * 0.75) // Simpler now

                .attr("fill", d => colorScale(d.Castigator) || "#999") // Use colorScale, default to grey
                .attr("opacity", 0.75) // Default opacity
                .attr("stroke", "none") // No default stroke
                .attr("stroke-width", 0) // No default stroke width
                .style("pointer-events", 'auto') // All drawn points are valid for interaction

                .on("mouseover", (event, d) => {
                     tooltip.style("opacity", 1).html(scatterTooltip(d, config)); // Show tooltip
                     d3.select(event.currentTarget).raise().attr("stroke", "#000").attr("stroke-width", 1.5); // Highlight
                 })
                .on("mousemove", updateTooltipPosition) // Update position on move
                .on("mouseout", (event, d) => {
                    tooltip.style("opacity", 0); // Hide tooltip
                    // Check persistent highlight states (search/filter)
                     const searchTerm = normalize(d3.select("#search-input").property("value"));
                     const isSearching = searchTerm.length > 0;
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                     const isHighlightedByFilter = currentFilter !== "all" && d.Castigator === currentFilter;

                     let finalStroke = "none", finalStrokeWidth = 0;
                     if (exactSearchMatch) { // Exact search match has priority
                         finalStroke = "#FFFFFF";
                         finalStrokeWidth = 2.5; // Slightly thinner for static plots
                     } else if (isHighlightedByFilter) { // Winner filter highlight
                         finalStroke = "#FFFFFF";
                         finalStrokeWidth = 1;
                     }
                     // Reset stroke based on persistent state (search/filter)
                     d3.select(event.currentTarget).attr("stroke", finalStroke).attr("stroke-width", finalStrokeWidth);
                });

             staticCircles.push(circles); // Keep track of static circle selections
             return circles; // Return the selection
         }



        d3.csv("scatter.csv", d3.autoType).then(data => {
            // Filter data: ensure essential fields exist and are valid numbers where needed
            allDataGlobal = data.filter(d =>
                d.Castigator &&
                d.uat &&
                d.jud // Also ensure 'jud' exists for the keying function
            );

            // Data Cleaning Loop
            allDataGlobal.forEach(d => {
                // Helper function to handle conversion and invalid values
                const checkAndConvert = (value) => {
                    if (value === "#N/A" || value === "#DIV/0!") {
                        return null;
                    }
                    if (value != null && typeof value === 'string') {
                         // Ensure it's a string before replacing, handle potential non-string types gracefully
                        const cleanedValue = parseFloat(String(value).replace(",", "."));
                        return isNaN(cleanedValue) ? null : cleanedValue;
                    }
                     if (value == null || isNaN(value)) {
                         return null; // Ensure it's null if missing or NaN after potential d3.autoType
                    }
                    return value; // Return original number if already valid
                };

                // List of fields to clean (numeric indicators, coords, percentages, turnout)
                const fieldsToClean = [
                     "Procent castigator", "Prezenta",
                     "Lat", "Long",
                     "Procent plecari din populatie (2023)",
                     "Suprafata locuibila/cap de locuitor (m patrati) 2023",
                     "Numarul de salariati raportat la populatie (% din populatie) 2023",
                     "Cote de impozit raportat la populatie (2022)",
                     "Fonduri pe cap de locuitor (2022)",
                     "Pacienti la un medic 2023",
                     "Varsta medie a populatiei in 2023",
                     "Ponderea somerilor in 2023"
                 ];

                fieldsToClean.forEach(field => {
                    if (d.hasOwnProperty(field)) { // Check if the property exists on the object
                        d[field] = checkAndConvert(d[field]);
                    } else {
                         d[field] = null; // Ensure field exists even if missing in CSV row, set to null
                    }
                });

            });
            // End Data Cleaning Loop

            // --- Scatter Plot Configurations with newline characters (\n) in quadLabels ---
            const scatterConfig1 = {
                id: "scatter-viz-1", // Added ID for lookup
                xField: "Varsta medie a populatiei in 2023", yField: "Suprafata locuibila/cap de locuitor (m patrati) 2023", xLabel: "Vârsta medie", yLabel: "Suprafață/loc.", xUnit: " ani", yUnit: " m²", xDecimals: 1, yDecimals: 1,
                title: "Vârsta medie a populației și suprafața locuibilă/cap de locuitor",
                xLabelFull: "Vârsta medie a populației (ani)", yLabelFull: "Suprafață locuibilă/locuitor (m²)",
                quadLabels: {
                    I: "I. Suburbii sau localități \nperiurbane prospere, \nspațiu mare", II: "II. Localități îmbătrânite\n sau zone turistice rurale",
                    III: "III. Orașe cu cartiere \naglomerate/densitate mare", IV: "IV. Zone rurale sărace \ncu pop. vârstnică"
                }
            };
            const scatterConfig2 = {
                id: "scatter-viz-2", // Added ID for lookup
                xField: "Procent plecari din populatie (2023)", yField: "Ponderea somerilor in 2023", xLabel: "Plecări", yLabel: "Șomeri", xUnit: "%", yUnit: "%", xDecimals: 1, yDecimals: 1,
                title: "Plecările din localitate și ponderea șomerilor",
                xLabelFull: "Procent plecări din populație (%)", yLabelFull: "Pondere șomeri în populație (%)",
                quadLabels: {
                    I: "I. Zone unde populația \nrămâne din lipsă \nde alternative", II: "II. Zone aflate \nîn declin economic sever",
                    III: "III. Zone stabile economic", IV: "IV. Zone dinamice, \ndar tranzitorii"
                }
            };
            const scatterConfig3 = {
                 id: "scatter-viz-3", // Added ID for lookup
                xField: "Numarul de salariati raportat la populatie (% din populatie) 2023", yField: "Cote de impozit raportat la populatie (2022)", xLabel: "Salariați", yLabel: "Impozit/loc.", xUnit: "%", yUnit: " lei", xDecimals: 1, yDecimals: 0,
                title: "Salariați vs. Venituri din Impozite",
                xLabelFull: "Salariați / Populație (%)", yLabelFull: "Cote impozit / Populație (lei/loc.)",
                quadLabels: {
                    I: "I. Comunități mici/turistice \nsau cu venituri speciale", II: "II. Economie solidă, \ncolectare fiscală eficientă",
                    III: "III. Zone sărace, \nfără activitate economică", IV: "IV. Zone industriale \nsau muncitorești \ncu salarii mici"
                }
            };
            const scatterConfig4 = {
                 id: "scatter-viz-4", // Added ID for lookup
                xField: "Fonduri pe cap de locuitor (2022)", yField: "Pacienti la un medic 2023", xLabel: "Fonduri UE/loc.", yLabel: "Pacienți/medic", xUnit: " lei", yUnit: "", xDecimals: 0, yDecimals: 0,
                title: "Fonduri Europene vs. Acces la Medici",
                xLabelFull: "Fonduri europene / Locuitor (lei)", yLabelFull: "Număr pacienți / medic",
                quadLabels: {
                    I: "I. Zone sărace, \nfără fonduri", II: "II. Investiții recente \nfără impact asupra sistemului medical",
                    III: "III. Zone izolate, populație \nmică sau posibile excepții", IV: "IV. Investiții consistente, \ninfrastructură bună"
                }
            };
            // --- End Scatter Plot Configurations ---


            // Set the first config as the one for the main interactive scatter
            mainScatterConfig = scatterConfig1;
            // Pre-calculate medians for the main scatter config using ALL valid data points
             if (allDataGlobal && allDataGlobal.length > 0) {
                // Filter for valid data points *just for median calculation*
                 const validDataForMedianX = allDataGlobal.map(d => d[mainScatterConfig.xField]).filter(v => v != null && !isNaN(v) && typeof v === 'number');
                 const validDataForMedianY = allDataGlobal.map(d => d[mainScatterConfig.yField]).filter(v => v != null && !isNaN(v) && typeof v === 'number');
                 mainScatterConfig._xMedian = validDataForMedianX.length > 0 ? d3.median(validDataForMedianX) : undefined;
                 mainScatterConfig._yMedian = validDataForMedianY.length > 0 ? d3.median(validDataForMedianY) : undefined;
             } else {
                 mainScatterConfig._xMedian = undefined;
                 mainScatterConfig._yMedian = undefined;
             }

            // Setup scales for map view and circle size
            // Ensure valid data for extents
             const validPercentagesMap = allDataGlobal.map(d => d["Procent castigator"]).filter(p => p != null && !isNaN(p));
             let areaScale;
             if (validPercentagesMap.length > 0) {
                 const extent = d3.extent(validPercentagesMap);
                 if (extent[0] !== undefined && extent[1] !== undefined) {
                     areaScale = d3.scaleSqrt().domain(extent).range([baseCircleDiameter * 0.8, baseCircleDiameter * 2.2]);
                 }
             }

             const validLongs = allDataGlobal.map(d => d.Long).filter(l => l != null && !isNaN(l));
             const validLats = allDataGlobal.map(d => d.Lat).filter(l => l != null && !isNaN(l));
             let xGeo, yGeo;
             if (validLongs.length > 0 && validLats.length > 0) {
                 xGeo = d3.scaleLinear().domain(d3.extent(validLongs)).range([marginMain.left, mainWidth - marginMain.right]);
                 yGeo = d3.scaleLinear().domain(d3.extent(validLats)).range([mainHeight - marginMain.bottom, marginMain.top]);
             }


            createSpherePositions(allDataGlobal, 250); // Calculate sphere positions

            // Create main circles (initially positioned for sphere)
            mainCircles = chartMain.selectAll("circle.main-circle")
                .data(allDataGlobal, d => d.uat + d.jud) // Key for object constancy
                .enter().append("circle")
                .attr("class", "data-circle main-circle") // Add main class
                .attr("fill", d => colorScale(d.Castigator) || "#999") // Use colorScale, default grey
                .attr("opacity", 0) // Start invisible
                .style("pointer-events", "auto") // Allow interactions
                .on("mouseover", (event, d) => {
                     tooltip.style("opacity", 1);
                     let configForTooltip = mainScatterConfig; // Default to main
                      // Determine relevant config based on view/scroll for tooltip
                      const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);
                      if (mainChartOpacity < 0.5 && staticPlotsVisible && activeStaticPlotConfig) {
                          configForTooltip = activeStaticPlotConfig;
                      } else if (currentView !== 'scatter'){
                          configForTooltip = null; // Use basic tooltip if not scatter relevant
                      }

                     // Show tooltip based on current view/config
                     if (currentView === 'sphere' || currentView === 'map' || !configForTooltip) {
                         tooltip.html(basicTooltip(d));
                     } else { // Scatter view or static plot relevant
                         const xVal = d[configForTooltip.xField], yVal = d[configForTooltip.yField];
                         // Show scatter tooltip only if data is valid for the *relevant* config, else basic
                         if (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) {
                             tooltip.html(scatterTooltip(d, configForTooltip));
                         } else {
                             tooltip.html(basicTooltip(d)); // Fallback
                         }
                     }
                     // Highlight on hover
                     d3.select(event.currentTarget).raise().attr("stroke", "#000").attr("stroke-width", currentView === 'sphere' ? 2.5 : 2);
                 })
                .on("mousemove", updateTooltipPosition)
                .on("mouseout", (event, d) => {
                    tooltip.style("opacity", 0); // Hide tooltip
                    // Determine persistent stroke based on filters/search/quadrant
                    const searchTerm = normalize(d3.select("#search-input").property("value"));
                    const isSearching = searchTerm.length > 0;
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                    const isHighlightedByFilter = currentFilter !== "all" && d.Castigator === currentFilter;
                    let inActiveQuadHighlight = false;
                     if (currentView === 'scatter' && activeQuad !== 'all') {
                         const config = mainScatterConfig; // Quadrant highlight is only for main scatter
                          // Add checks for config and fields
                          if (config && config.xField && config.yField) {
                            const xVal = d[config.xField], yVal = d[config.yField];
                            const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                            if (hasValidScatterData && isPointInQuad(d, config, activeQuad)) {
                                inActiveQuadHighlight = true;
                            }
                          }
                     }

                    let finalStroke = "none", finalStrokeWidth = 0;
                    if (exactSearchMatch) {
                        finalStroke = "#FFFFFF"; finalStrokeWidth = 3;
                    } else if (isHighlightedByFilter) {
                        finalStroke = "#FFFFFF"; finalStrokeWidth = 1;
                    } else if (inActiveQuadHighlight) {
                        finalStroke = "#FFFFFF"; finalStrokeWidth = 1;
                    }
                    // Apply persistent stroke state
                    d3.select(event.currentTarget).attr("stroke", finalStroke).attr("stroke-width", finalStrokeWidth);
                });

            updateSphereVisuals(); // Initial sphere rendering
            sphereAnimation.play(); // Start animation

            // --- Setup Search and Filters ---
            const datalist = document.getElementById("localitati-list");
            // Populate datalist for search suggestions
            [...new Set(allDataGlobal.map(d => d.uat).filter(Boolean))] // Get unique UAT names
                .sort((a, b) => a.localeCompare(b, "ro-RO")) // Sort alphabetically
                .forEach(name => {
                    const opt = document.createElement("option");
                    opt.value = name;
                    datalist.appendChild(opt);
                });

            // Attach event listeners for search/filter controls
            d3.select("#search-input").on("input", applyGlobalFilterAndSearch);
            d3.select("#clear-search").on("click", () => {
                d3.select("#search-input").property("value", ""); // Clear input
                applyGlobalFilterAndSearch(); // Re-apply filters
            });
            d3.select("#winner-filter").on("change", applyGlobalFilterAndSearch);
            // Add event listener for the popup close button
            closeSummaryButton.on("click", hideSummaryPopup);


            // --- Create Static Scatter Plots ---
            staticCircles = []; // Reset array holding static circle selections
            staticConfigs = {}; // Reset object holding static configs (keyed by SVG ID)
            createScatterPlot("#scatter-viz-1", allDataGlobal, scatterConfig1);
            createScatterPlot("#scatter-viz-2", allDataGlobal, scatterConfig2);
            createScatterPlot("#scatter-viz-3", allDataGlobal, scatterConfig3);
            createScatterPlot("#scatter-viz-4", allDataGlobal, scatterConfig4); // This now uses cleaned data
            applyGlobalFilterAndSearch(); // Apply initial filter state to static plots


            // --- View Transition Functions ---
            function toSphere() {
                if (currentView === 'sphere') return; // Avoid redundant transitions
                hideSummaryPopup(); // Hide popup when changing view
                activeStaticPlotConfig = null; // Reset active static plot
                console.log("Transitioning to Sphere");
                currentView = "sphere";
                window.IO?.disconnect(); // DEACTIVATE Intersection Observer for steps
                activeQuad = 'all'; // Reset quadrant highlighting
                observerInitialized = false; // Reset IO flag
                sphereAnimation.play(); // Resume sphere rotation
                updateSearchControlsVisibility(); // Show/hide search based on view
                // Remove non-sphere elements (axes, titles, lines, labels, etc.)
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();
                updateSphereVisuals(); // Trigger sphere position update and filter application
            }

            function toMap() {
                if (currentView === 'map' || !xGeo || !yGeo) return; // Avoid redundant transitions or if scales aren't set
                hideSummaryPopup(); // Hide popup when changing view
                 activeStaticPlotConfig = null; // Reset active static plot
                console.log("Transitioning to Map");
                currentView = "map";
                window.IO?.disconnect(); // DEACTIVATE Intersection Observer for steps
                activeQuad = 'all'; // Reset quadrant highlighting
                observerInitialized = false; // Reset IO flag
                sphereAnimation.pause(); // Pause sphere rotation
                updateSearchControlsVisibility(); // Show/hide search based on view
                // Remove non-map elements
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();
                // Add Map Titles
                svgMain.append("text").attr("class", "map-title")
                    .attr("x", mainWidth / 2).attr("y", marginMain.top / 2)
                    .text("Distribuția câștigătorilor pe localități");
                svgMain.append("text").attr("class", "map-subtitle")
                    .attr("x", mainWidth / 2).attr("y", marginMain.top / 2 + 22)
                    .text("Dimensiunea cercurilor indică procentul obținut de câștigător.");

                // Transition main circles to map positions
                mainCircles.transition("mapPos").duration(1500).ease(d3.easeCubicInOut)
                    .attr("cx", d => (d.Long != null && !isNaN(d.Long) && isFinite(xGeo(d.Long))) ? xGeo(d.Long) : -100) // Use geo coords or hide
                    .attr("cy", d => (d.Lat != null && !isNaN(d.Lat) && isFinite(yGeo(d.Lat))) ? yGeo(d.Lat) : -100) // Use geo coords or hide
                    .attr("r", d => (d.Lat != null && d.Long != null && areaScale && d["Procent castigator"] != null && !isNaN(d["Procent castigator"])) ? areaScale(d["Procent castigator"]) : 0) // Use area scale or hide
                    .end().then(applyGlobalFilterAndSearch).catch(err => { // Apply filters after transition
                        console.error("Map transition error:", err);
                        applyGlobalFilterAndSearch(); // Ensure filters applied even on error
                    });
                applyGlobalFilterAndSearch(); // Apply filters immediately for responsiveness
            }

            function toScatter() {
                if (currentView === 'scatter') return; // Avoid redundant transitions
                // Hide initially, applyGlobalFilterAndSearch will show if needed based on main config
                hideSummaryPopup();
                 activeStaticPlotConfig = null; // Reset active static plot
                console.log("Transitioning to Main Scatter");
                currentView = "scatter";
                sphereAnimation.pause(); // Pause sphere rotation
                updateSearchControlsVisibility(); // Show/hide search based on view
                // Remove non-scatter elements
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();

                const config = mainScatterConfig; // Use the pre-defined main config
                 // Check config validity
                 if (!config || !config.xField || !config.yField) {
                     console.error("Main scatter config invalid for transition.");
                     return; // Abort transition if config is bad
                 }
                // Define inner dimensions using main margins
                const innerWidth = mainWidth - marginMain.left - marginMain.right;
                const innerHeight = mainHeight - marginMain.top - marginMain.bottom;

                // Filter data for valid points for extent calculation
                 const validScatterData = allDataGlobal.filter(d =>
                     d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number' &&
                     d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number'
                 );

                 if (validScatterData.length === 0) {
                     console.warn("No valid data points for the main scatter plot.");
                     // Optionally display a message on the SVG
                     svgMain.append("text").attr("x", mainWidth/2).attr("y", mainHeight/2).attr("text-anchor", "middle").attr("fill", "#ccc").text("Date insuficiente pentru acest grafic.");
                     return; // Abort if no data
                 }

                // Setup scales using main scatter config and dimensions
                const xExtent = d3.extent(validScatterData, d => d[config.xField]);
                const yExtent = d3.extent(validScatterData, d => d[config.yField]);
                const xDomain = (xExtent[0] === undefined || xExtent[1] === undefined) ? [0, 1] : xExtent;
                const yDomain = (yExtent[0] === undefined || yExtent[1] === undefined) ? [0, 1] : yExtent;
                // Scales map data to SVG coordinates within the main margins
                const x = d3.scaleLinear().domain(xDomain).nice().range([marginMain.left, mainWidth - marginMain.right]);
                const y = d3.scaleLinear().domain(yDomain).nice().range([mainHeight - marginMain.bottom, marginMain.top]); // Inverted for SVG y-axis

                const xMedian = config._xMedian; // Use cached median from allDataGlobal
                const yMedian = config._yMedian; // Use cached median from allDataGlobal

                 // --- Draw Axes, Titles, Median Lines for main plot ---
                 svgMain.append("text").attr("class", "plot-title") // Use svgMain for main title
                     .attr("x", mainWidth / 2)
                     .attr("y", marginMain.top / 2) // Position above plot
                     .text(config.title);
                 svgMain.append("g").attr("class", "x-axis axis")
                     .attr("transform", `translate(0,${mainHeight - marginMain.bottom})`) // Positioned at bottom
                     .call(d3.axisBottom(x).ticks(7));
                 svgMain.append("text").attr("class", "x-label axis-label")
                     .attr("x", mainWidth / 2).attr("y", mainHeight - 20) // Adjusted Y slightly
                     .text(config.xLabelFull || config.xLabel); // Use full label if available
                 svgMain.append("g").attr("class", "y-axis axis")
                     .attr("transform", `translate(${marginMain.left},0)`) // Positioned at left
                     .call(d3.axisLeft(y).ticks(7));
                 svgMain.append("text").attr("class", "y-label axis-label")
                     .attr("transform", "rotate(-90)") // Rotated for y-axis
                     .attr("x", -(marginMain.top + innerHeight / 2)) // Centered along y-axis height
                     .attr("y", marginMain.left - 60) // Adjusted Y slightly
                     .text(config.yLabelFull || config.yLabel); // Use full label if available
                 // Draw median lines if valid
                 if (xMedian !== undefined && xMedian !== null && isFinite(x(xMedian))) {
                     svgMain.append("line").attr("class", "quadrant-line")
                         .attr("x1", x(xMedian)).attr("x2", x(xMedian))
                         .attr("y1", marginMain.top).attr("y2", mainHeight - marginMain.bottom); // Vertical line
                 }
                 if (yMedian !== undefined && yMedian !== null && isFinite(y(yMedian))) {
                     svgMain.append("line").attr("class", "quadrant-line")
                         .attr("x1", marginMain.left).attr("x2", mainWidth - marginMain.right)
                         .attr("y1", y(yMedian)).attr("y2", y(yMedian)); // Horizontal line
                 }

                 // --- Draw Quadrant Labels OUTSIDE the plot area using TSPAN for wrapping ---
                 const isMobileMain = window.innerWidth <= 600;
                 // Adjusted padding values for larger/multi-line labels in main plot
                 const mainOuterLabelPadding = isMobileMain ? 12 : 18; // Increased padding from plot edge
                 const mainOuterLabelYOffset = isMobileMain ? -15 : -22; // Increased negative offset for top labels
                 const mainOuterLabelYOffsetBottom = isMobileMain ? 20 : 30; // Increased positive offset for bottom labels


                 if (config.quadLabels && xMedian !== undefined && yMedian !== undefined && xMedian !== null && yMedian !== null && isFinite(x(xMedian)) && isFinite(y(yMedian))) {
                     const mainLabelData = [
                         { quad: 'II', anchor: 'end', xPos: mainWidth - marginMain.right + mainOuterLabelPadding, yPos: marginMain.top + mainOuterLabelYOffset }, // Top Right
                         { quad: 'I', anchor: 'start', xPos: marginMain.left - mainOuterLabelPadding, yPos: marginMain.top + mainOuterLabelYOffset },   // Top Left
                         { quad: 'III', anchor: 'start', xPos: marginMain.left - mainOuterLabelPadding, yPos: mainHeight - marginMain.bottom + mainOuterLabelYOffsetBottom }, // Bottom Left
                         { quad: 'IV', anchor: 'end', xPos: mainWidth - marginMain.right + mainOuterLabelPadding, yPos: mainHeight - marginMain.bottom + mainOuterLabelYOffsetBottom } // Bottom Right
                     ];


                     mainLabelData.forEach(lbl => {
                         const labelText = config.quadLabels[lbl.quad];
                          if (!labelText) return; // Skip if label text is missing

                         const lines = labelText.split('\n'); // Split by newline
                         const textElement = svgMain.append("text") // Append directly to svgMain
                             .attr("class", "quadrant-label quadrant-label-outer") // Use updated class
                             .attr("x", lbl.xPos)
                             .attr("y", lbl.yPos) // Base y position
                             .attr("text-anchor", lbl.anchor);

                         // Append tspans for each line
                         lines.forEach((line, i) => {
                             textElement.append("tspan")
                                 .attr("x", lbl.xPos) // Re-apply x for each tspan
                                 .attr("dy", i === 0 ? "0" : "1.1em") // Vertical spacing
                                 .text(line);
                         });
                     });
                 }
                 // --- END NEW Quadrant Labels (Main Plot) ---


                 // --- Draw Quadrant Overlays (for highlighting) ---
                 const overlays = svgMain.selectAll(".quadrant-overlay").data(["I","II","III","IV"]);
                 overlays.enter().append("rect")
                    .attr("class","quadrant-overlay")
                    .merge(overlays)
                    .attr("opacity", 0) // Start hidden
                    .attr("pointer-events","none") // Not interactive
                    .each(function(q){ // Calculate position and size for each quadrant overlay
                        if (xMedian === undefined || yMedian === undefined || xMedian === null || yMedian === null || !isFinite(x(xMedian)) || !isFinite(y(yMedian))) return; // Skip if medians/scales invalid
                        const isLeft = q==="I" || q==="III";
                        const isTop = q==="I" || q==="II";
                        // Calculate position based on margins and median lines
                        const xPos = isLeft ? marginMain.left : x(xMedian);
                        const yPos = isTop ? marginMain.top : y(yMedian);
                        // Calculate width/height based on margins and median lines
                        const width = Math.max(0, isLeft ? x(xMedian)-marginMain.left : mainWidth-marginMain.right-x(xMedian));
                        const height = Math.max(0, isTop ? y(yMedian)-marginMain.top : mainHeight-marginMain.bottom-y(yMedian));
                        // Apply dimensions only if valid numbers
                        if (isFinite(xPos) && isFinite(yPos) && isFinite(width) && width >= 0 && isFinite(height) && height >= 0) {
                            d3.select(this).attr("x", xPos).attr("y", yPos).attr("width", width).attr("height", height);
                        } else {
                            // Fallback if calculation fails
                            d3.select(this).attr("width", 0).attr("height", 0);
                        }
                 });

                 // --- Transition Main Circles to Scatter Positions ---
                 mainCircles.transition("scatterPos").duration(1500).ease(d3.easeCubicInOut)
                    // Position circles using scatter scales, hide if data invalid
                    .attr("cx", d => {
                        // Only calculate position if data is valid for this plot
                        const xVal = d[config.xField];
                        return (xVal != null && !isNaN(xVal) && typeof xVal === 'number' && isFinite(x(xVal))) ? x(xVal) : -100;
                    })
                    .attr("cy", d => {
                        // Only calculate position if data is valid for this plot
                        const yVal = d[config.yField];
                        return (yVal != null && !isNaN(yVal) && typeof yVal === 'number' && isFinite(y(yVal))) ? y(yVal) : -100;
                    })
                    // Set radius, hide if data invalid
                    .attr("r", d => {
                         // Only set radius if data is valid for this plot
                         const xVal = d[config.xField], yVal = d[config.yField];
                         return (xVal != null && !isNaN(xVal) && typeof xVal === 'number' && yVal != null && !isNaN(yVal) && typeof yVal === 'number') ? baseCircleDiameter * 1.1 : 0;
                    })
                    .end().then(() => {
                         // After transition: apply filters and setup Intersection Observer
                         console.log("Scatter transition finished. Setting up IO.");
                         applyGlobalFilterAndSearch(); // Apply filters which will hide non-relevant points and potentially show popup
                         setupIntersectionObserver(config); // Pass the correct config
                    }).catch(err => {
                         // Handle transition errors
                         console.error("Scatter transition error:", err);
                         applyGlobalFilterAndSearch(); // Ensure filters are applied (and popup logic runs)
                         setupIntersectionObserver(config); // Still try to setup IO
                    });
                applyGlobalFilterAndSearch(); // Apply filters immediately for responsiveness (and popup logic)
            }


            // --- Intersection Observer for Scroll Steps (Main Scatter Quadrants) ---
            const steps = document.querySelectorAll("#scatter-steps .step");

            function setupIntersectionObserver(config) { // Expects mainScatterConfig
                window.IO?.disconnect(); // Disconnect previous observer if exists
                observerInitialized = false; // Reset flag
                 // Check if config is valid before setting up
                 if (!config || !config.xField || !config.yField) {
                     console.error("[IO Setup] Aborting: Invalid config provided.");
                     return;
                 }
                console.log("[IO] Setting up Intersection Observer for Steps");

                window.IO = new IntersectionObserver(entries => {
                    // Ignore callbacks if not in scatter view OR if main chart is faded out
                    const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);
                    if (currentView !== 'scatter' || mainChartOpacity < 0.1) return;


                    const minVisibilityThreshold = 0.05; // Minimum ratio to be considered "visible"

                    // Find the step elements that are currently intersecting above the threshold
                    const visibleSteps = entries.filter(entry =>
                        entry.isIntersecting && entry.intersectionRatio >= minVisibilityThreshold
                    );

                    let highestVisibleStep = null;
                    if (visibleSteps.length > 0) {
                        // Sort visible steps by their top position (lowest top value = highest on screen)
                        visibleSteps.sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top);
                        // The first one in the sorted list is the highest visible step
                        highestVisibleStep = visibleSteps[0].target;
                    }

                    // Determine the quadrant associated with the highest visible step, default to 'all'
                    const nextActiveQuad = highestVisibleStep ? highestVisibleStep.dataset.quad : 'all';

                    // Only update if the active quadrant changes
                    if (nextActiveQuad !== activeQuad) {
                        console.log(`[IO Callback Steps] *** Changing highlight: ${activeQuad} -> ${nextActiveQuad} *** (Highest visible: ${highestVisibleStep ? highestVisibleStep.dataset.quad : 'None'})`);
                        activeQuad = nextActiveQuad; // Update the global state
                        renderHighlight(activeQuad, config); // Render the highlight effect
                    }
                }, {
                    // Use multiple thresholds to trigger callback frequently during scroll
                    threshold: Array.from({ length: 21 }, (_, i) => i * 0.05) // [0, 0.05, 0.1, ..., 1.0]
                });

                // Observe each step element
                steps.forEach(s => window.IO.observe(s));
                console.log("[IO] Observer attached to steps.");

                 // Initial check in case a step is already visible on load/transition
                 if (!observerInitialized) {
                      console.log("[IO Initial Check Steps] Scheduling...");
                      // Use setTimeout to allow layout settling after transition
                      setTimeout(() => {
                         // Abort if view changed or config became invalid during timeout
                           const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);
                         if (currentView !== 'scatter' || !config || !config.xField || !config.yField || mainChartOpacity < 0.1) {
                            console.log("[IO Initial Check Steps] Aborted, view/config/opacity changed.");
                            return;
                         }
                         console.log("[IO Initial Check Steps] Running...");

                         const minVisibilityThreshold = 0.05;
                         const currentVisibleSteps = [];
                         // Manually check visibility of each step
                         steps.forEach(step => {
                            const rect = step.getBoundingClientRect();
                            // Check if vertically within viewport
                            const isIntersecting = rect.top < window.innerHeight && rect.bottom > 0;
                            if (isIntersecting) {
                                // Calculate approximate intersection ratio
                                const visibleHeight = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
                                const ratio = Math.max(0, Math.min(1, visibleHeight / rect.height));
                                if (ratio >= minVisibilityThreshold) {
                                    // Store step and its top position if visible enough
                                    currentVisibleSteps.push({ target: step, top: rect.top });
                                }
                            }
                         });

                         let initialHighestStep = null;
                         if (currentVisibleSteps.length > 0) {
                             // Find the highest visible step (lowest top value)
                             currentVisibleSteps.sort((a, b) => a.top - b.top);
                             initialHighestStep = currentVisibleSteps[0].target;
                         }

                         // Determine the initial quadrant based on the highest visible step
                         const initialActiveQuad = initialHighestStep ? initialHighestStep.dataset.quad : 'all';
                         console.log(`[IO Initial Check Steps] Determined initial quad: ${initialActiveQuad}.`);

                         // Update state and render highlight only if different from default
                         if (initialActiveQuad !== activeQuad) {
                              console.log(`[IO Initial Check Steps] *** Setting initial highlight: ${activeQuad} -> ${initialActiveQuad} ***`);
                              activeQuad = initialActiveQuad;
                         }
                         renderHighlight(activeQuad, config); // Render initial highlight state
                         observerInitialized = true; // Mark as initialized
                     }, 350); // Delay to ensure transitions/layout are stable
                 }
             }

            function renderHighlight(quad, config) { // Expects mainScatterConfig
                // Guard against rendering if not in scatter view or SVG/config is gone
                if (currentView !== 'scatter' || !svgMain || !svgMain.node() || !config || !config.xField || !config.yField) {
                    console.warn(`[RenderHighlight] Aborting. View: ${currentView}, SVG exists: ${!!svgMain?.node()}, Config valid: ${!!(config && config.xField && config.yField)}`);
                    if (currentView !== 'scatter') activeQuad = 'all'; // Reset if view changed
                    return;
                }
                 // Also abort if main chart is faded out (static plots are primary)
                 const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);
                 if (mainChartOpacity < 0.1) {
                     console.log("[RenderHighlight] Aborting, main chart faded.");
                      activeQuad = 'all'; // Reset quadrant if main chart not visible
                      // Ensure overlays are hidden if chart fades while quad is active
                      svgMain.selectAll(".quadrant-overlay").transition("overlayFadeOut").duration(100).attr("opacity", 0);
                     return;
                 }

                console.log(`[RenderHighlight] Rendering for quad: ${quad}`);
                // Transition the opacity of the quadrant overlays
                svgMain.selectAll(".quadrant-overlay")
                    .filter(qData => qData) // Ensure data is bound
                    .transition("overlayHighlight").duration(300)
                    // Show the overlay for the active quad, hide others
                    .attr("opacity", qData => (quad === "all") ? 0 : (qData === quad ? 0.12 : 0));

                // Re-apply global filters/search, which now includes quadrant dimming logic
                applyGlobalFilterAndSearch();
            }


            // --- Scroll Listener for View Changes ---
            const chartWrapper = document.querySelector('.chart-wrapper');
            const scatterStepsSection = document.getElementById('scatter-steps');

            window.addEventListener("scroll", () => {
                const y = window.scrollY;
                const wh = window.innerHeight;
                // Exit if essential elements aren't found
                if (!chartWrapper || !scatterStepsSection) return;

                // Get positions and dimensions needed for calculations
                const wrapperRect = chartWrapper.getBoundingClientRect();
                const stepsRect = scatterStepsSection.getBoundingClientRect();
                const wrapperTop = wrapperRect.top + y; // Absolute top position of wrapper
                const stepsTop = stepsRect.top + y;     // Absolute top position of steps section
                const wrapperHeight = chartWrapper.offsetHeight;

                // Define scroll thresholds for changing views
                // Transition to Map when 1/3 of the wrapper has scrolled past the bottom of the viewport
                const mapStartPoint = wrapperTop + wrapperHeight * 0.33 - wh;
                // Transition to Scatter when the top of the steps section is about 60% up the viewport
                const scatterStartPoint = stepsTop - wh * 0.6;

                let targetView; // Determine the target view based on scroll position

                if (y < mapStartPoint) {
                    targetView = "sphere";
                } else if (y >= mapStartPoint && y < scatterStartPoint) {
                    targetView = "map";
                } else { // y >= scatterStartPoint
                    targetView = "scatter";
                }

                // If the target view is different from the current view, trigger the transition
                if (targetView !== currentView) {
                    console.log(`Scroll Trigger: Changing view from ${currentView} to ${targetView} (y=${y.toFixed(0)}, mapStart=${mapStartPoint.toFixed(0)}, scatterStart=${scatterStartPoint.toFixed(0)})`);
                    if (targetView === "sphere") toSphere();
                    else if (targetView === "map") toMap();
                    else if (targetView === "scatter") toScatter();
                }

                // Update search controls visibility based on the current view
                updateSearchControlsVisibility();

                // Hide intro overlay when scrolling down or not in sphere view
                const intro = document.getElementById("sphere-intro");
                if (intro) {
                    if (y < 80 && currentView === 'sphere') intro.classList.remove("hidden");
                    else intro.classList.add("hidden");
                }

            }, { passive: true }); // Use passive listener for better scroll performance


            // --- Intersection Observer for Fading Main Chart ---
            const chartContainer = document.getElementById("chart-container");
            const staticPlotsSection = document.getElementById("flourish-block");

             if (chartContainer && staticPlotsSection) {
                new IntersectionObserver(
                    entries => {
                        const staticPlotsEntry = entries[0];
                        const fadeStartRatio = 0.05; // Start fading when 5% visible
                        const fadeEndRatio = 0.25; // Fully faded when 25% visible
                        let opacity = 1; // Default opacity

                         const oldStaticPlotsVisible = staticPlotsVisible; // Store previous state
                        staticPlotsVisible = staticPlotsEntry.isIntersecting; // Update visibility flag

                        if (staticPlotsEntry.isIntersecting) {
                            // Calculate opacity based on intersection ratio within the fade range
                            const ratio = staticPlotsEntry.intersectionRatio;
                            if (ratio >= fadeStartRatio) {
                                opacity = 1 - Math.min(1, Math.max(0, (ratio - fadeStartRatio) / (fadeEndRatio - fadeStartRatio)));
                            }
                        } else if (staticPlotsEntry.boundingClientRect.top < 0) {
                            // If scrolled past (top is negative), force opacity to 0
                            opacity = 0;
                            staticPlotsVisible = true; // Still consider static plots potentially active
                        } else {
                            // If not intersecting and above the viewport, opacity is 1
                            opacity = 1;
                            staticPlotsVisible = false;
                        }

                        // Apply opacity and pointer events
                        chartContainer.style.opacity = opacity;
                        chartContainer.style.pointerEvents = opacity < 0.5 ? "none" : "auto";

                        updateSearchControlsVisibility(); // Update search controls based on visibility

                        // Hide intro if chart starts fading
                        const intro = document.getElementById("sphere-intro");
                        if (intro && opacity < 0.8) intro.classList.add("hidden");

                         // If static plots just became visible or invisible, potentially trigger popup update
                         if (staticPlotsVisible !== oldStaticPlotsVisible) {
                             applyGlobalFilterAndSearch();
                         }

                        // Disconnect Intersection Observer for steps if main chart is mostly hidden
                        // And reset quad highlight
                        if (opacity < 0.1 && window.IO) {
                             console.log("Disconnecting Step IO due to main chart fade");
                             window.IO.disconnect();
                             activeQuad = 'all'; // Reset active quadrant
                             observerInitialized = false; // Reset IO flag
                             renderHighlight('all', mainScatterConfig); // Ensure highlight is off
                        } else if (opacity >= 0.1 && currentView === 'scatter' && !observerInitialized && window.IO) {
                             // Re-setup step observer if chart becomes visible again in scatter view
                             console.log("Re-enabling Step IO as main chart became visible");
                              setupIntersectionObserver(mainScatterConfig);
                        }
                    },
                    { threshold: Array.from({ length: 21 }, (_, i) => i * 0.05) } // Multiple thresholds for smooth fade calculation
                ).observe(staticPlotsSection); // Observe the static plots section
             }


            // --- START: Intersection Observer for Static Plot Containers ---
            const staticPlotContainers = document.querySelectorAll('.scatter-plot-container');
            if (staticPlotContainers.length > 0 && staticConfigs) {
                const staticPlotObserver = new IntersectionObserver(entries => {
                    // Only act if the static plots section is generally visible (main chart faded)
                    if (!staticPlotsVisible) {
                         // If static plots are no longer the primary focus, reset active config
                         if (activeStaticPlotConfig !== null) {
                             console.log("Static plots no longer primary, resetting activeStaticPlotConfig");
                             activeStaticPlotConfig = null;
                              applyGlobalFilterAndSearch(); // Update popup state
                         }
                        return;
                    }

                    let mostVisibleStaticPlot = null;
                    let maxRatio = -1;

                    entries.forEach(entry => {
                        if (entry.isIntersecting && entry.intersectionRatio > maxRatio) {
                            maxRatio = entry.intersectionRatio;
                            mostVisibleStaticPlot = entry.target;
                        }
                        // Basic visibility check: consider entry visible if any part intersects
                         // console.log(`Static plot ${entry.target.id} intersecting: ${entry.isIntersecting}, Ratio: ${entry.intersectionRatio.toFixed(2)}`);
                    });

                    let newActiveConfig = null;
                    if (mostVisibleStaticPlot) {
                        const chartId = mostVisibleStaticPlot.dataset.chartId; // Use data-chart-id
                        if (chartId && staticConfigs[chartId]) {
                            newActiveConfig = staticConfigs[chartId];
                             // console.log(`Most visible static plot: ${chartId}`);
                        }
                    }

                    // Update state and trigger popup redraw ONLY if the active config changes
                    if (newActiveConfig?.id !== activeStaticPlotConfig?.id) { // Compare based on unique ID
                         console.log(`[Static IO] Changing active static config: ${activeStaticPlotConfig?.id} -> ${newActiveConfig?.id}`);
                        activeStaticPlotConfig = newActiveConfig;
                        // Re-run filter/popup logic to update the popup content
                        applyGlobalFilterAndSearch();
                    }

                }, {
                    threshold: Array.from({ length: 11 }, (_, i) => i * 0.1), // Check at 10% intervals
                    rootMargin: "-10% 0px -30% 0px" // Prioritize plots in the middle-ish of the viewport
                });

                staticPlotContainers.forEach(container => staticPlotObserver.observe(container));
                 console.log("[Static IO] Observer attached to static plot containers.");
            }
            // --- END: Intersection Observer for Static Plot Containers ---


            // --- Intro Button ---
            const intro = document.getElementById("sphere-intro");
            const introOk = document.getElementById("intro-ok");
            if (intro && introOk) {
                function hideIntro() { intro.classList.add("hidden"); }
                introOk.addEventListener("click", hideIntro);
                // Optional: Hide intro on first scroll
                // window.addEventListener('scroll', hideIntro, { once: true });
            }

            // --- Initial View Setup on Load ---
            // Use setTimeout to ensure layout is stable before calculating positions
            setTimeout(() => {
                 const y = window.scrollY;
                 const wh = window.innerHeight;
                 // Check if elements exist before proceeding
                 if (!chartWrapper || !scatterStepsSection) {
                     console.error("Initial view check failed: Elements not found.");
                     toSphere(); // Default to sphere view
                     applyGlobalFilterAndSearch();
                     updateSearchControlsVisibility();
                     return;
                 }
                 // Recalculate positions (same logic as scroll handler)
                 const wrapperRect = chartWrapper.getBoundingClientRect();
                 const stepsRect = scatterStepsSection.getBoundingClientRect();
                 const wrapperTop = wrapperRect.top + y;
                 const stepsTop = stepsRect.top + y;
                 const wrapperHeight = chartWrapper.offsetHeight;
                 const mapStartPoint = wrapperTop + wrapperHeight * 0.33 - wh;
                 const scatterStartPoint = stepsTop - wh * 0.6;

                 let initialViewFunction = toSphere; // Default view

                 // Determine initial view based on current scroll position
                 if (y >= mapStartPoint && y < scatterStartPoint) {
                     initialViewFunction = toMap;
                 } else if (y >= scatterStartPoint) {
                     initialViewFunction = toScatter;
                 }

                 console.log(`Setting initial view: ${initialViewFunction.name} (y=${y.toFixed(0)}, mapStart=${mapStartPoint.toFixed(0)}, scatterStart=${scatterStartPoint.toFixed(0)})`);
                 initialViewFunction(); // Call the function to set the initial view

                 // Update search visibility after a short delay to ensure view is set
                 setTimeout(updateSearchControlsVisibility, 200);
                 // Run filter/popup logic after initial view setup
                 setTimeout(applyGlobalFilterAndSearch, 250);

                 // Handle initial intro visibility
                 const introElem = document.getElementById("sphere-intro");
                 if (introElem) {
                     if (y < 80 && currentView === 'sphere') {
                         introElem.classList.remove("hidden");
                     } else {
                         introElem.classList.add("hidden");
                     }
                 }
                 console.log("Initial view determined:", currentView);
            }, 150); // Short delay for safety


        }).catch(error => {
            // --- Error Handling ---
            console.error("Error loading or processing data:", error);
            // Display user-friendly error message
            document.body.innerHTML = `<div style="color: red; padding: 50px; text-align: center; font-size: 1.2em;">A apărut o eroare la încărcarea datelor (${error.message}). Vă rugăm reîncărcați pagina.</div>`;
        });

    </script>
    </body>
    </html>

