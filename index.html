<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Universul Românesc</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        *, *:before, *:after { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            overflow-x: hidden;
            background-color: #000;
            color: #fff;
        }

        .headline-wrapper {
            position: relative;
            z-index: 3;
            text-align: center;
            padding-top: 8vh;
            padding-bottom: 4vh;
            color: white;
        }

        .cosmic-supratitle {
            font-family: 'Roboto', sans-serif;
            font-size: 1.4em;
            font-weight: 300;
            color: white;
            text-shadow: 0 0 6px #88b5ff, 0 0 10px #5573d6;
            margin-bottom: 10px;
        }

        .cosmic-title {
            font-family: 'Roboto', sans-serif;
            font-size: 1.6em;
            font-weight: 400;
            padding: 0 6vw;
            line-height: 1.4;
            color: white;
            text-shadow: 0 0 6px #88b5ff, 0 0 12px #335bc4;
        }

        .text-container {
            max-width: 600px;
            margin: 0 auto;
            padding: 0 5vw;
            padding-top: 5vh;
            color: #fff;
        }

        p {
            text-align: center;
            font-size: 1em;
            margin: 1em 0;
        }


        .chart-wrapper {
            position: relative;
            height: 170vh;
            margin-bottom: 5vh;
        }

        .chart-container {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100vh;
            background: radial-gradient(ellipse at center, #0b1f4c 0%, #000000 100%);
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.6s ease;
        }


        .svg-inner {
            width: 100%;
            max-width: 1000px;
            position: relative;
        }
        svg {
            width: 100%;
            height: auto;
            display: block;
            background-color: transparent;
            overflow: visible;
        }


        .tooltip {
            position: absolute;
            background: rgba(255,255,255,0.95);
            border: 1px solid #aaa;
            padding: 0.85em 1em;
            font-size: 0.9em;
            pointer-events: none;
            opacity: 0;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            border-radius: 4px;
            max-width: 90vw;
            min-width: 80px;
            color: #333;
            transition: opacity 0.2s ease;
        }

        .top-spacer { height: 15vh; }


        #search-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 11;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            display: none;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            max-width: 90vw;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
        }
         #search-container.visible {
            display: block;
            opacity: 1;
            pointer-events: auto;
         }
        #search-input, #clear-search, #winner-filter {
            padding: 8px 12px;
            font-size: 0.9em;
            margin: 4px;
            border: 1px solid #555;
            border-radius: 5px;
            background-color: #333;
            color: #eee;
        }
        #search-input::placeholder { color: #aaa; }
        #clear-search {
            padding: 8px 10px;
            margin-left: 6px;
            cursor: pointer;
            background-color: #555;
            border-color: #777;
        }
         #clear-search:hover { background-color: #666; }
        #winner-filter {
            cursor: pointer;
            background-color: #333;
             border-color: #555;
             color: #eee;
             flex-grow: 1;
             min-width: 150px;
        }
        #search-container > div {
             display: flex;
             align-items: center;
             gap: 5px;
             flex-wrap: wrap;
         }
         #search-container > div:last-child { margin-top: 8px; }
         #search-container label {
             color: white;
             margin-right: 6px;
             font-size: 0.9em;
             white-space: nowrap;
         }


        #scatter-steps {
            position: relative;
            z-index: 5;

             margin-top: 100vh;
             padding-top: 1vh;
             padding-bottom: 5vh;
        }
        .step {
            position: relative;
            max-width: min(90vw, 340px);

            margin: 70vh auto;
            padding: 1.25em 1.5em;
            background: rgba(255,255,255,0.92);
            border-radius: 8px;
            font-size: .95em;
            line-height: 1.35;
            box-shadow: 0 2px 10px rgba(0,0,0,.25);
            color: #333;
        }

         .step:first-child { margin-top: 40vh; }
         .step:last-child { margin-bottom: 50vh; }


        #sphere-intro{
            position:fixed; inset:0; z-index:6; display:flex;
            flex-direction:column; justify-content:center; align-items:center;
            text-align:center; gap:1.5rem; font-family:'Roboto',sans-serif;
            background:rgba(0,0,0,0.88); color:#fff; opacity:1;
            pointer-events:auto; transition:opacity .6s ease;
        }
        #sphere-intro h2{font-size:1.4rem; margin:0;}
        #sphere-intro p {
    font-size: 1rem;
    line-height: 1.4;
    margin: 0;
    max-width: 600px;
    width: 90%;

    padding-left: 15px;
    padding-right: 15px;
    box-sizing: border-box;

    /* The <p> block itself will be centered by #sphere-intro's align-items: center */
}
        #sphere-intro button{
            padding:.6rem 1.4rem; font-size:1rem; border:none; border-radius:6px;
            background:rgb(0, 140, 255); color:#ffffff; cursor:pointer;
        }
        #sphere-intro.hidden{ opacity:0; pointer-events:none; }


        #flourish-block{
            padding: 10vh 0 6vh;
            background: #000;
            text-align:left;
            position:relative;
            z-index:3;
        }
        .scatter-plot-container {
            max-width: 950px;
            width: 92%;
            margin: 10vh auto;
            background-color: rgba(11, 31, 76, 0.2);
            border-radius: 8px;
            padding: 25px 15px 15px 15px;
            box-shadow: 0 0 15px rgba(136, 181, 255, 0.15);
        }
        .scatter-explainer {
            font-size: 1em; color: #ccc; margin-top: 10px;
            max-width: 850px; margin-left: auto; margin-right: auto;
            padding: 0 15px; line-height: 1.4; text-align: left;
            margin-top: 50px;


        }



        .axis path, .axis line { stroke: #aaa; stroke-width: 0.5; shape-rendering: crispEdges; }
        .axis text { fill: #ccc; font-weight: 300; font-size: 10px; }
        .axis-label { fill: #ddd; font-size: 0.85em; text-anchor: middle; }
        .plot-title { fill: #fff; font-size: 2em; font-weight: 600; text-anchor: middle; } /* Adjusted from 2em for balance */
        .map-title { fill: #fff; font-size: 2em; font-weight: 600; text-anchor: middle; }
        .map-subtitle { fill: #ccc; font-size: 0.9em; text-anchor: middle; }
        .quadrant-line { stroke: #ffffff; stroke-dasharray: 3 3; stroke-width: 1.5px; opacity: 0.8; }


        .quadrant-label {
            fill: #ffffff;
            font-size: 1em;
            font-weight: 400;
            opacity: 0.9;
         }
         .quadrant-label-outer {

             font-size: 1.4em;

             fill: #e0e0e0;
             font-weight: 500;
             opacity: 0.95;

             text-shadow: 0 0 3px rgba(0, 0, 0, 0.7);
             pointer-events: none;
         }

         .quadrant-label-outer tspan {

         }


         .quadrant-overlay {
             fill: #ffffff;
             opacity: 0;
             pointer-events: none;
             transition: opacity 0.3s ease;
         }


        #candidate-summary-popup {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(40, 40, 60, 0.95);
            border: 1px solid #777;
            border-radius: 8px;
            padding: 18px 25px;
            max-width: 400px;
            z-index: 12;
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            color: #eee;
            font-size: 0.9em;
            line-height: 1.45;
        }

        #candidate-summary-popup.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        #summary-text p {
            margin: 0 0 10px 0;
            text-align: left;
             font-size: inherit;
             color: inherit;
        }
         #summary-text strong {
             color: #fff;
         }
         #summary-text i {
             color: #bbb;
             font-style: normal;
             font-weight: 500;
         }

        #mini-chart-container {
            margin-top: 10px;
            height: 60px;
            width: 100%;
        }

        #mini-chart-svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        .mini-axis path, .mini-axis line {
            stroke: #888;
            stroke-width: 0.5;
            shape-rendering: crispEdges;
        }
        .mini-axis .tick text {
             fill: #ccc;
             font-size: 9px;
        }
        .mini-axis-label {
            fill: #ccc;
            font-size: 9px;
            text-anchor: middle;
        }
        .mini-bar {
            fill: #88b5ff;
            stroke: #fff;
            stroke-width: 0.5;
        }
        .mini-median-line {

            stroke-width: 1.5;
            stroke-dasharray: 2 2;
        }
         .mini-median-label {

             font-size: 10px;
             font-weight: bold;
         }

        #close-summary-popup {
            position: absolute;
            top: 5px;
            right: 8px;
            background: none;
            border: none;
            color: #ccc;
            font-size: 1.8em;
            line-height: 1;
            cursor: pointer;
            padding: 0 5px;
        }
        #close-summary-popup:hover {
            color: #fff;
        }



        @media (max-width: 600px) {
             #search-container {
                 top: 10px; left: 50%; right: auto; transform: translateX(-50%);
                 width: 90vw; max-width: 350px; padding: 8px 10px;
             }
             #search-container > div {
                 flex-direction: column; align-items: stretch; width: 100%; gap: 6px;
             }
             #search-input, #clear-search, #winner-filter, #search-container label {
                 font-size: 0.85em; width: 100%; margin: 0; box-sizing: border-box;
             }
             #search-input { padding: 7px 10px; }
              #clear-search { padding: 7px 10px; margin-top: 4px; }
             #search-container label { margin-bottom: 4px; text-align: center; margin-right: 0; }
             #winner-filter { padding: 7px 10px; min-width: 0; }
             #search-container > div:last-child { margin-top: 10px; }

            .scatter-plot-container {
                width: 98%; padding: 10px 5px 5px 5px; margin: 5vh auto; box-shadow: none;
            }
            .scatter-explainer { padding: 0 5px; font-size: 0.9em; margin-top: 30px; line-height: 1.3; }
             .plot-title { font-size: 1.1em; }
             .axis-label { font-size: 0.8em; }


             .quadrant-label {
                 font-size: 1.1em;
             }
             .quadrant-label-outer {
                  font-size: 1.1em;
                  text-shadow: 0 0 2px rgba(0, 0, 0, 0.6);
             }

             .axis text { font-size: 8px; }


            .step { margin: 60vh auto; }
            .step:first-child { margin-top: 30vh; }
            .step:last-child { margin-bottom: 40vh; }

            .map-title { font-size: 2em; }
            .map-subtitle { font-size: 1em; }
            .cosmic-title { font-size: 1.5em; }
            .cosmic-supratitle { font-size: 1.3em; }


            #candidate-summary-popup {
                left: 10px;
                right: 10px;
                bottom: 10px;
                max-width: none;
                width: auto;
                padding: 16px 20px;
                font-size: 0.85em;
            }
            #close-summary-popup {
                top: 3px;
                right: 5px;
                 font-size: 1.6em;
            }
             #mini-chart-container {
                 height: 50px;
             }
             .mini-axis-label { font-size: 8px; }
             .mini-median-label { font-size: 9px; }
             .mini-axis .tick text { font-size: 8px; }

             .scatter-plot-container svg .static-circle {
                 r: 5;
             }
        }


        body { min-height: 500vh; }
        html,body{ overscroll-behavior: none; }

        .highlight {
            background-color: rgb(0, 140, 255);
            color: #ffffff;
            padding: 0px 1px;
            border-radius: 0px;
        }

        a {
    color: rgb(0, 140, 255);
  }

  a:hover {
    color: rgb(255, 217, 0);
  }



    </style>
</head>
<body>
    <div class="headline-wrapper">
        <div class="cosmic-supratitle">INTERACTIV | Voturile din turul I, explicate altfel</div>
        <h1 class="cosmic-title">
            Cum a votat România în funcție de opt indicatori socio-economici și cum s-au diferențiat victoriile lui Simon de cele ale lui Nicușor Dan
        </h1>
    </div>
    <div class="text-container">
        <p>
            Am analizat <strong>rezultatele obținute</strong> <br>
            <strong>Scroll</strong> pentru a explora vizualizarea interactivă. Mai jos găsiți analize detaliate pe indicatori specifici.<br>
            <i>Filtrele și căutarea (sus dreapta) se aplică tuturor graficelor.</i>
        </p>
    </div>

    <div id="search-container">
        <div>
            <input id="search-input" type="text" placeholder="Caută localitate..." list="localitati-list">
            <button id="clear-search" title="Resetează căutarea">Reset</button>
            <datalist id="localitati-list"></datalist>
        </div>
        <div >
            <label for="winner-filter">Filtrează după câștigător:</label>
            <!-- *** UPDATED FILTER OPTIONS START *** -->
             <select id="winner-filter">
                <option value="all">Toți</option>
                <!-- Use full names from CSV in the 'value' attribute -->
                <option value="GEORGE-NICOLAE SIMION">GEORGE SIMION</option>
                <option value="GEORGE-CRIN-LAURENȚIU ANTONESCU">CRIN ANTONESCU</option>
                <option value="NICUȘOR-DANIEL DAN">NICUȘOR DAN</option>
                <option value="VICTOR-VIOREL PONTA">VICTOR PONTA</option>
            </select>
             <!-- *** UPDATED FILTER OPTIONS END *** -->
        </div>
    </div>

    <div class="top-spacer"></div>

    <div class="chart-wrapper">
        <div class="chart-container" id="chart-container">
            <div class="svg-inner">
                <svg id="viz" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet"></svg>
                <!-- Note: Arrowhead <defs> would go here if implemented -->
            </div>
        </div>
    </div>

    <div id="sphere-intro">
        <h2>INTERACTIV | Voturile din turul I, explicate altfel</h2>
        <p>
        <a href="https://www.hotnews.ro" target="_blank" rel="noopener noreferrer">HotNews.ro</a> a analizat <span class="highlight">rezultatele primului tur</span> al alegerilor prezidențiale din 2025
        și le-a corelat cu <span class="highlight">8 indicatori socio-economici</span> de la INS într-o serie de grafice
        interactive care ne arată cum influențează aceștia opțiunile electorale.<br> <br>
        Scopul a fost să observăm cum votează românii din diferite zone ale țării, în funcție de specificul economic și social al acestora.<br><br>
        Întregul material este <span class="highlight">interactiv.</span> <span class="highlight">Click</span>pe cercuri, grafice și filtre pentru a-l explora.
        <span class="highlight">Filtrează graficele</span> în funcție de câștigător pentru a vedea
        statistica medie a candidatului pe fiecare grafic. <br><br>
        Materialul este împărțit în secțiuni care
        se activează pe măsură ce derulezi pagina în jos.
        <span class="highlight">Scroll</span> pentru a explora toate secțiunile.
    </p>
        <button id="intro-ok">Începe</button>
    </div>

    <section id="scatter-steps">
        <div class="step" data-quad="I">
            <p><strong><span style="font-size: 1.2em;">Cum am structurat graficele</span></strong><br>
                Am selectat <strong>8 indicatori</strong> socio-economici de la Institutul Național de Statistică și i-am reprezentat în <strong>patru grafice diferite</strong>.
Fiecare grafic are două axe, iar pe fiecare axă este reprezentat câte un indicator din cei 8.
<strong>Localitățile</strong> din România apar sub formă de <strong>puncte</strong> pe aceste grafice. Poziția unui punct (adică a unei localități) ne arată care
este situația acelei localități față de cei doi indicatori aleși.
Pentru o înțelegere și mai ușoară și pentru a ajuta la navigare și interpretare,
<strong>fiecare grafic</strong> este <strong>împărțit în patru zone (cadrane)</strong>, folosind valorile mediane (valorile de mijloc)
ale indicatorilor. Astfel, putem vedea clar categoriile în care se află localitățile
și putem compara situațiile din diferite zone ale țării.</p>
        </div>
        <div class="step" data-quad="II">
            <p><strong><span style="font-size: 1.2em;">Cum interpretezi cadranele</span></strong><br>
                <strong>Cele patru cadrane</strong> din fiecare grafic reprezintă <strong>patru tipuri diferite de situații.</strong>
                De exemplu, dacă o localitate are vârsta medie a populației mare și suprafața locuibilă
                pe cap de locuitor mică, asta arată că populația este îmbătrânită și locuiește în zone
                aglomerate sau cu situație financiară mai modestă.
                Cu cât o localitate este poziționată mai aproape de marginile graficului (extremele cadranului),
                cu atât situația respectivă este mai accentuată. Am dat câte un nume generic fiecărui tip de situație
                din cadrane, dar aceste denumiri sunt doar orientative și exemplele nu se limitează strict la ele.</p>
        </div>
        <div class="step" data-quad="III">
            <p><strong><span style="font-size: 1.2em;">De ce sunt utile cadranele</span></strong><br>
                În loc să analizăm fiecare indicator separat, am ales să vedem <strong>cum se combină doi indicatori importanți pentru a înțelege povestea localității.</strong>
                Astfel, putem observa dacă și cum sunt legate între ele situația economică, socială și politică.
                Acest tip de analiză ne ajută să înțelegem mai ușor relația dintre indicatorii analizați și realitatea din fiecare zonă.</p>
        </div>
        <div class="step" data-quad="IV">
            <p><strong><span style="font-size: 1.2em;">Caută localitatea, filtrează informația și explorează graficele</span></strong><br>
                Graficul este interactiv. Poți muta cursorul peste un cerc pentru a vedea detalii despre localitatea respectivă,
                poți căuta direct numele unei localități sau poți alege să vezi doar localitățile în care a câștigat
                un anumit candidat.</p>
        </div>
         <div class="step" data-quad="all"> <!-- This step helps reset when scrolling past the last specific quadrant step -->
             <p><strong>Scroll în continuare pentru a explora graficele</strong></p>
         </div>
    </section>

    <section id="flourish-block">
        <h2 class="cosmic-title" style="margin-bottom: 5vh; padding-top: 5vh;">Analiza detaliată pe indicatori statici</h2>
        <!-- Added data-chart-id attribute matching the SVG ID -->
        <div id="scatter-container-1" class="scatter-plot-container" data-chart-id="scatter-viz-1">
            <svg id="scatter-viz-1" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer">
                <strong>Ce ne poate spune combinația dintre vârsta medie a populației și suprafața locuibilă pe persoană?</strong><br>
                Această combinație scoate la iveală tipuri distincte de comunități: locuri unde populația e îmbătrânită dar trăiește în locuințe mari,
                zone tinere, dar dense și aglomerate, sau suburbii în creștere cu familii tinere și spațiu generos.
                Graficul ne arată nu doar nivelul de trai, ci și direcții demografice: unde s-au retras vârstnicii,
                unde se concentrează familiile înstărite, sau care sunt zonele unde tinerii trăiesc în condiții mai restrânse.
                În ansamblu, aceste relații reflectă mobilitatea socială, presiunea urbană și transformările economice ale fiecărei regiuni.<br><br>
                <ul>
<li><strong>Localitățile din dreapta sus (vârstă medie mare și spațiu generos)</strong>sunt adesea foste orașe istorice sau stațiuni,
unde populația tânără a plecat, iar cei rămași trăiesc în case mari.</li><br>
<li><strong>În dreapta jos,</strong> vedem orașe mici sau cartiere vechi, unde locuiesc oameni mai
în vârstă în locuințe mici – semn al unor condiții mai modeste.</li><br>
<li><strong>Stânga sus</strong> ne arată suburbii sau localități periurbane
mai înstărite, cu familii tinere care trăiesc în case mari.</li><br>
<li><strong>Stânga jos</strong> indică orașe mari și aglomerate, dominate de populație tânără
care locuiește în spații restrânse.</li></ul><br>
<strong>Simion, învingător în localități cu media de vârstă mai mare și spațiu locuibil mic </strong><br><br>
Din dispunerea rezultatelor pe grafic se observă cum Nicușor Dan iese clar în evidență
câștigând în orașe și localități periurbane prospere - suprafața medie pe
locuitor fiind de 34,9 mp. Dan a câștigat votul și pe zone unde vârsta medie
a populației este situată între 35 și 45 de ani, media de vârstă în localitățile
câștigate fiind de 38,1 ani.<br><br>
De cealaltă parte, scorurile înregistrate de George Simion sunt mult mai
răsfirate pe grafic - practic Simion a câștigat din toate categoriile
de vârstă și din toate mediile. Pe grafic însă se poate vedea o concentrație spre zonele rurale sau urbane medii și mici, cu medie de vârstă mai înaintată (41,8 ani) și suprafețe locuibile pe cap de locuitor mai mici în general (20,7 mp).

            </p>
        </div>

        <div id="scatter-container-2" class="scatter-plot-container" data-chart-id="scatter-viz-2">
            <svg id="scatter-viz-2" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce ne arată relația dintre plecările cu domiciliul și șomajul local?</strong><br>
            Combinația dintre câți oameni pleacă dintr-o localitate și câți nu au un loc de muncă ne spune multe despre
            cât de bine funcționează acea comunitate. Plecările cu domiciliul arată cât de atractiv (sau nu)
            este un loc pentru a trăi. Șomajul arată cât de greu este să găsești un loc de muncă acolo.
            Când ambele sunt ridicate, înseamnă că oamenii pleacă din cauza lipsei de oportunități. Este semnul unei comunități
            aflate în dificultate. În schimb, acolo unde oamenii rămân și șomajul este scăzut,
            avem o localitate mai stabilă, unde locuitorii își pot construi un viitor. Această combinație
            ne ajută să înțelegem care sunt zonele vulnerabile, dar și care reușesc să-și păstreze echilibrul
            economic și social.</p>
            <ul>
<li><strong>Dreapta sus:</strong> localități cu șomaj mare și plecări frecvente – oamenii pleacă din cauza lipsei oportunităților.</li><br>
<li><strong>Dreapta jos:</strong> localități cu plecări frecvente, dar șomaj scăzut – oamenii pleacă, deși există locuri de muncă. Pot fi zone tranzitorii.</li><br>
<li><strong>Stânga sus:</strong> plecări puține și șomaj mare – populația rămâne, deși nu are acces la locuri de muncă, posibil din lipsă de alternative.</li><br>
<li><strong>Stânga jos:</strong> localități stabile, cu plecări reduse și șomaj mic, semn de echilibru și atractivitate locală.</li><br>
            </ul>
<strong>Nicușor Dan, câștigător în localități cu șomaj mic</strong><br><br>
Simion a câștigat votul din primul tur în 2701 localități, iar media
în localitățile câștigate arată un șomaj de 2%, cu o populație plecată de 1,9%.
În comparație, Nicușor a câștigat doar 34 de localități, dar toate sunt
zone urbane sau periurbane, cu mari orașe care înregistrează o pondere
mai mare de plecări cu domiciliul (media de 2,7%). În schimb localitățile
adjudecate de Nicușor Dan au o medie mică de șomeri: 0,3%.


        </div>

        <div id="scatter-container-3" class="scatter-plot-container" data-chart-id="scatter-viz-3">
            <svg id="scatter-viz-3" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce ne arată relația dintre numărul de salariați și veniturile fiscale locale?</strong><br>
            Această combinație ne ajută să înțelegem cât de activă este economia locală și cât de eficientă este administrația
            în a colecta bani pentru bugetul comunității. datele despre cotele de impozit sunt luate de la Ministerul Finanțelor și se referă la anul 2022.
            Am împărțit aceste valori la populație din 2022 pentru a vedea împozitul mediu/cap de locuitor.
            Numărul de salariați raportat la populație arată câți oameni contribuie efectiv la economie prin muncă.
            Veniturile fiscale locale per locuitor reflectă câți bani se colectează.
            Când ambele valori sunt ridicate, vorbim de comunități dinamice, cu o economie puternică
            și administrație funcțională. Când ambele sunt scăzute, e semn de slăbiciune economică,
            adesea legată de migrație, șomaj sau lipsa unei baze de impozitare solide.</p>
            <ul>
<li><strong>Dreapta sus:</strong> localități cu mulți salariați și venituri fiscale mari. Sunt comunități prospere, bine administrate și cu economie diversificată.</li><br>
<li><strong>Dreapta jos:</strong> localități cu mulți salariați, dar venituri fiscale mici, semn că sunt zone cu salarii foarte mici, probabil zone industriale</li><br>
<li><strong>Stânga sus:</strong> localități cu puțini salariați, dar venituri fiscale mari. Sunt posibile zone turistice, cu venituri din proprietăți sau venituri speciale.</li><br>
            <li><strong>Stânga jos:</strong> localități fragile, cu puțini salariați și venituri fiscale scăzute, semn al unui potențial economic slab.</li>
            </ul>
            <strong>Impozitul mediu în localitățile câștigate de Simion: sub 200 de lei / În cele ale lui Nicușor Dan: 1.300 lei</strong><br><br>
Pe acest grafic ies în evidență localitățile câștigate de Nicușor Dan care
se poziționează preponderent ca zone cu mai mulți salariați (35%)
și solide din punct de vedere al colectării fiscale (1.319 impozit mediu/loc).
În comparație, Simion a câștigat în peste 2.700 de localități care oferă o medie
a salariaților de 6,9% din totalul populației, cu un impozit mediu per locuitor
de 188 de lei. <br><br>
În același timp din grafic reies o serie de localități unde și Simion și Antonescu au câștigat ce au caracteristicile unor zone sărace sau zone unde, în ciuda numărului mai mici de angajați, există un grad mare de impozitare (cadranul I din grafic).

        </div>

        <div id="scatter-container-4" class="scatter-plot-container" data-chart-id="scatter-viz-4">
            <svg id="scatter-viz-4" viewBox="0 0 900 550" preserveAspectRatio="xMidYMid meet"></svg>
            <p class="scatter-explainer"><strong>Ce ne arată relația dintre fondurile europene atrase pe cap de locuitor și numărul de pacienți care revin unui medic?</strong><br>
            Această combinație de indicatori, deși pare necorelată, ne ajută să înțelegem dacă
            investițiile publice contribuie, direct sau indirect, la îmbunătățirea accesului
            la servicii medicale. România are în continuare zone în care medicii nu sunt atrași să se stabilească.
            Ne referim aici cel mai frecvent la medicii de familie. Fondurile europene atrase,
            indiferent de sectorul în care sunt folosite, sprijină dezvoltarea locală prin infrastructură mai bună,
            servicii publice modernizate, condiții mai bune de trai. Toate acestea pot face o localitate
            mai atractivă pentru medici și alți specialiști. Numărul mare de pacienți per medic
            indică un sistem medical suprasolicitat. Dacă o localitate atrage fonduri europene consistente,
            dar rămâne cu puțini medici, e semn că banii nu se transformă încă în servicii publice eficiente.
            În schimb, acolo unde fondurile sunt mari și pacienții per medic puțini,
            investițiile par să contribuie la o rețea medicală mai echilibrată.</p>
            <ul>
<li><strong>Dreapta sus:</strong> localități cu fonduri europene mari și mulți pacienți per medic indică investiții mari, dar lipsă de personal medical sau acces slab la sănătate.</li><br>
<li><strong>Dreapta jos:</strong> localități cu fonduri mari și puțini pacienți per medic unde investițiile contribuie la servicii publice mai bune care atrage medici.</li><br>
<li><strong>Stânga sus:</strong> localități cu fonduri reduse și mulți pacienți per medic. Sunt zone vulnerabile, cu acces medical limitat și puține investiții.</li><br>
<li><strong>Stânga jos:</strong> localități cu fonduri reduse și mai puțini pacienți per medic sunt posibile excepții, unde rețeaua medicală funcționează în ciuda lipsei de investiții majore.</li>
            </ul>
<strong>Mai mulți bani europeni atrași de localitățile câștigate de Dan și Antonescu, decât cele adjudecate de Simion</strong><br><br>
În această reprezentare grafică apar, în dreptul localităților câștigate la vot de
George Simion, o polarizare a zonelor unde investițiile europene sunt minime
sau chiar zero, iar în cazul multor localități și numărul de pacienți pe
medic este foarte ridicat. <br><br>
În medie, în dreptul localităților adjudecate de Simon vorbim de 1.931
de pacienți per medic, cu o investiție medie de fonduri europene per cap de
locuitor de doar 18 lei. În cazul localităților adjudecate de Nicușor Dan acestea
sunt poziționate în partea de jos a graficului, cu investiții europene
mai mari pe cap de locuitor (43 de lei), dar cu acces mult mai bun la medici
(725 de pacienți per medic). <br><br>
Localitățile câștigate la vot de Crin Antonescu arată o dispunere mai echilibrată, cu multe zone unde sunt contabilizate și investiții din fonduri europene (25 de lei/loc), dar și zone unde numărul de pacienți per medic este ridicat (media de 1.722 pacienți/medic).


        </div>
    </section>

    <div class="tooltip" id="tooltip"></div>

    <!-- START: Candidate Summary Pop-up HTML -->
    <div id="candidate-summary-popup">
        <div id="summary-text"></div>
        <div id="mini-chart-container">
            <svg id="mini-chart-svg"></svg>
        </div>
        <button id="close-summary-popup" title="Închide">&times;</button>
    </div>



    <script>

        const DEBUG_MODE = true;


        function throttle(func, limit) {
            let lastFunc;
            let lastRan;
            return function(...args) {
                const context = this;
                if (!lastRan) {
                    func.apply(context, args);
                    lastRan = Date.now();
                } else {
                    clearTimeout(lastFunc);
                    lastFunc = setTimeout(function() {
                        if ((Date.now() - lastRan) >= limit) {
                            func.apply(context, args);
                            lastRan = Date.now();
                        }
                    }, limit - (Date.now() - lastRan));
                }
            }
        }

        let allDataGlobal;
        const mainWidth = 1000, mainHeight = 700;
        const plotWidth = 900, plotHeight = 550;
        const margin = { top: 60, right: 60, bottom: 60, left: 80 };
        const marginMain = { top: 60, right: 80, bottom: 70, left: 90 };

        const mobileDiameter = 3;
        const desktopDiameterLarge = 4.2;
        const desktopDiameterMedium = 4;
        const baseCircleDiameter = window.innerWidth <= 600 ? mobileDiameter : window.innerWidth > 800 ? desktopDiameterLarge : desktopDiameterMedium;

        const svgMain = d3.select("#viz");
        const tooltip = d3.select("#tooltip");
        const chartMain = svgMain.append("g").attr("id", "chartGroup");
        const searchEl = d3.select("#search-container");

        const summaryPopup = d3.select("#candidate-summary-popup");
        const summaryTextEl = d3.select("#summary-text");
        const miniChartSvg = d3.select("#mini-chart-svg");
        const closeSummaryButton = d3.select("#close-summary-popup");

        const winnerColors = {
            "GEORGE-NICOLAE SIMION": "#FFB623",
            "GEORGE-CRIN-LAURENȚIU ANTONESCU": "#00B7FF",
            "NICUȘOR-DANIEL DAN": "#4DD400",
            "VICTOR-VIOREL PONTA": "#FF2A1F"
        };
        const colorScale = d3.scaleOrdinal(Object.keys(winnerColors), Object.values(winnerColors));

        let currentView = "sphere";
        let currentFilter = "all";
        let mainCircles;
        let staticCircles = [];
        let staticConfigs = {};
        let activeQuad = "all";
        let mainScatterConfig = {};
        let staticPlotsVisible = false;
        let observerInitialized = false;
        let activeStaticPlotConfig = null;

        let isViewTransitioning = false;
        const SCROLL_THROTTLE_LIMIT = 150;


        const normalize = str => (str || "").toString().normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().trim();


        function showSearchControls() { searchEl.classed("visible", true); }
        function hideSearchControls() { searchEl.classed("visible", false); }
        function updateSearchControlsVisibility() {
            if ((currentView === 'map' || currentView === 'scatter') || staticPlotsVisible) {
                showSearchControls();
            } else {
                hideSearchControls();
            }
        }


        function basicTooltip(d) {
            const jud = d.jud || 'N/A';
            const uat = d.uat || 'N/A';
            const castigator = d.Castigator || 'N/A';
            const procentCastigator = d["Procent castigator"] != null ? d["Procent castigator"].toFixed(2) + '%' : 'N/A';
            const prezenta = d.Prezenta != null ? d.Prezenta.toFixed(2) + '%' : 'N/A';
            return `<strong>${jud}</strong><br/>${uat}<br/>Câștigător: ${castigator}<br/>Procent: ${procentCastigator}<br/>Prezența: ${prezenta}`;
        }

        function scatterTooltip(d, config) {
            const xValue = d[config.xField] !== undefined && d[config.xField] !== null ? d[config.xField].toFixed(config.xDecimals ?? 2) : 'N/A';
            const yValue = d[config.yField] !== undefined && d[config.yField] !== null ? d[config.yField].toFixed(config.yDecimals ?? 2) : 'N/A';
            const jud = d.jud || 'N/A';
            const uat = d.uat || 'N/A';
            const castigator = d.Castigator || 'N/A';
            const procentCastigator = d["Procent castigator"] != null ? d["Procent castigator"].toFixed(2) + '%' : 'N/A';
            const prezenta = d.Prezenta != null ? d.Prezenta.toFixed(2) + '%' : 'N/A';
            return `<strong>${jud}</strong><br/>${uat}<br/>${config.xLabel}: ${xValue}${config.xUnit ?? ''}<br/>${config.yLabel}: ${yValue}${config.yUnit ?? ''}<br/>Câștigător: ${castigator}<br/>Procent: ${procentCastigator}<br/>Prezența: ${prezenta}`;
         }
         function updateTooltipPosition(event) {
            const tRect = tooltip.node().getBoundingClientRect();
            let left = event.pageX + 10, top = event.pageY - 15;
            const marginTT = 10;
            if (left + tRect.width > window.innerWidth - marginTT) left = event.pageX - tRect.width - 10;
            if (top + tRect.height > window.innerHeight - marginTT) top = event.pageY - tRect.height - 5;
            if (top < marginTT) top = marginTT;
            if (left < marginTT) left = marginTT;
            tooltip.style("left", left + "px").style("top", top + "px");
         }


        function createSpherePositions(data, radius = 250){
            data.forEach((d,i) => {
                const phi = Math.acos(-1 + (2 * i) / data.length);
                const theta = Math.sqrt(data.length * Math.PI) * phi;
                d.sphere_x = radius * Math.sin(phi) * Math.cos(theta);
                d.sphere_y = radius * Math.sin(phi) * Math.sin(theta);
                d.sphere_z = radius * Math.cos(phi);
            });
        }
        let rotationAngle = 0;
        const sphereAnimation = anime({
            targets: { angle: 0 }, angle: 2 * Math.PI, duration: 35000, easing: 'linear',
            loop: true, autoplay: false,
            update: anim => {
                rotationAngle = anim.animations[0].currentValue;
                if (currentView === "sphere") updateSphereVisuals();
            }
        });
        function updateSphereVisuals() {
            const f = 400, cx = mainWidth / 2, cy = mainHeight / 2;
            if (!mainCircles) return;
            mainCircles.each(function(d) {
                const xRot = d.sphere_x * Math.cos(rotationAngle) - d.sphere_z * Math.sin(rotationAngle);
                const zRot = d.sphere_x * Math.sin(rotationAngle) + d.sphere_z * Math.cos(rotationAngle);
                const scale = f / (f + zRot + 1e-6);
                d.display_x = cx + xRot * scale;
                d.display_y = cy + d.sphere_y * scale;
                d.base_sphere_r = Math.max(1, baseCircleDiameter * (scale > 0 ? scale : 0));
                d.display_opacity_z = Math.max(0.1, Math.min(1, (f - zRot) / (f * 1.5)));
            });
            applyGlobalFilterAndSearch();
        }


        function isPointInQuad(d, config, quad) {
            if (!config || !config.xField || !config.yField || !allDataGlobal) return false;
            const xMedian = config._xMedian ?? (config._xMedian = d3.median(allDataGlobal, dataPoint => dataPoint[config.xField]));
            const yMedian = config._yMedian ?? (config._yMedian = d3.median(allDataGlobal, dataPoint => dataPoint[config.yField]));
            if (xMedian === undefined || yMedian === undefined || xMedian === null || yMedian === null) return false;
            const xVal = d[config.xField], yVal = d[config.yField];
            if (xVal === undefined || yVal === undefined || xVal === null || yVal === null) return false;

            let pointQuad = "";
            if (xVal <= xMedian && yVal >= yMedian) pointQuad = "I";
            else if (xVal > xMedian && yVal >= yMedian) pointQuad = "II";
            else if (xVal <= xMedian && yVal < yMedian) pointQuad = "III";
            else if (xVal > xMedian && yVal < yMedian) pointQuad = "IV";
            return pointQuad === quad;
         }

        function hideSummaryPopup() {
            summaryPopup.classed("visible", false);
            miniChartSvg.selectAll("*").remove();
        }

        function showSummaryPopup(candidateName, candidateData, config) {
            if (DEBUG_MODE) console.log("[showSummaryPopup] Called. Candidate:", candidateName, "Config ID:", config ? config.id : "N/A", "Config Title:", config ? config.title : "N/A");
            if (!config || !config.xField || !config.yField) {
                if (DEBUG_MODE) console.warn("[showSummaryPopup] Invalid config provided:", config);
                hideSummaryPopup();
                return;
            }
            if (!candidateData) {
                hideSummaryPopup();
                return;
            }

            const validCandidateData = candidateData.filter(d =>
                d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number' &&
                d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number'
            );

            if (validCandidateData.length === 0) {
                 summaryTextEl.html(`<p><strong>${candidateName.replace(/-/g, ' ')}</strong> a câștigat ${candidateData.length} localități, dar nu există date valide pentru axele curente (<i>${config.xLabel}</i> / <i>${config.yLabel}</i>) în aceste localități.</p>`);
                 miniChartSvg.selectAll("*").remove();
                 summaryPopup.classed("visible", true);
                 return;
            }

            const medianX = d3.median(validCandidateData, d => d[config.xField]);
            const medianY = d3.median(validCandidateData, d => d[config.yField]);
            const count = candidateData.length;
            const xValStr = medianX !== undefined ? medianX.toFixed(config.xDecimals ?? 1) + (config.xUnit ?? '') : 'N/A';
            const yValStr = medianY !== undefined ? medianY.toFixed(config.yDecimals ?? 1) + (config.yUnit ?? '') : 'N/A';

            summaryTextEl.html(`<p><strong>${candidateName.replace(/-/g, ' ')}</strong> a câștigat ${count} localități.
               Mediane în localitățile câștigate:
                <br> • <i>${config.xLabel}</i>: ${xValStr}
                <br> • <i>${config.yLabel}</i>: ${yValStr}</p>`);
            drawMiniChart(validCandidateData, config, medianX, medianY, candidateName);
            summaryPopup.classed("visible", true);
        }

        function drawMiniChart(data, config, medianX, medianY, candidateName) {
            miniChartSvg.selectAll("*").remove();
            const candidateColor = winnerColors[candidateName] || '#AAAAAA';
            const miniMargin = { top: 5, right: 20, bottom: 20, left: 45 };
            const containerWidth = parseInt(miniChartSvg.style("width"));
            const containerHeight = parseInt(miniChartSvg.style("height"));

            if (!containerWidth || !containerHeight || containerWidth <= 0 || containerHeight <= 0) {
                 if (DEBUG_MODE) console.warn("[drawMiniChart] Mini chart container has no valid dimensions.");
                 return;
            }
            const miniWidth = containerWidth - miniMargin.left - miniMargin.right;
            const miniHeight = containerHeight - miniMargin.top - miniMargin.bottom;
            if (miniWidth <= 0 || miniHeight <= 0) {
                 if (DEBUG_MODE) console.warn("[drawMiniChart] Mini chart calculated dimensions are invalid.");
                 return;
            }

            const chartGroup = miniChartSvg.append("g")
                .attr("transform", `translate(${miniMargin.left},${miniMargin.top})`);
            let contextXScale, contextYScale;
            const validDataForExtentContext = allDataGlobal.filter(d =>
                 d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number' &&
                 d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number'
            );

            if (validDataForExtentContext.length > 0) {
                 const xExtentContext = d3.extent(validDataForExtentContext, d => d[config.xField]);
                 const yExtentContext = d3.extent(validDataForExtentContext, d => d[config.yField]);
                 const xDomainContext = (xExtentContext[0] === undefined || xExtentContext[1] === undefined) ? [0, 1] : xExtentContext;
                 const yDomainContext = (yExtentContext[0] === undefined || yExtentContext[1] === undefined) ? [0, 1] : yExtentContext;
                 contextXScale = d3.scaleLinear().domain(xDomainContext).nice();
                 contextYScale = d3.scaleLinear().domain(yDomainContext).nice();
            }

            if (!contextXScale || !contextYScale) {
                 if (DEBUG_MODE) console.warn("[drawMiniChart] Cannot be drawn without context scales for config:", config ? config.id : "N/A");
                 chartGroup.append("text").attr("x", miniWidth / 2).attr("y", miniHeight / 2).attr("text-anchor", "middle").attr("font-size", "10px").attr("fill", "#aaa").text("Eroare scală");
                 return;
            }

            const miniX = d3.scaleLinear().domain(contextXScale.domain()).range([0, miniWidth]);
            chartGroup.append("g").attr("class", "mini-axis").attr("transform", `translate(0, ${miniHeight})`)
                .call(d3.axisBottom(miniX).ticks(3).tickSize(3).tickPadding(2));
            chartGroup.append("text").attr("class", "mini-axis-label").attr("x", miniWidth / 2).attr("y", miniHeight + miniMargin.bottom - 0.1).text(config.xLabel);

            if (medianX !== undefined && isFinite(miniX(medianX))) {
                chartGroup.append("line").attr("class", "mini-median-line").attr("x1", miniX(medianX)).attr("x2", miniX(medianX)).attr("y1", 0).attr("y2", miniHeight).style("stroke", candidateColor);
                chartGroup.append("text").attr("class", "mini-median-label").attr("x", miniX(medianX)).attr("y", -2).attr("text-anchor", "middle").text(medianX.toFixed(config.xDecimals ?? 1)).style("fill", candidateColor);
            }

            const miniY = d3.scaleLinear().domain(contextYScale.domain()).range([miniHeight, 0]);
            chartGroup.append("g").attr("class", "mini-axis").call(d3.axisLeft(miniY).ticks(3).tickSize(3).tickPadding(2));
            chartGroup.append("text").attr("class", "mini-axis-label").attr("transform", "rotate(-90)").attr("x", -miniHeight / 2).attr("y", -miniMargin.left + 12).text(config.yLabel);

            if (medianY !== undefined && isFinite(miniY(medianY))) {
                 chartGroup.append("line").attr("class", "mini-median-line").attr("x1", 0).attr("x2", miniWidth).attr("y1", miniY(medianY)).attr("y2", miniY(medianY)).style("stroke", candidateColor);
                 chartGroup.append("text").attr("class", "mini-median-label").attr("x", -3).attr("y", miniY(medianY)).attr("text-anchor", "end").attr("alignment-baseline", "middle").text(medianY.toFixed(config.yDecimals ?? 1)).style("fill", candidateColor);
             }
        }


        function applyGlobalFilterAndSearch() {
            const searchTerm = normalize(d3.select("#search-input").property("value"));
            const isSearching = searchTerm.length > 0;
            const selectedWinner = d3.select("#winner-filter").property("value");
            currentFilter = selectedWinner;

            let showPopupDecision = false;
            let configForPopup = null;
            const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);

            if (selectedWinner !== 'all' && !isSearching) {
                if (staticPlotsVisible && activeStaticPlotConfig) {
                    configForPopup = activeStaticPlotConfig;
                    if (DEBUG_MODE) console.log(`[applyGlobalFilterAndSearch] Popup Context: ACTIVE STATIC (${activeStaticPlotConfig.id}), staticPlotsVisible=${staticPlotsVisible}, MainOpacity: ${mainChartOpacity.toFixed(2)}`);
                }
                else if (currentView === 'scatter' && mainChartOpacity >= 0.5) {
                    configForPopup = mainScatterConfig;
                    if (DEBUG_MODE) console.log(`[applyGlobalFilterAndSearch] Popup Context: MAIN SCATTER (${mainScatterConfig.id}), MainOpacity: ${mainChartOpacity.toFixed(2)}, staticPlotsVisible=${staticPlotsVisible}, activeStaticPlotConfig=${activeStaticPlotConfig?.id}`);
                } else {
                    if (DEBUG_MODE) {
                        console.log(`[applyGlobalFilterAndSearch] Popup Context: No specific config or conditions not met. SelectedWinner: ${selectedWinner}, IsSearching: ${isSearching}, staticPlotsVisible=${staticPlotsVisible}, activeStaticPlotConfig=${activeStaticPlotConfig?.id}, mainChartOpacity=${mainChartOpacity.toFixed(2)}, currentView=${currentView}, mainScatterConfig=${mainScatterConfig?.id}`);
                    }
                }
            }

            if (configForPopup) {
                const candidateSpecificData = allDataGlobal.filter(d => d.Castigator === selectedWinner);
                showSummaryPopup(selectedWinner, candidateSpecificData, configForPopup);
                showPopupDecision = true;
            }

            if (!showPopupDecision) {
                hideSummaryPopup();
                 if (DEBUG_MODE && selectedWinner !== 'all' && !isSearching) {
                    console.log(`[applyGlobalFilterAndSearch] Hiding Pop-up. Reason: No suitable configForPopup or filter not active/search active. SelectedWinner: ${selectedWinner}, IsSearching: ${isSearching}, configForPopup: ${configForPopup?.id}`);
                 }
            }

            let areaScale;
            if (allDataGlobal) {
                const validPercentages = allDataGlobal.map(d => d["Procent castigator"]).filter(p => p != null && !isNaN(p));
                if (validPercentages.length > 0) {
                    const extent = d3.extent(validPercentages);
                     if (extent[0] !== undefined && extent[1] !== undefined) {
                        areaScale = d3.scaleSqrt().domain(extent).range([baseCircleDiameter * 0.8, baseCircleDiameter * 2.2]);
                     }
                }
            }

            d3.selectAll(".data-circle").each(function(d) {
                if (isSearching && normalize(d.uat) === searchTerm) d3.select(this).raise();
            });

            d3.selectAll(".data-circle")
                .transition("filterSearch").duration(350)
                .attr("opacity", function(d) {
                    const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                    const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                    if (!isWinnerMatch || !isSearchMatch) return 0.08;
                    let baseOpacity = 1.0;
                    const isMain = d3.select(this).classed('main-circle');
                    const isStatic = d3.select(this).classed('static-circle');
                    if (isStatic) {
                         const parentSvgId = d3.select(this.ownerSVGElement).attr('id');
                         const config = staticConfigs[parentSvgId];
                         if(config && (d[config.xField] === null || d[config.yField] === null || d[config.xField] === undefined || d[config.yField] === undefined )) baseOpacity = 0.05;
                         else baseOpacity = 0.75;
                    } else if (isMain) {
                        if (currentView === 'sphere') baseOpacity = d.display_opacity_z ?? 1.0;
                        else if (currentView === 'map') baseOpacity = (d.Lat && d.Long) ? 0.8 : 0;
                        else if (currentView === 'scatter') {
                            const config = mainScatterConfig;
                             if (!config || !config.xField || !config.yField) return 0;
                            const xVal = d[config.xField], yVal = d[config.yField];
                            const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                            if (!hasValidScatterData) return 0;
                            const isQuadActive = activeQuad !== 'all';
                            const inActiveQuad = isQuadActive && isPointInQuad(d, config, activeQuad);
                            if (isQuadActive && !inActiveQuad) baseOpacity = 0.05;
                            else baseOpacity = 0.8;
                        }
                    }
                    if (isSearching && !exactSearchMatch && isWinnerMatch && isSearchMatch) baseOpacity *= 0.6;
                    if (exactSearchMatch) baseOpacity = isStatic ? 0.9 : 1.0;
                    return Math.max(0.05, baseOpacity);
                })
                .attr("stroke", function(d) {
                    const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                    const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                    if (!isWinnerMatch || !isSearchMatch) return "none";
                    if (exactSearchMatch) return "#FFFFFF";
                    if (currentFilter !== "all" && isWinnerMatch) return "#FFFFFF";
                    const isMain = d3.select(this).classed('main-circle');
                    if (isMain && currentView === 'scatter' && activeQuad !== 'all') {
                         const config = mainScatterConfig;
                          if (!config || !config.xField || !config.yField) return "none";
                         const xVal = d[config.xField], yVal = d[config.yField];
                         const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                         if (hasValidScatterData && isPointInQuad(d, config, activeQuad)) return "#FFF";
                    }
                    return "none";
                })
                .attr("stroke-width", function(d) {
                     const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                     const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                     if (!isWinnerMatch || !isSearchMatch) return 0;
                     const isMain = d3.select(this).classed('main-circle');
                     if (exactSearchMatch) return isMain ? 3 : 2.5;
                     if (currentFilter !== "all" && isWinnerMatch) return 1;
                     if (isMain && currentView === 'scatter' && activeQuad !== 'all') {
                          const config = mainScatterConfig;
                           if (!config || !config.xField || !config.yField) return 0;
                          const xVal = d[config.xField], yVal = d[config.yField];
                          const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                          if (hasValidScatterData && isPointInQuad(d, config, activeQuad)) return 1;
                     }
                     return 0;
                 })
                 .attr("cx", function(d) {
                    if (currentView === 'sphere' && d3.select(this).classed('main-circle')) return d.display_x;
                    const currentCx = d3.select(this).attr("cx");
                    return isFinite(currentCx) ? currentCx : -100;
                 })
                 .attr("cy", function(d) {
                    if (currentView === 'sphere' && d3.select(this).classed('main-circle')) return d.display_y;
                    const currentCy = d3.select(this).attr("cy");
                    return isFinite(currentCy) ? currentCy : -100;
                 })
                 .attr("r", function(d) {
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                     const boostFactor = 1.8;
                     const isMain = d3.select(this).classed('main-circle');
                     let baseRadius = 0;
                     const procent = d["Procent castigator"];
                     if (isMain) {
                         if (currentView === 'sphere') baseRadius = d.base_sphere_r ?? 0;
                         else if (currentView === 'map' && areaScale && procent != null && !isNaN(procent)) baseRadius = (d.Lat != null && d.Long != null) ? areaScale(procent) : 0;
                         else if (currentView === 'scatter') {
                             const config = mainScatterConfig;
                              if (!config || !config.xField || !config.yField) return 0;
                             const xVal = d[config.xField], yVal = d[config.yField];
                             baseRadius = (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 1.1 : 0;
                         }
                     } else {
                          const parentSvgId = d3.select(this.ownerSVGElement).attr('id');
                          const config = staticConfigs[parentSvgId];
                          if (config) {
                              const xVal = d[config.xField], yVal = d[config.yField];
                              baseRadius = (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) ? baseCircleDiameter * 0.75 : 0;
                          } else baseRadius = 0;
                     }
                     baseRadius = (typeof baseRadius === 'number' && !isNaN(baseRadius)) ? baseRadius : 0;
                     return (exactSearchMatch && baseRadius > 0) ? baseRadius * boostFactor : baseRadius;
                 })
                 .style("pointer-events", function(d) {
                    const isWinnerMatch = currentFilter === 'all' || d.Castigator === currentFilter;
                    const isSearchMatch = !isSearching || normalize(d.uat).includes(searchTerm);
                    const opacity = parseFloat(d3.select(this).attr("opacity"));
                    const radius = parseFloat(d3.select(this).attr("r"));
                    if (isWinnerMatch && isSearchMatch && radius > 0.1 && opacity > 0.06) return 'auto';
                    return 'none';
                 });
         }


        function createScatterPlot(containerSelector, data, config) {
             const svg = d3.select(containerSelector);
             const svgId = svg.attr('id');
             staticConfigs[svgId] = config;
             if (allDataGlobal && allDataGlobal.length > 0) {
                config._xMedian = d3.median(allDataGlobal, d => (d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number') ? d[config.xField] : undefined);
                config._yMedian = d3.median(allDataGlobal, d => (d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number') ? d[config.yField] : undefined);
             } else {
                 config._xMedian = undefined;
                 config._yMedian = undefined;
             }
             svg.selectAll("*").remove();
             const plotGroup = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
             const innerWidth = plotWidth - margin.left - margin.right;
             const innerHeight = plotHeight - margin.top - margin.bottom;
             const scatterPlotData = data.filter(d =>
                d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number' &&
                d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number'
             );
             const validDataForExtent = scatterPlotData;
             const xExtent = d3.extent(validDataForExtent, d => d[config.xField]);
             const yExtent = d3.extent(validDataForExtent, d => d[config.yField]);
             const xDomain = (xExtent[0] === undefined || xExtent[1] === undefined) ? [0, 1] : xExtent;
             const yDomain = (yExtent[0] === undefined || yExtent[1] === undefined) ? [0, 1] : yExtent;
             const x = d3.scaleLinear().domain(xDomain).nice().range([0, innerWidth]);
             const y = d3.scaleLinear().domain(yDomain).nice().range([innerHeight, 0]);
             const xMedian = config._xMedian, yMedian = config._yMedian;

            plotGroup.append("g").attr("class", "x-axis axis").attr("transform", `translate(0,${innerHeight})`).call(d3.axisBottom(x).ticks(7).tickSizeOuter(0));
            plotGroup.append("text").attr("class", "axis-label x-label").attr("x", innerWidth / 2).attr("y", innerHeight + margin.bottom - 15).text(config.xLabelFull || config.xLabel);
            plotGroup.append("g").attr("class", "y-axis axis").call(d3.axisLeft(y).ticks(7).tickSizeOuter(0));
            plotGroup.append("text").attr("class", "axis-label y-label").attr("transform", "rotate(-90)").attr("x", -innerHeight / 2).attr("y", -margin.left + 20).text(config.yLabelFull || config.yLabel);
            svg.append("text").attr("class", "plot-title").attr("x", margin.left + innerWidth / 2).attr("y", margin.top - 90).text(config.title); // Adjusted title Y

            if (xMedian !== undefined && xMedian !== null && isFinite(x(xMedian))) plotGroup.append("line").attr("class", "quadrant-line").attr("x1", x(xMedian)).attr("x2", x(xMedian)).attr("y1", 0).attr("y2", innerHeight);
            if (yMedian !== undefined && yMedian !== null && isFinite(y(yMedian))) plotGroup.append("line").attr("class", "quadrant-line").attr("x1", 0).attr("x2", innerWidth).attr("y1", y(yMedian)).attr("y2", y(yMedian));

            const isMobile = window.innerWidth <= 600;
            const outerLabelPadding = isMobile ? 20 : 30;
            const outerLabelYOffset = isMobile ? -25 : -35;
            const outerLabelYOffsetBottom = isMobile ? 35 : 45;

            if (config.quadLabels && xMedian !== undefined && yMedian !== undefined && xMedian !== null && yMedian !== null && isFinite(x(xMedian)) && isFinite(y(yMedian))) {
                 const labelData = [
                     { quad: 'II', anchor: 'end', xPos: innerWidth + outerLabelPadding, yPos: outerLabelYOffset },
                     { quad: 'I', anchor: 'start', xPos: -outerLabelPadding, yPos: outerLabelYOffset },
                     { quad: 'III', anchor: 'start', xPos: -outerLabelPadding, yPos: innerHeight + outerLabelYOffsetBottom },
                     { quad: 'IV', anchor: 'end', xPos: innerWidth + outerLabelPadding, yPos: innerHeight + outerLabelYOffsetBottom }
                 ];
                 labelData.forEach(lbl => {
                     const labelText = config.quadLabels[lbl.quad];
                     if (!labelText) return;
                     const lines = labelText.split('\n');
                     const textElement = plotGroup.append("text").attr("class", "quadrant-label quadrant-label-outer").attr("x", lbl.xPos).attr("y", lbl.yPos).attr("text-anchor", lbl.anchor);
                     lines.forEach((line, i) => textElement.append("tspan").attr("x", lbl.xPos).attr("dy", i === 0 ? "0" : "1.1em").text(line));
                 });
             }
             const circles = plotGroup.selectAll(".data-circle").data(scatterPlotData, d => d.uat + d.jud)
                .enter().append("circle").attr("class", "data-circle static-circle").attr("cx", d => x(d[config.xField])).attr("cy", d => y(d[config.yField]))
                .attr("r", baseCircleDiameter * 0.75).attr("fill", d => colorScale(d.Castigator) || "#999").attr("opacity", 0.75)
                .attr("stroke", "none").attr("stroke-width", 0).style("pointer-events", 'auto')
                .on("mouseover", (event, d) => {
                     tooltip.style("opacity", 1).html(scatterTooltip(d, config));
                     d3.select(event.currentTarget).raise().attr("stroke", "#000").attr("stroke-width", 1.5);
                 })
                .on("mousemove", updateTooltipPosition)
                .on("mouseout", (event, d) => {
                    tooltip.style("opacity", 0);
                     const searchTerm = normalize(d3.select("#search-input").property("value"));
                     const isSearching = searchTerm.length > 0;
                     const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                     const isHighlightedByFilter = currentFilter !== "all" && d.Castigator === currentFilter;
                     let finalStroke = "none", finalStrokeWidth = 0;
                     if (exactSearchMatch) { finalStroke = "#FFFFFF"; finalStrokeWidth = 2.5; }
                     else if (isHighlightedByFilter) { finalStroke = "#FFFFFF"; finalStrokeWidth = 1; }
                     d3.select(event.currentTarget).attr("stroke", finalStroke).attr("stroke-width", finalStrokeWidth);
                });
             staticCircles.push(circles);
             return circles;
         }


        d3.csv("scatter.csv", d3.autoType).then(data => {
            allDataGlobal = data.filter(d => d.Castigator && d.uat && d.jud);
            allDataGlobal.forEach(d => {
                const checkAndConvert = (value) => {
                    if (value === "#N/A" || value === "#DIV/0!") return null;
                    if (value != null && typeof value === 'string') {
                        const cleanedValue = parseFloat(String(value).replace(",", "."));
                        return isNaN(cleanedValue) ? null : cleanedValue;
                    }
                     if (value == null || isNaN(value)) return null;
                    return value;
                };
                const fieldsToClean = ["Procent castigator", "Prezenta", "Lat", "Long", "Procent plecari din populatie (2023)", "Suprafata locuibila/cap de locuitor (m patrati) 2023", "Numarul de salariati raportat la populatie (% din populatie) 2023", "Cote de impozit raportat la populatie (2022)", "Fonduri pe cap de locuitor (2022)", "Pacienti la un medic 2023", "Varsta medie a populatiei in 2023", "Ponderea somerilor in 2023"];
                fieldsToClean.forEach(field => {
                    if (d.hasOwnProperty(field)) d[field] = checkAndConvert(d[field]);
                    else d[field] = null;
                });
            });

            const scatterConfig1 = { id: "scatter-viz-1", xField: "Varsta medie a populatiei in 2023", yField: "Suprafata locuibila/cap de locuitor (m patrati) 2023", xLabel: "Vârsta medie", yLabel: "Suprafață/loc.", xUnit: " ani", yUnit: " m²", xDecimals: 1, yDecimals: 1, title: "Vârsta medie a populației și suprafața locuibilă/cap de locuitor", xLabelFull: "Vârsta medie a populației (ani)", yLabelFull: "Suprafață locuibilă/locuitor (m²)", quadLabels: { I: "I. Suburbii sau localități \nperiurbane prospere, \nspațiu mare", II: "II. Localități îmbătrânite\n și spații de locuit mari", III: "III. Orașe cu cartiere \naglomerate/densitate mare", IV: "IV. Zone rurale sărace \ncu pop. vârstnică" } };
            const scatterConfig2 = { id: "scatter-viz-2", xField: "Procent plecari din populatie (2023)", yField: "Ponderea somerilor in 2023", xLabel: "Plecări", yLabel: "Șomeri", xUnit: "%", yUnit: "%", xDecimals: 1, yDecimals: 1, title: "Plecările din localitate și ponderea șomerilor", xLabelFull: "Procent plecări din populație (%)", yLabelFull: "Pondere șomeri în populație (%)", quadLabels: { I: "I. Zone unde populația \nrămâne din lipsă \nde alternative", II: "II. Zone aflate \nîn declin economic sever", III: "III. Zone stabile economic", IV: "IV. Zone dinamice, \ndar tranzitorii" } };
            const scatterConfig3 = { id: "scatter-viz-3", xField: "Numarul de salariati raportat la populatie (% din populatie) 2023", yField: "Cote de impozit raportat la populatie (2022)", xLabel: "Salariați", yLabel: "Impozit/loc.", xUnit: "%", yUnit: " lei", xDecimals: 1, yDecimals: 0, title: "Salariați vs. Venituri din Impozite", xLabelFull: "Salariați / Populație (%)", yLabelFull: "Cote impozit / Populație (lei/loc.)", quadLabels: { I: "I. Comunități mici/turistice \nsau cu venituri speciale", II: "II. Economie solidă, \ncolectare fiscală eficientă", III: "III. Zone sărace, \nfără activitate economică", IV: "IV. Zone industriale \nsau muncitorești \ncu salarii mici" } };
            const scatterConfig4 = { id: "scatter-viz-4", xField: "Fonduri pe cap de locuitor (2022)", yField: "Pacienti la un medic 2023", xLabel: "Fonduri UE/loc.", yLabel: "Pacienți/medic", xUnit: " lei", yUnit: "", xDecimals: 0, yDecimals: 0, title: "Fonduri Europene vs. Acces la Medici", xLabelFull: "Fonduri europene / Locuitor (lei)", yLabelFull: "Număr pacienți / medic", quadLabels: { I: "I. Zone sărace, \nfără fonduri", II: "II. Investiții recente \nfără impact asupra sistemului medical", III: "III. Zone izolate, populație \nmică sau posibile excepții", IV: "IV. Investiții consistente, \ninfrastructură bună" } };

            mainScatterConfig = scatterConfig1;
            if (allDataGlobal && allDataGlobal.length > 0) {
                 const validDataForMedianX = allDataGlobal.map(d => d[mainScatterConfig.xField]).filter(v => v != null && !isNaN(v) && typeof v === 'number');
                 const validDataForMedianY = allDataGlobal.map(d => d[mainScatterConfig.yField]).filter(v => v != null && !isNaN(v) && typeof v === 'number');
                 mainScatterConfig._xMedian = validDataForMedianX.length > 0 ? d3.median(validDataForMedianX) : undefined;
                 mainScatterConfig._yMedian = validDataForMedianY.length > 0 ? d3.median(validDataForMedianY) : undefined;
            } else { mainScatterConfig._xMedian = undefined; mainScatterConfig._yMedian = undefined; }

            const validPercentagesMap = allDataGlobal.map(d => d["Procent castigator"]).filter(p => p != null && !isNaN(p));
            let areaScale;
            if (validPercentagesMap.length > 0) {
                 const extent = d3.extent(validPercentagesMap);
                 if (extent[0] !== undefined && extent[1] !== undefined) areaScale = d3.scaleSqrt().domain(extent).range([baseCircleDiameter * 0.8, baseCircleDiameter * 2.2]);
            }
            const validLongs = allDataGlobal.map(d => d.Long).filter(l => l != null && !isNaN(l));
            const validLats = allDataGlobal.map(d => d.Lat).filter(l => l != null && !isNaN(l));
            let xGeo, yGeo;
            if (validLongs.length > 0 && validLats.length > 0) {
                 xGeo = d3.scaleLinear().domain(d3.extent(validLongs)).range([marginMain.left, mainWidth - marginMain.right]);
                 yGeo = d3.scaleLinear().domain(d3.extent(validLats)).range([mainHeight - marginMain.bottom, marginMain.top]);
            }
            createSpherePositions(allDataGlobal, 250);

            mainCircles = chartMain.selectAll("circle.main-circle").data(allDataGlobal, d => d.uat + d.jud)
                .enter().append("circle").attr("class", "data-circle main-circle").attr("fill", d => colorScale(d.Castigator) || "#999")
                .attr("opacity", 0).style("pointer-events", "auto")
                .on("mouseover", (event, d) => {
                     tooltip.style("opacity", 1);
                     let configForTooltip = mainScatterConfig;
                      const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);
                      if (mainChartOpacity < 0.5 && staticPlotsVisible && activeStaticPlotConfig) configForTooltip = activeStaticPlotConfig;
                      else if (currentView !== 'scatter') configForTooltip = null;
                     if (currentView === 'sphere' || currentView === 'map' || !configForTooltip) tooltip.html(basicTooltip(d));
                     else {
                         const xVal = d[configForTooltip.xField], yVal = d[configForTooltip.yField];
                         if (xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null) tooltip.html(scatterTooltip(d, configForTooltip));
                         else tooltip.html(basicTooltip(d));
                     }
                     d3.select(event.currentTarget).raise().attr("stroke", "#000").attr("stroke-width", currentView === 'sphere' ? 2.5 : 2);
                 })
                .on("mousemove", updateTooltipPosition)
                .on("mouseout", (event, d) => {
                    tooltip.style("opacity", 0);
                    const searchTerm = normalize(d3.select("#search-input").property("value"));
                    const isSearching = searchTerm.length > 0;
                    const exactSearchMatch = isSearching && normalize(d.uat) === searchTerm;
                    const isHighlightedByFilter = currentFilter !== "all" && d.Castigator === currentFilter;
                    let inActiveQuadHighlight = false;
                     if (currentView === 'scatter' && activeQuad !== 'all') {
                         const config = mainScatterConfig;
                          if (config && config.xField && config.yField) {
                            const xVal = d[config.xField], yVal = d[config.yField];
                            const hasValidScatterData = xVal !== undefined && xVal !== null && yVal !== undefined && yVal !== null;
                            if (hasValidScatterData && isPointInQuad(d, config, activeQuad)) inActiveQuadHighlight = true;
                          }
                     }
                    let finalStroke = "none", finalStrokeWidth = 0;
                    if (exactSearchMatch) { finalStroke = "#FFFFFF"; finalStrokeWidth = 3; }
                    else if (isHighlightedByFilter) { finalStroke = "#FFFFFF"; finalStrokeWidth = 1; }
                    else if (inActiveQuadHighlight) { finalStroke = "#FFFFFF"; finalStrokeWidth = 1; }
                    d3.select(event.currentTarget).attr("stroke", finalStroke).attr("stroke-width", finalStrokeWidth);
                });
            updateSphereVisuals();
            sphereAnimation.play();

            const datalist = document.getElementById("localitati-list");
            [...new Set(allDataGlobal.map(d => d.uat).filter(Boolean))].sort((a, b) => a.localeCompare(b, "ro-RO"))
                .forEach(name => { const opt = document.createElement("option"); opt.value = name; datalist.appendChild(opt); });
            d3.select("#search-input").on("input", applyGlobalFilterAndSearch);
            d3.select("#clear-search").on("click", () => { d3.select("#search-input").property("value", ""); applyGlobalFilterAndSearch(); });
            d3.select("#winner-filter").on("change", applyGlobalFilterAndSearch);
            closeSummaryButton.on("click", hideSummaryPopup);

            staticCircles = []; staticConfigs = {};
            createScatterPlot("#scatter-viz-1", allDataGlobal, scatterConfig1);
            createScatterPlot("#scatter-viz-2", allDataGlobal, scatterConfig2);
            createScatterPlot("#scatter-viz-3", allDataGlobal, scatterConfig3);
            createScatterPlot("#scatter-viz-4", allDataGlobal, scatterConfig4);
            applyGlobalFilterAndSearch();


            function toSphere() {
                if (currentView === 'sphere' || isViewTransitioning) return;
                isViewTransitioning = true;
                hideSummaryPopup(); activeStaticPlotConfig = null;
                if (DEBUG_MODE) console.log("[ViewChange] Transitioning to Sphere");
                currentView = "sphere"; window.IO?.disconnect(); activeQuad = 'all'; observerInitialized = false;
                sphereAnimation.play(); updateSearchControlsVisibility();
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .map-scroll-hint, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();
                updateSphereVisuals();
                setTimeout(() => { isViewTransitioning = false; }, 50);
            }

            function toMap() {
                if (currentView === 'map' || !xGeo || !yGeo || isViewTransitioning) return;
                isViewTransitioning = true;
                hideSummaryPopup(); activeStaticPlotConfig = null;
                if (DEBUG_MODE) console.log("[ViewChange] Transitioning to Map");
                currentView = "map"; window.IO?.disconnect(); activeQuad = 'all'; observerInitialized = false;
                sphereAnimation.pause(); updateSearchControlsVisibility();
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .map-scroll-hint, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();

                svgMain.append("text").attr("class", "map-title").attr("x", mainWidth / 2).attr("y", marginMain.top / 2).text("Distribuția câștigătorilor pe localități");
                svgMain.append("text").attr("class", "map-subtitle").attr("x", mainWidth / 2).attr("y", marginMain.top / 2 + 22).text("Dimensiunea cercurilor indică procentul obținut de câștigător.");

                
                svgMain.append("text")
                    .attr("class", "map-scroll-hint") // New class for this text
                    .attr("x", mainWidth / 2)
                    .attr("y", mainHeight - (marginMain.bottom / 2) + 10) // Position it in the bottom margin area
                    .attr("text-anchor", "middle")
                    .style("font-size", "1.2em")
                    .style("fill", "#ffffff")
                    .text("Scroll în continuare pentru grafice");
               

                mainCircles.transition("mapPos").duration(1500).ease(d3.easeCubicInOut)
                    .attr("cx", d => (d.Long != null && !isNaN(d.Long) && isFinite(xGeo(d.Long))) ? xGeo(d.Long) : -100)
                    .attr("cy", d => (d.Lat != null && !isNaN(d.Lat) && isFinite(yGeo(d.Lat))) ? yGeo(d.Lat) : -100)
                    .attr("r", d => (d.Lat != null && d.Long != null && areaScale && d["Procent castigator"] != null && !isNaN(d["Procent castigator"])) ? areaScale(d["Procent castigator"]) : 0)
                    .end().then(() => {
                        applyGlobalFilterAndSearch();
                        isViewTransitioning = false;
                    }).catch(err => {
                        console.error("Map transition error:", err);
                        applyGlobalFilterAndSearch();
                        isViewTransitioning = false;
                    });
            }

            function toScatter() {
                if (currentView === 'scatter' || isViewTransitioning) return;
                isViewTransitioning = true;
                hideSummaryPopup(); activeStaticPlotConfig = null;
                if (DEBUG_MODE) console.log("[ViewChange] Transitioning to Main Scatter");
                currentView = "scatter"; sphereAnimation.pause(); updateSearchControlsVisibility();
                svgMain.selectAll(".axis, .axis-label, .plot-title, .map-title, .map-subtitle, .map-scroll-hint, .quadrant-line, .quadrant-label, .quadrant-overlay").remove();
                const config = mainScatterConfig;
                 if (!config || !config.xField || !config.yField) {
                     console.error("Main scatter config invalid for transition.");
                     isViewTransitioning = false; return;
                 }
                const innerWidth = mainWidth - marginMain.left - marginMain.right;
                const innerHeight = mainHeight - marginMain.top - marginMain.bottom;
                const validScatterData = allDataGlobal.filter(d =>
                     d[config.xField] != null && !isNaN(d[config.xField]) && typeof d[config.xField] === 'number' &&
                     d[config.yField] != null && !isNaN(d[config.yField]) && typeof d[config.yField] === 'number'
                 );
                 if (validScatterData.length === 0) {
                     if (DEBUG_MODE) console.warn("[toScatter] No valid data points for the main scatter plot.");
                     svgMain.append("text").attr("x", mainWidth/2).attr("y", mainHeight/2).attr("text-anchor", "middle").attr("fill", "#ccc").text("Date insuficiente pentru acest grafic.");
                     isViewTransitioning = false; return;
                 }
                const xExtent = d3.extent(validScatterData, d => d[config.xField]);
                const yExtent = d3.extent(validScatterData, d => d[config.yField]);
                const xDomain = (xExtent[0] === undefined || xExtent[1] === undefined) ? [0, 1] : xExtent;
                const yDomain = (yExtent[0] === undefined || yExtent[1] === undefined) ? [0, 1] : yExtent;
                const x = d3.scaleLinear().domain(xDomain).nice().range([marginMain.left, mainWidth - marginMain.right]);
                const y = d3.scaleLinear().domain(yDomain).nice().range([mainHeight - marginMain.bottom, marginMain.top]);
                const xMedian = config._xMedian, yMedian = config._yMedian;

                 svgMain.append("text").attr("class", "plot-title").attr("x", mainWidth / 2).attr("y", marginMain.top - 90).text(config.title); // Adjusted Y
                 svgMain.append("g").attr("class", "x-axis axis").attr("transform", `translate(0,${mainHeight - marginMain.bottom})`).call(d3.axisBottom(x).ticks(7));
                 svgMain.append("text").attr("class", "x-label axis-label").attr("x", mainWidth / 2).attr("y", mainHeight - 20).text(config.xLabelFull || config.xLabel);
                 svgMain.append("g").attr("class", "y-axis axis").attr("transform", `translate(${marginMain.left},0)`).call(d3.axisLeft(y).ticks(7));
                 svgMain.append("text").attr("class", "y-label axis-label").attr("transform", "rotate(-90)").attr("x", -(marginMain.top + innerHeight / 2)).attr("y", marginMain.left - 60).text(config.yLabelFull || config.yLabel);
                 if (xMedian !== undefined && xMedian !== null && isFinite(x(xMedian))) svgMain.append("line").attr("class", "quadrant-line").attr("x1", x(xMedian)).attr("x2", x(xMedian)).attr("y1", marginMain.top).attr("y2", mainHeight - marginMain.bottom);
                 if (yMedian !== undefined && yMedian !== null && isFinite(y(yMedian))) svgMain.append("line").attr("class", "quadrant-line").attr("x1", marginMain.left).attr("x2", mainWidth - marginMain.right).attr("y1", y(yMedian)).attr("y2", y(yMedian));

                 const isMobileMain = window.innerWidth <= 600;
                 const mainOuterLabelPadding = isMobileMain ? 20 : 30;
                 const mainOuterLabelYOffset = isMobileMain ? -25 : -35;
                 const mainOuterLabelYOffsetBottom = isMobileMain ? 35 : 45;
                 if (config.quadLabels && xMedian !== undefined && yMedian !== undefined && xMedian !== null && yMedian !== null && isFinite(x(xMedian)) && isFinite(y(yMedian))) {
                     const mainLabelData = [
                         { quad: 'II', anchor: 'end', xPos: mainWidth - marginMain.right + mainOuterLabelPadding, yPos: marginMain.top + mainOuterLabelYOffset },
                         { quad: 'I', anchor: 'start', xPos: marginMain.left - mainOuterLabelPadding, yPos: marginMain.top + mainOuterLabelYOffset },
                         { quad: 'III', anchor: 'start', xPos: marginMain.left - mainOuterLabelPadding, yPos: mainHeight - marginMain.bottom + mainOuterLabelYOffsetBottom },
                         { quad: 'IV', anchor: 'end', xPos: mainWidth - marginMain.right + mainOuterLabelPadding, yPos: mainHeight - marginMain.bottom + mainOuterLabelYOffsetBottom }
                     ];
                     mainLabelData.forEach(lbl => {
                         const labelText = config.quadLabels[lbl.quad]; if (!labelText) return;
                         const lines = labelText.split('\n');
                         const textElement = svgMain.append("text").attr("class", "quadrant-label quadrant-label-outer").attr("x", lbl.xPos).attr("y", lbl.yPos).attr("text-anchor", lbl.anchor);
                         lines.forEach((line, i) => textElement.append("tspan").attr("x", lbl.xPos).attr("dy", i === 0 ? "0" : "1.1em").text(line));
                     });
                 }
                 const overlays = svgMain.selectAll(".quadrant-overlay").data(["I","II","III","IV"]);
                 overlays.enter().append("rect").attr("class","quadrant-overlay").merge(overlays).attr("opacity", 0).attr("pointer-events","none")
                    .each(function(q){
                        if (xMedian === undefined || yMedian === undefined || xMedian === null || yMedian === null || !isFinite(x(xMedian)) || !isFinite(y(yMedian))) return;
                        const isLeft = q==="I" || q==="III", isTop = q==="I" || q==="II";
                        const xPos = isLeft ? marginMain.left : x(xMedian);
                        const yPos = isTop ? marginMain.top : y(yMedian);
                        const width = Math.max(0, isLeft ? x(xMedian)-marginMain.left : mainWidth-marginMain.right-x(xMedian));
                        const height = Math.max(0, isTop ? y(yMedian)-marginMain.top : mainHeight-marginMain.bottom-y(yMedian));
                        if (isFinite(xPos) && isFinite(yPos) && isFinite(width) && width >= 0 && isFinite(height) && height >= 0) d3.select(this).attr("x", xPos).attr("y", yPos).attr("width", width).attr("height", height);
                        else d3.select(this).attr("width", 0).attr("height", 0);
                 });
                 mainCircles.transition("scatterPos").duration(1500).ease(d3.easeCubicInOut)
                    .attr("cx", d => { const xVal = d[config.xField]; return (xVal != null && !isNaN(xVal) && typeof xVal === 'number' && isFinite(x(xVal))) ? x(xVal) : -100; })
                    .attr("cy", d => { const yVal = d[config.yField]; return (yVal != null && !isNaN(yVal) && typeof yVal === 'number' && isFinite(y(yVal))) ? y(yVal) : -100; })
                    .attr("r", d => { const xVal = d[config.xField], yVal = d[config.yField]; return (xVal != null && !isNaN(xVal) && typeof xVal === 'number' && yVal != null && !isNaN(yVal) && typeof yVal === 'number') ? baseCircleDiameter * 1.1 : 0; })
                    .end().then(() => {
                         if (DEBUG_MODE) console.log("[toScatter] Scatter transition finished. Setting up IO.");
                         applyGlobalFilterAndSearch(); setupIntersectionObserver(mainScatterConfig);
                         isViewTransitioning = false;
                    }).catch(err => {
                         console.error("Scatter transition error:", err);
                         applyGlobalFilterAndSearch();
                         isViewTransitioning = false;
                    });
            }


            const steps = document.querySelectorAll("#scatter-steps .step");
            function setupIntersectionObserver(config) {
                window.IO?.disconnect(); observerInitialized = false;
                 if (!config || !config.xField || !config.yField) {
                     if (DEBUG_MODE) console.error("[IO Setup] Aborting: Invalid config provided for steps IO.", config);
                     return;
                 }
                if (DEBUG_MODE) console.log("[IO Steps] Setting up Intersection Observer for Steps with config:", config.id);
                window.IO = new IntersectionObserver(entries => {
                    const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);
                    if (currentView !== 'scatter' || mainChartOpacity < 0.1) {
                        if (DEBUG_MODE && currentView !== 'scatter') console.log("[IO Steps Callback] Aborted, not in scatter view or main chart faded.");
                        return;
                    }
                    const minVisibilityThreshold = 0.05;
                    const visibleSteps = entries.filter(entry => entry.isIntersecting && entry.intersectionRatio >= minVisibilityThreshold);
                    let highestVisibleStep = null;
                    if (visibleSteps.length > 0) {
                        visibleSteps.sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top);
                        highestVisibleStep = visibleSteps[0].target;
                    }
                    const nextActiveQuad = highestVisibleStep ? highestVisibleStep.dataset.quad : 'all';
                    if (nextActiveQuad !== activeQuad) {
                        if (DEBUG_MODE) console.log(`[IO Steps Callback] *** Changing highlight: ${activeQuad} -> ${nextActiveQuad} *** (Highest visible: ${highestVisibleStep ? highestVisibleStep.dataset.quad : 'None'})`);
                        activeQuad = nextActiveQuad; renderHighlight(activeQuad, config);
                    }
                }, { threshold: Array.from({ length: 21 }, (_, i) => i * 0.05) });
                steps.forEach(s => window.IO.observe(s));
                if (DEBUG_MODE) console.log("[IO Steps] Observer attached to steps.");
                 if (!observerInitialized) {
                      if (DEBUG_MODE) console.log("[IO Steps Initial Check] Scheduling...");
                      setTimeout(() => {
                           const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);
                         if (currentView !== 'scatter' || !config || !config.xField || !config.yField || mainChartOpacity < 0.1) {
                            if (DEBUG_MODE) console.log("[IO Steps Initial Check] Aborted, view/config/opacity changed or invalid for initial check.");
                            return;
                         }
                         if (DEBUG_MODE) console.log("[IO Steps Initial Check] Running...");
                         const minVisibilityThreshold = 0.05;
                         const currentVisibleSteps = [];
                         steps.forEach(step => {
                            const rect = step.getBoundingClientRect();
                            const isIntersecting = rect.top < window.innerHeight && rect.bottom > 0;
                            if (isIntersecting) {
                                const visibleHeight = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
                                const ratio = Math.max(0, Math.min(1, visibleHeight / rect.height));
                                if (ratio >= minVisibilityThreshold) currentVisibleSteps.push({ target: step, top: rect.top });
                            }
                         });
                         let initialHighestStep = null;
                         if (currentVisibleSteps.length > 0) {
                             currentVisibleSteps.sort((a, b) => a.top - b.top);
                             initialHighestStep = currentVisibleSteps[0].target;
                         }
                         const initialActiveQuad = initialHighestStep ? initialHighestStep.dataset.quad : 'all';
                         if (DEBUG_MODE) console.log(`[IO Steps Initial Check] Determined initial quad: ${initialActiveQuad}.`);
                         if (initialActiveQuad !== activeQuad) {
                              if (DEBUG_MODE) console.log(`[IO Steps Initial Check] *** Setting initial highlight: ${activeQuad} -> ${initialActiveQuad} ***`);
                              activeQuad = initialActiveQuad;
                         }
                         renderHighlight(activeQuad, config); observerInitialized = true;
                     }, 350);
                 }
             }

            function renderHighlight(quad, config) {
                if (currentView !== 'scatter' || !svgMain || !svgMain.node() || !config || !config.xField || !config.yField) {
                    if (DEBUG_MODE) console.warn(`[RenderHighlight] Aborting. View: ${currentView}, SVG exists: ${!!svgMain?.node()}, Config valid: ${!!(config && config.xField && config.yField)}`);
                    if (currentView !== 'scatter') activeQuad = 'all';
                    return;
                }
                 const mainChartOpacity = parseFloat(d3.select("#chart-container").style("opacity") || 1);
                 if (mainChartOpacity < 0.1) {
                     if (DEBUG_MODE) console.log("[RenderHighlight] Aborting, main chart faded.");
                      activeQuad = 'all';
                      svgMain.selectAll(".quadrant-overlay").transition("overlayFadeOut").duration(100).attr("opacity", 0);
                     return;
                 }
                if (DEBUG_MODE) console.log(`[RenderHighlight] Rendering for quad: ${quad} with config: ${config.id}`);
                svgMain.selectAll(".quadrant-overlay").filter(qData => qData).transition("overlayHighlight").duration(300)
                    .attr("opacity", qData => (quad === "all") ? 0 : (qData === quad ? 0.12 : 0));
                applyGlobalFilterAndSearch();
            }


            const chartWrapper = document.querySelector('.chart-wrapper');
            const scatterStepsSection = document.getElementById('scatter-steps');

            const processScroll = () => {
                if (isViewTransitioning) {
                    if (DEBUG_MODE) console.log("[Scroll Process] Skipped due to active view transition.");
                    return;
                }
                const y = window.scrollY;
                const wh = window.innerHeight;
                if (!chartWrapper || !scatterStepsSection) return;
                const wrapperRect = chartWrapper.getBoundingClientRect();
                const stepsRect = scatterStepsSection.getBoundingClientRect();
                const wrapperTopDoc = wrapperRect.top + window.scrollY;
                const stepsTopDoc = stepsRect.top + window.scrollY;
                const wrapperHeight = chartWrapper.offsetHeight;

                const mapStartTrigger = wrapperTopDoc + (wrapperHeight * 0.30) - wh;
                const scatterStartTrigger = stepsTopDoc - (wh * 0.50);

                if (DEBUG_MODE && Math.random() < 0.05) {
                     console.log(`[Scroll Debug] y:${y.toFixed(0)} | mapStart:${mapStartTrigger.toFixed(0)} | scatterStart:${scatterStartTrigger.toFixed(0)} | currentView:${currentView}`);
                }
                let targetView;
                if (y < mapStartTrigger) targetView = "sphere";
                else if (y >= mapStartTrigger && y < scatterStartTrigger) targetView = "map";
                else targetView = "scatter";

                if (targetView !== currentView && !isViewTransitioning) {
                    if (DEBUG_MODE) console.log(`[Scroll Trigger] Changing view from ${currentView} to ${targetView} (y=${y.toFixed(0)})`);
                    if (targetView === "sphere") toSphere();
                    else if (targetView === "map") toMap();
                    else if (targetView === "scatter") toScatter();
                }
                updateSearchControlsVisibility();
                const intro = document.getElementById("sphere-intro");
                if (intro) {
                    if ( (currentView !== 'sphere' || y >= 80 || isViewTransitioning) && !intro.classList.contains("hidden")) {
                        intro.classList.add("hidden");
                    } else if (currentView === 'sphere' && y < 80 && !isViewTransitioning && intro.classList.contains("hidden")) {
                        intro.classList.remove("hidden");
                    }
                }
            };
            const throttledScrollHandler = throttle(processScroll, SCROLL_THROTTLE_LIMIT);
            window.addEventListener("scroll", throttledScrollHandler, { passive: true });


            const chartContainer = document.getElementById("chart-container");
            const staticPlotsSection = document.getElementById("flourish-block");
             if (chartContainer && staticPlotsSection) {
                new IntersectionObserver(
                    entries => {
                        const staticPlotsEntry = entries[0];
                        const fadeStartRatio = 0.05, fadeEndRatio = 0.25;
                        let opacity = 1;
                        const oldStaticPlotsVisible = staticPlotsVisible;
                        if (staticPlotsEntry.isIntersecting) {
                            staticPlotsVisible = true;
                            const ratio = staticPlotsEntry.intersectionRatio;
                            if (ratio >= fadeStartRatio) opacity = 1 - Math.min(1, Math.max(0, (ratio - fadeStartRatio) / (fadeEndRatio - fadeStartRatio)));
                        } else if (staticPlotsEntry.boundingClientRect.top < 0) {
                            opacity = 0; staticPlotsVisible = true;
                        } else { opacity = 1; staticPlotsVisible = false; }

                        chartContainer.style.opacity = opacity;
                        chartContainer.style.pointerEvents = opacity < 0.5 ? "none" : "auto";
                        updateSearchControlsVisibility();
                        const intro = document.getElementById("sphere-intro");
                        if (intro && opacity < 0.8) intro.classList.add("hidden");
                         if (staticPlotsVisible !== oldStaticPlotsVisible || Math.abs(parseFloat(chartContainer.style.opacity) - opacity) > 0.01) {
                             if (DEBUG_MODE && staticPlotsVisible !== oldStaticPlotsVisible) console.log(`[Flourish IO] staticPlotsVisible changed from ${oldStaticPlotsVisible} to ${staticPlotsVisible}. Opacity: ${opacity.toFixed(2)}`);
                             applyGlobalFilterAndSearch();
                         }
                        if (opacity < 0.1 && window.IO) {
                             if (DEBUG_MODE) console.log("[Flourish IO] Disconnecting Step IO due to main chart fade");
                             window.IO.disconnect(); activeQuad = 'all'; observerInitialized = false; renderHighlight('all', mainScatterConfig);
                        } else if (opacity >= 0.1 && currentView === 'scatter' && !observerInitialized && window.IO && mainScatterConfig) {
                             if (DEBUG_MODE) console.log("[Flourish IO] Re-enabling Step IO as main chart became visible");
                              setupIntersectionObserver(mainScatterConfig);
                        }
                    }, { threshold: Array.from({ length: 21 }, (_, i) => i * 0.05) }
                ).observe(staticPlotsSection);
             }

            const staticPlotContainers = document.querySelectorAll('.scatter-plot-container');
            if (staticPlotContainers.length > 0 && staticConfigs) {
                const staticPlotObserver = new IntersectionObserver(entries => {
                    let newActiveStaticPlotConfig = activeStaticPlotConfig;
                    if (!staticPlotsVisible) {
                         if (activeStaticPlotConfig !== null) {
                             if (DEBUG_MODE) console.log("[Static Plot IO] Static plots section no longer primary for context, resetting activeStaticPlotConfig.");
                             newActiveStaticPlotConfig = null;
                         }
                    } else {
                        let mostVisibleStaticPlot = null, maxRatio = -1;
                        entries.forEach(entry => {
                            if (entry.isIntersecting && entry.intersectionRatio > maxRatio) {
                                maxRatio = entry.intersectionRatio; mostVisibleStaticPlot = entry.target;
                            }
                        });
                        if (mostVisibleStaticPlot) {
                            const chartId = mostVisibleStaticPlot.dataset.chartId;
                            if (chartId && staticConfigs[chartId]) newActiveStaticPlotConfig = staticConfigs[chartId];
                        } else newActiveStaticPlotConfig = null;
                    }
                    if (newActiveStaticPlotConfig?.id !== activeStaticPlotConfig?.id || (newActiveStaticPlotConfig === null && activeStaticPlotConfig !== null) || (newActiveStaticPlotConfig !== null && activeStaticPlotConfig === null)) {
                        if (DEBUG_MODE) console.log(`[Static Plot IO] Active static config changing. Old: ${activeStaticPlotConfig?.id}, New: ${newActiveStaticPlotConfig?.id}. staticPlotsVisible: ${staticPlotsVisible}`);
                        activeStaticPlotConfig = newActiveStaticPlotConfig; applyGlobalFilterAndSearch();
                    }
                }, { threshold: Array.from({ length: 11 }, (_, i) => i * 0.1), rootMargin: "-10% 0px -30% 0px" });
                staticPlotContainers.forEach(container => staticPlotObserver.observe(container));
                 if (DEBUG_MODE) console.log("[Static Plot IO] Observer attached to static plot containers.");
            }

            const intro = document.getElementById("sphere-intro");
            const introOk = document.getElementById("intro-ok");
            if (intro && introOk) {
                function hideIntro() { intro.classList.add("hidden"); }
                introOk.addEventListener("click", hideIntro);
            }

            setTimeout(() => {
                 const y = window.scrollY; const wh = window.innerHeight;
                 if (!chartWrapper || !scatterStepsSection) { console.error("Initial view check failed: Elements not found."); toSphere(); applyGlobalFilterAndSearch(); updateSearchControlsVisibility(); return; }
                 const wrapperRect = chartWrapper.getBoundingClientRect(); const stepsRect = scatterStepsSection.getBoundingClientRect();
                 const wrapperTop = wrapperRect.top + y; const stepsTop = stepsRect.top + y;
                 const wrapperHeight = chartWrapper.offsetHeight;
                 const mapStartPoint = wrapperTop + wrapperHeight * 0.30 - wh; // Adjusted trigger
                 const scatterStartPoint = stepsTop - wh * 0.50; // Adjusted trigger

                 let initialViewFunction = toSphere;
                 if (y >= mapStartPoint && y < scatterStartPoint) initialViewFunction = toMap;
                 else if (y >= scatterStartPoint) initialViewFunction = toScatter;

                 if (DEBUG_MODE) console.log(`[Initial Load] Setting initial view: ${initialViewFunction.name} (y=${y.toFixed(0)}, mapStart=${mapStartPoint.toFixed(0)}, scatterStart=${scatterStartPoint.toFixed(0)})`);
                 initialViewFunction();
                 setTimeout(updateSearchControlsVisibility, 200);
                 setTimeout(applyGlobalFilterAndSearch, 250);
                 const introElem = document.getElementById("sphere-intro");
                 if (introElem) {
                     if (y < 80 && currentView === 'sphere' && !isViewTransitioning) introElem.classList.remove("hidden");
                     else introElem.classList.add("hidden");
                 }
                 if (DEBUG_MODE) console.log("[Initial Load] Initial view determined:", currentView);
            }, 150);

        }).catch(error => {
            console.error("Error loading or processing data:", error);
            document.body.innerHTML = `<div style="color: red; padding: 50px; text-align: center; font-size: 1.2em;">A apărut o eroare la încărcarea datelor (${error.message}). Vă rugăm reîncărcați pagina.</div>`;
        });

    </script>
    </body>
    </html>
